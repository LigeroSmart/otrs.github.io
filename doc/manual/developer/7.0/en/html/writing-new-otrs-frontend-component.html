<html><head>
<!-- otrs.github.io -->
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../../../../../documentation.css">
<script src="https://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../../../../documentation.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script>
$(document).ready(function() {

    // Hint languages to prevent false matches (php for example).
    hljs.configure({
        languages: ['perl', 'javascript', 'xml', 'html', 'css', 'json', 'yaml']
    });

    // programlistings in manuals
    $('pre.programlisting').each(function(i, block) {
        hljs.highlightBlock(block);
    });
    // code snippets in Perl API docs
    $('.pod pre').addClass('perl').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});</script>
<!-- otrs.github.io -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Writing a new OTRS frontend component</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="OTRS 7 - Developer Manual"><link rel="up" href="how-to-extend-otrs.html" title="Chapter 3. How to Extend OTRS"><link rel="prev" href="how-to-extend-otrs.html" title="Chapter 3. How to Extend OTRS"><link rel="next" href="otrs-module-layers.html" title="Using the power of the OTRS module layers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Writing a new OTRS frontend component</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="how-to-extend-otrs.html">Prev</a> </td><th width="60%" align="center">Chapter 3. How to Extend OTRS</th><td width="20%" align="right"> <a accesskey="n" href="otrs-module-layers.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="writing-new-otrs-frontend-component"></a>Writing a new OTRS frontend component</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="writing-new-otrs-frontend-component.html#frontend-component-the-goal">The Goal</a></span></dt><dt><span class="section"><a href="writing-new-otrs-frontend-component.html#using-skeleton-command">Using the Skeleton Command</a></span></dt><dt><span class="section"><a href="writing-new-otrs-frontend-component.html#the-route-configuration">The Route Configuration</a></span></dt><dt><span class="section"><a href="writing-new-otrs-frontend-component.html#component-template-code">Component Template Code</a></span></dt><dt><span class="section"><a href="writing-new-otrs-frontend-component.html#component-core-code">Component Core Code</a></span></dt><dt><span class="section"><a href="writing-new-otrs-frontend-component.html#component-style-code">Component Style Code</a></span></dt><dt><span class="section"><a href="writing-new-otrs-frontend-component.html#passing-parameters">Passing Parameters to the Route Component</a></span></dt><dt><span class="section"><a href="writing-new-otrs-frontend-component.html#component-folders">Component Folders</a></span></dt><dt><span class="section"><a href="writing-new-otrs-frontend-component.html#packaging-additional-vendor-modules">Packaging Additional Vendor Modules</a></span></dt></dl></div><p>
        In this example, we will try to write a new OTRS frontend component. Starting with OTRS 7, the framework
        supports Single Page Application frontends written in Vue.js and based on a new JavaScript toolchain. First
        iteration contains the new external interface, for which we will try to write a custom component. You will need
        to have a running OTRS development environment as specified in the chapter of the same name.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="frontend-component-the-goal"></a>The Goal</h3></div></div></div><p>
            We want to write a small frontend component that displays the text 'Hello World' when called up. This will
            be a route component, meaning it will be available in the external interface when called with a carefully
            crafted URL.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="using-skeleton-command"></a>Using the Skeleton Command</h3></div></div></div><p>
            To speed up the development, we should use a skeleton command to get a boilerplate template file which we
            can build upon.
        </p><p>
            On a running OTRS instance, call the following command to generate the template. We will use
            <code class="literal">HelloWorld</code> as the name of our new component:
        </p><p>
            </p><pre class="screen">
bin/otrs.Console.pl Dev::Code::Generate::VueComponent --component-directory /ws/MyPackage --component-subdirectory Apps/External/Components/Route --no-docs HelloWorld
            </pre><p>
        </p><p>
            where <code class="literal">--component-directory</code> is the directory of your module,
            <code class="literal">--component-subdirectory</code> path under <code class="filename">Frontend/</code> folder that will house
            the component file. For now, use <code class="literal">--no-docs</code> switch to skip creation of the documentation
            component for the design system.
        </p><p>
            This command will generate two files with following paths:
        </p><p>
            </p><pre class="screen">
Generated: /ws/MyPackage/Frontend/Apps/External/Components/Route/HelloWorld.vue
Generated: /ws/MyPackage/Frontend/Tests/Apps/External/Components/Route/HelloWorld.js
Skipped creating documentation component.
            </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="the-route-configuration"></a>The Route Configuration</h3></div></div></div><p>
            In order to allow the route in the external interface application, we need to add a correct route
            configuration that points to our component. Therefore we create a file
            <code class="filename">Kernel/Config/Files/XML/HelloWorld.xml</code> with following definition:
        </p><p>
            </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;otrs_config version="2.0" init="Application"&gt;
    &lt;Setting Name="ExternalFrontend::Route###420-HelloWorld" Required="0" Valid="1"&gt;
        &lt;Description Translatable="1"&gt;Defines the application routes for the external interface. Additional routes are defined by adding new items and specifying their parameters. 'Group' and 'GroupRo' arrays can be used to limit access of the route to members of certain groups with RW and RO permissions respectively. 'Path' defines the relative path of the route, and 'Alias' can be used for specifying an alternative path. 'Component' is the path of the Vue component responsible for displaying the route content, relative to the Components/Route folder in the app. 'IsPublic' defines if the route will be accessible for unauthenticated users and in case this is set to '1', 'Group' and 'GroupRo' parameters will be ignored. 'Props' can be used to signal that the path contain dynamic segments, and that their values should be bound to the component as props (use '1' to turn on this feature).&lt;/Description&gt;
        &lt;Navigation&gt;Frontend::External::Route&lt;/Navigation&gt;
        &lt;Value&gt;
            &lt;Array&gt;
                &lt;DefaultItem ValueType="ApplicationRoute"&gt;
                    &lt;Hash&gt;
                    &lt;/Hash&gt;
                &lt;/DefaultItem&gt;
                &lt;Item&gt;
                    &lt;Hash&gt;
                        &lt;Item Key="Group"&gt;
                            &lt;Array&gt;
                            &lt;/Array&gt;
                        &lt;/Item&gt;
                        &lt;Item Key="GroupRo"&gt;
                            &lt;Array&gt;
                            &lt;/Array&gt;
                        &lt;/Item&gt;
                        &lt;Item Key="Path"&gt;/hello-world/:headingText?&lt;/Item&gt;
                        &lt;Item Key="Alias"&gt;&lt;/Item&gt;
                        &lt;Item Key="Component"&gt;HelloWorld&lt;/Item&gt;
                        &lt;Item Key="IsPublic"&gt;1&lt;/Item&gt;
                        &lt;Item Key="Props"&gt;1&lt;/Item&gt;
                    &lt;/Hash&gt;
                &lt;/Item&gt;
            &lt;/Array&gt;
        &lt;/Value&gt;
    &lt;/Setting&gt;
&lt;/otrs_config&gt;
            </pre><p>
        </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="round"><li class="listitem"><p>
                        <code class="literal">Group</code> and <code class="literal">GroupRo</code> can be used to limit the route screen to
                        users with certain groups. Please note that this only concerns the authenticated customer users.
                    </p></li><li class="listitem"><p>
                        <code class="literal">Path</code> is actually the slug under which the route component will be available.
                        The full URL in this case will be <code class="literal">/external/hello-world</code>, and any subsequent
                        path component will be passed as a parameter named <code class="literal">headingText</code>. If your
                        system has <code class="literal">Frontend::PrefixPath</code> configured, full URL will be prepended by it.
                    </p></li><li class="listitem"><p>
                        <code class="literal">Alias</code> can be used to provide an alias for the same route. I.e.
                        <code class="literal">/hello-world-alt</code>. It will point to the same component.
                    </p></li><li class="listitem"><p>
                        <code class="literal">Component</code> is the component identifier, first part of the filename, without
                        the <code class="filename">.vue</code> extension. In case of component folders, it's the name of the root
                        folder (see <a class="link" href="writing-new-otrs-frontend-component.html#component-folders" title="Component Folders">here</a> for more info).
                    </p></li><li class="listitem"><p>
                        <code class="literal">IsPublic</code> defines if the route will be accessible by unauthenticated users
                        (0/Empty - not accessible, 1 - accessible).
                    </p></li><li class="listitem"><p>
                        <code class="literal">Props</code> defines if the route will be passed URI parameters as prop values
                        (0/Empty - not passed, 1 - passed). See <a class="link" href="writing-new-otrs-frontend-component.html#passing-parameters" title="Passing Parameters to the Route Component">here</a>
                        for more info).
                    </p></li></ul></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="component-template-code"></a>Component Template Code</h3></div></div></div><p>
            Let's fire up the code editor now and take a closer look at the <code class="filename">HelloWorld.vue</code> file
            that our skeleton command created.
        </p><p>
            Top part of the file contains a template section which should contain Vue.js template code. For example,
            let's modify it so it displays a heading with a text variable:
        </p><p>
            </p><pre class="programlisting">
&lt;template&gt;
    &lt;main class="HelloWorld"&gt;
        &lt;b-container&gt;
            &lt;b-row&gt;
                &lt;b-col&gt;
                    &lt;h1 class="HelloWorld__Heading"&gt;
                        {{ headingText | translate }}
                    &lt;/h1&gt;
                &lt;/b-col&gt;
            &lt;/b-row&gt;
        &lt;/b-container&gt;
    &lt;/main&gt;
&lt;/template&gt;
            </pre><p>
        </p><p>
            OTRS supports number of filters, with <code class="literal">translate</code> being one of them. It even supports
            translation of string literals with placeholder values, you can use it like this:
        </p><p>
            </p><pre class="programlisting">
{{ 'This is a %s.' | translate('string') }}
            </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="component-core-code"></a>Component Core Code</h3></div></div></div><p>
            Next, we add a support for a prop to our component core code block, following is a modified and abridged
            version suitable for an example:
        </p><p>
            </p><pre class="programlisting">
&lt;script&gt;
export default {
    name: 'HelloWorld',

    props: {
        headingText: {
            type: String,
            default: translatable('Hello, world!'),
        },
    },
};
&lt;/script&gt;
            </pre><p>
        </p><p>
            This adds a prop with the name <code class="literal">headingText</code> to our component, which is of type string and
            has a sensible default value.
        </p><p>
            Usage of <code class="literal">translatable()</code> no-op method is limited to marking translatable strings which
            appear in the code. Please note that this is not required for string literals which are piped to the
            translate filter, as this will be assumed from the start. Rule of thumb is to use the marker anywhere where
            the string is not translated at the place where it is defined.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="component-style-code"></a>Component Style Code</h3></div></div></div><p>
            Last, but not the least, we have an option to specify styles used by the component. For this we have access
            to the SCSS, which is a flavor of SASS CSS extension set. To leverage it, just add a style tag at the end of
            the component file:
        </p><p>
            </p><pre class="programlisting">
&lt;style lang="scss"&gt;
.HelloWorld {
    &amp;__Heading {
        color: $primary;
    }
}
&lt;/style&gt;
            </pre><p>
        </p><p>
            Inside the style block, you will have access to certain set of global variables and mixins. Please refer
            to the framework code for details (take a look at the <code class="filename">Frontend/Styles/globals.js</code>).
        </p><p>
            Please note that while the styles will be loaded only when your component is referenced, these will be
            globally available afterwards since the CSS is inherently global for the same page. There is an option to
            scope the styles just to your component, you can do this via the <code class="literal">scoped</code> attribute on the
            style tag, but this might not be necessary with clever usage of BEM approach in designing your class names.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="passing-parameters"></a>Passing Parameters to the Route Component</h3></div></div></div><p>
            In the route configuration above, we defined the route path that contains a parameter placeholder
            (<code class="literal">headingText</code>). By activating the <code class="literal">Props</code> flag, we made sure that the
            value of this parameter will be bound to our component prop with the same name every time a route is
            entered.
        </p><p>
            For example, if we enter the route via the <code class="literal">/external/hello-world</code> URL, our component prop
            will be undefined and therefore will get its default value:
        </p><p>
            </p><div class="figure"><a name="id-1.4.3.9.4.1"></a><p class="title"><b>Figure 3.1. Passing Parameters - Default Prop Value</b></p><div class="figure-contents"><div class="screenshot"><div><img src="screenshots/passing-parameters-default-prop-value.png" alt="Passing Parameters - Default Prop Value"></div></div></div></div><p><br class="figure-break">
        </p><p>
            But, if we access the route via the <code class="literal">/external/hello-world/Value</code>, the prop will be set
            to string <code class="literal">Value</code>, and even automatically translated in the current user language (where
            applicable):
        </p><p>
            </p><div class="figure"><a name="id-1.4.3.9.6.1"></a><p class="title"><b>Figure 3.2. Passing Parameters - Translated Prop Value</b></p><div class="figure-contents"><div class="screenshot"><div><img src="screenshots/passing-parameters-translated-prop-value.png" alt="Passing Parameters - Translated Prop Value"></div></div></div></div><p><br class="figure-break">
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="component-folders"></a>Component Folders</h3></div></div></div><p>
            In case of self-enclosed components, you might want to ship some additional files with it. Sometimes it's
            better to modularize the code base since it's easier to maintain. In case of frontend components you have a
            really simple way of doing this: component folders. Instead of a single <code class="filename">.vue</code> file for
            a component, enclose the file named <code class="filename">index.vue</code> in a folder named as your component.
            Something like this:
        </p><p>
             </p><pre class="screen">
HelloWorld/
HelloWorld/index.vue
              </pre><p>
        </p><p>
            Then, simply add new files in the same folder, following a sane structure:
        </p><p>
             </p><pre class="screen">
HelloWorld/
HelloWorld/index.vue
HelloWorld/Styles/_mystyles.scss
HelloWorld/Images/foobar.png
HelloWorld/Fonts/awesome-font.woff
HelloWorld/Fonts/awesome-font.woff2
HelloWorld/ChildComponent1.vue
HelloWorld/ChildComponent2/index.vue
HelloWorld/ChildComponent2/Styles/_childstyles2.scss
               </pre><p>
        </p><p>
            You get the idea. It will then be possible to reference the new files via relative paths, in order to
            achieve something like this in the parent component (<code class="filename">index.vue</code>):
        </p><p>
            </p><pre class="programlisting">
&lt;template&gt;
    &lt;img src="./Images/foobar.png" alt="Foobar" /&gt;
&lt;/template&gt;
            </pre><p>
        </p><p>
            Or, something like this:
        </p><p>
            </p><pre class="programlisting">
&lt;script&gt;
export default {
    name: 'HelloWorld',

    components: {
        ChildComponent1: () =&gt; import('./ChildComponent1'),
        ChildComponent2: () =&gt; import('./ChildComponent2'),
    },
...
            </pre><p>
        </p><p>
            Even external styles can be referenced in the correct block:
        </p><p>
            </p><pre class="programlisting">
&lt;style lang="scss"&gt;
@import './Styles/mystyles';
&lt;/style&gt;
            </pre><p>
        </p><p>
            With this approach you will be left with a packaged component in a single folder that follows the logical
            tree hierarchy, and makes all resources easily findable when needed.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="packaging-additional-vendor-modules"></a>Packaging Additional Vendor Modules</h3></div></div></div><p>
            In certain cases, you might need to ship additional Node.js modules with your package. Unfortunately, both
            NPM and OTRS do not support easy addition of modules to the root <code class="filename">node_modules/</code> folder,
            but there is a mechanism to provide pre-packaged module files.
        </p><p>
            Simply create a <code class="filename">Frontend/Vendor</code> folder in your package, and add your module resources
            in sub-folders within it.
        </p><p>
            For example, let us assume we want to ship a useful <code class="literal">vue-full-calendar</code> component and its
            dependencies as part of our package. This component has following NPM dependencies:
        </p><p>
            </p><pre class="screen">
$ npm view vue-full-calendar dependencies
{ 'babel-plugin-transform-runtime': '^6.23.0', fullcalendar: '^3.4.0', 'lodash.defaultsdeep': '^4.6.0' }
            </pre><p>
        </p><p>
            However, some of its dependencies have even more dependencies and we can inspect them too:
        </p><p>
            </p><pre class="screen">
$ npm view babel-plugin-transform-runtime dependencies
{ 'babel-runtime': '^6.22.0' }

$ npm view fullcalendar dependencies
{ jquery: '2 - 3', moment: '^2.20.1' }

$ npm view lodash.defaultsdeep dependencies

            </pre><p>
        </p><p>
            Quick check will inform us that both babel-runtime and moment are actually part of the OTRS framework
            dependencies:
        </p><p>
            </p><pre class="screen">
/opt/otrs $ npm list babel-runtime
otrs-frontend@7.0.0-dev /ws/otrs7-mojo
├─┬ bootstrap-vue@2.0.0-rc.11
│ └─┬ opencollective@1.0.3
│   └─┬ babel-polyfill@6.23.0
│     └── babel-runtime@6.26.0  deduped
├─┬ esdoc2@2.1.5
│ ├─┬ babel-generator@6.26.0
│ │ ├─┬ babel-messages@6.23.0
│ │ │ └── babel-runtime@6.26.0  deduped
...

/opt/otrs $ npm list moment
otrs-frontend@7.0.0-dev /ws/otrs7-mojo
└─┬ moment-timezone@0.5.21
  └── moment@2.22.2
            </pre><p>
        </p><p>
            This means that we don't have to ship those modules too, since they will be available out-of-box. While it's
            cumbersome to check all dependencies, it will be worthwhile because our package will be smaller. We will
            also prevent issues with overriding framework dependencies, since Frontend/Vendor wins always.
        </p><p>
            Let's now install what we need and discard what we don't need. The easiest way to do it is via the following
            NPM command:
        </p><p>
            </p><pre class="screen">
/ws/MyPackage $ npm install vue-full-calendar --no-save
+ vue-full-calendar@2.7.0
added 9 packages from 14 contributors in 1.883s

/ws/MyPackage $ ls node_modules/
babel-plugin-transform-runtime fullcalendar                        moment
babel-runtime                  jquery                              regenerator-runtime
core-js                        lodash.defaultsdeep                 vue-full-calendar
            </pre><p>
        </p><p>
            Now we remove those modules which we know are provided by the framework:
        </p><p>
            </p><pre class="screen">
/ws/MyPackage $ rm -rf node_modules/babel-runtime node_modules/core-js node_modules/moment node_modules/regenerator-runtime

/ws/MyPackage $ ls node_modules/
babel-plugin-transform-runtime lodash.defaultsdeep
fullcalendar                   vue-full-calendar
jquery
            </pre><p>
        </p><p>
            Much better. Now we move the modules to their correct place:
        </p><p>
            </p><pre class="screen">
/ws/MyPackage $ mkdir -p Frontend/Vendor
/ws/MyPackage $ mv node_modules/* Frontend/Vendor/
/ws/MyPackage $ rmdir node_modules/
            </pre><p>
        </p><p>
            Final optimization would be to remove unneeded files from the specific module folders. This might prove to
            be complicated, but it's worth it since it will further reduce size of the modules and number of files that
            need to be included in the package.
        </p><p>
            For example, let's remove minimized JS files from the <code class="literal">fullcalendar</code> module because we
            identified that the Vue component uses full dist files only:
        </p><p>
            </p><pre class="screen">
/ws/MyPackage $ rm Frontend/Vendor/fullcalendar/dist/*.min.*
            </pre><p>
        </p><p>
            It's also safe to remove jQuery source and minimized files as well, since the
            <code class="literal">fullcalendar</code> uses original dist files too:
        </p><p>
            </p><pre class="screen">
/ws/MyPackage $ rm Frontend/Vendor/jquery/dist/*.min.*
/ws/MyPackage $ rm Frontend/Vendor/jquery/external/sizzle/dist/*.min.*
/ws/MyPackage $ rm -rf Frontend/Vendor/jquery/src
            </pre><p>
        </p><p>
            We are left with approx. 100+ files which we need to include in our SOPM files, like any other regular
            package file. Once we do this, these dependencies will be present and resolvable in the target system:
        </p><p>
            </p><pre class="screen">
/ws/MyPackage $ ls -la Frontend/Vendor
Frontend/Vendor
Frontend/Vendor/vue-full-calendar
Frontend/Vendor/vue-full-calendar/.babelrc
Frontend/Vendor/vue-full-calendar/LICENSE
Frontend/Vendor/vue-full-calendar/tests
Frontend/Vendor/vue-full-calendar/tests/fullcalendar.spec.js
Frontend/Vendor/vue-full-calendar/index.js
...
            </pre><p>
        </p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="how-to-extend-otrs.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="how-to-extend-otrs.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="otrs-module-layers.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. How to Extend OTRS </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Using the power of the OTRS module layers</td></tr></table></div></body></html>
