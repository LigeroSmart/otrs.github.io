<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<!-- otrs.github.io -->
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../../../../../../../documentation.css">
<script src="https://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../../../../../../documentation.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
<script>
$(document).ready(function() {
    // programlistings in manuals
    $('pre.programlisting').each(function(i, block) {
        hljs.highlightBlock(block);
    });
    // code snippets in Perl API docs
    $('.pod pre').addClass('perl').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});</script>
<!-- otrs.github.io -->

	<title>Kernel::System::Ticket::Article</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <script type="text/javascript">

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  </script></head>
<body>
<div class="box">
  <h1 class="t1">OTRS 6.0 API Reference Perl</h1>
  <table>
    <tr>
      <td class="label">Description</td>
      <td class="cell">manuals and libraries</td>
    </tr>
  </table>
</div>
<div class="path">
  <a href="../../../index.html">OTRS 6.0 API Reference Perl</a> &gt; Perl Modules &gt;
  Kernel::System::Ticket::Article
</div>
<div>
<a href="../../../src/Kernel/System/Ticket/Article.pm">Source</a>
</div>
<div class="pod">
<!-- INDEX START -->
<h3 id="TOP">Index</h3>
<ul>
	<li><a href="#NAME">NAME</a></li>
	<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
	<li><a href="#PUBLIC_INTERFACE">PUBLIC INTERFACE</a><br />
<ul>
	<li><a href="#ArticleCreate">ArticleCreate()</a></li>
	<li><a href="#ArticleGetTicketIDOfMessageID">ArticleGetTicketIDOfMessageID()</a></li>
	<li><a href="#ArticleGetContentPath">ArticleGetContentPath()</a></li>
	<li><a href="#ArticleSenderTypeList">ArticleSenderTypeList()</a></li>
	<li><a href="#ArticleSenderTypeLookup">ArticleSenderTypeLookup()</a></li>
	<li><a href="#ArticleTypeLookup">ArticleTypeLookup()</a></li>
	<li><a href="#ArticleTypeList">ArticleTypeList()</a></li>
	<li><a href="#ArticleLastCustomerArticle">ArticleLastCustomerArticle()</a></li>
	<li><a href="#ArticleFirstArticle">ArticleFirstArticle()</a></li>
	<li><a href="#ArticleIndex">ArticleIndex()</a></li>
	<li><a href="#ArticleContentIndex">ArticleContentIndex()</a></li>
	<li><a href="#ArticleGet">ArticleGet()</a></li>
	<li><a href="#ArticleCount">ArticleCount()</a></li>
	<li><a href="#ArticlePage">ArticlePage()</a></li>
	<li><a href="#ArticleUpdate">ArticleUpdate()</a></li>
	<li><a href="#ArticleSend">ArticleSend()</a></li>
	<li><a href="#ArticleBounce">ArticleBounce()</a></li>
	<li><a href="#SendAutoResponse">SendAutoResponse()</a></li>
	<li><a href="#ArticleFlagSet">ArticleFlagSet()</a></li>
	<li><a href="#ArticleFlagDelete">ArticleFlagDelete()</a></li>
	<li><a href="#ArticleFlagGet">ArticleFlagGet()</a></li>
	<li><a href="#ArticleFlagsOfTicketGet">ArticleFlagsOfTicketGet()</a></li>
	<li><a href="#ArticleAccountedTimeGet">ArticleAccountedTimeGet()</a></li>
	<li><a href="#ArticleAccountedTimeDelete">ArticleAccountedTimeDelete()</a></li>
	<li><a href="#ArticleDelete">ArticleDelete()</a></li>
	<li><a href="#ArticleDeletePlain">ArticleDeletePlain()</a></li>
	<li><a href="#ArticleDeleteAttachment">ArticleDeleteAttachment()</a></li>
	<li><a href="#ArticleWritePlain">ArticleWritePlain()</a></li>
	<li><a href="#ArticlePlain">ArticlePlain()</a></li>
	<li><a href="#ArticleWriteAttachment">ArticleWriteAttachment()</a></li>
	<li><a href="#ArticleAttachment">ArticleAttachment()</a></li>
	<li><a href="#ArticleAttachmentIndex">ArticleAttachmentIndex()</a></li>
</ul>
</li>
	<li><a href="#TERMS_AND_CONDITIONS">TERMS AND CONDITIONS</a></li>
</ul>
<hr />
<!-- INDEX END -->

<h1 id="NAME">NAME <a href="#TOP" class="toplink"><img alt="^" src="../../../up.gif" /></a></h1>

<p>Kernel::System::Ticket::Article - sub module of Kernel::System::Ticket</p>

<h1 id="DESCRIPTION">DESCRIPTION <a href="#TOP" class="toplink"><img alt="^" src="../../../up.gif" /></a></h1>

<p>All article functions.</p>

<h1 id="PUBLIC_INTERFACE">PUBLIC INTERFACE <a href="#TOP" class="toplink"><img alt="^" src="../../../up.gif" /></a></h1>

<h2 id="ArticleCreate">ArticleCreate()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleCreate');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleCreate">
                                        <pre>

sub ArticleCreate {
    my ( $Self, %Param ) = @_;

    # get time object
    my $TimeObject = $Kernel::OM->Get('Kernel::System::Time');

    my $ValidID = $Param{ValidID} || 1;
    my $IncomingTime = $TimeObject->SystemTime();

    # create ArticleContentPath
    if ( !$Self->{ArticleContentPath} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need ArticleContentPath!'
        );
        return;
    }

    # lookups if no ids are passed
    if ( $Param{ArticleType} && !$Param{ArticleTypeID} ) {
        $Param{ArticleTypeID} = $Self->ArticleTypeLookup( ArticleType => $Param{ArticleType} );
    }
    if ( $Param{SenderType} && !$Param{SenderTypeID} ) {
        $Param{SenderTypeID} = $Self->ArticleSenderTypeLookup( SenderType => $Param{SenderType} );
    }

    # check needed stuff
    for (qw(TicketID UserID ArticleTypeID SenderTypeID HistoryType HistoryComment)) {
        if ( !$Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    # check ContentType vs. Charset & MimeType
    if ( !$Param{ContentType} ) {
        for (qw(Charset MimeType)) {
            if ( !$Param{$_} ) {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message  => "Need $_!"
                );
                return;
            }
        }
        $Param{ContentType} = "$Param{MimeType}; charset=$Param{Charset}";
    }
    else {
        for (qw(ContentType)) {
            if ( !$Param{$_} ) {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message  => "Need $_!"
                );
                return;
            }
        }
        $Param{Charset} = '';
        if ( $Param{ContentType} =~ /charset=/i ) {
            $Param{Charset} = $Param{ContentType};
            $Param{Charset} =~ s/.+?charset=("|'|)(\w+)/$2/gi;
            $Param{Charset} =~ s/"|'//g;
            $Param{Charset} =~ s/(.+?);.*/$1/g;

        }
        $Param{MimeType} = '';
        if ( $Param{ContentType} =~ /^(\w+\/\w+)/i ) {
            $Param{MimeType} = $1;
            $Param{MimeType} =~ s/"|'//g;
        }
    }

    # for the event handler, before any actions have taken place
    my %OldTicketData = $Self->TicketGet(
        TicketID      => $Param{TicketID},
        DynamicFields => 1,
    );

    # get html utils object
    my $HTMLUtilsObject = $Kernel::OM->Get('Kernel::System::HTMLUtils');

    # add 'no body' if there is no body there!
    my @AttachmentConvert;
    if ( !length $Param{Body} ) {    # allow '0' as body
        $Param{Body} = 'No body';
    }

    # process html article
    elsif ( $Param{MimeType} =~ /text\/html/i ) {

        # add html article as attachment
        my $Attach = {
            Content     => $Param{Body},
            ContentType => "text/html; charset=\"$Param{Charset}\"",
            Filename    => 'file-2',
        };
        push @AttachmentConvert, $Attach;

        # get ascii body
        $Param{MimeType} = 'text/plain';
        $Param{ContentType} =~ s/html/plain/i;
        $Param{Body} = $HTMLUtilsObject->ToAscii(
            String => $Param{Body},
        );
    }
    elsif ( $Param{MimeType} && $Param{MimeType} eq "application/json" ) {

        # Keep JSON body unchanged
    }

    # if body isn't text, attach body as attachment (mostly done by OE) :-/
    elsif ( $Param{MimeType} && $Param{MimeType} !~ /\btext\b/i ) {

        # add non text as attachment
        my $FileName = 'unknown';
        if ( $Param{ContentType} =~ /name="(.+?)"/i ) {
            $FileName = $1;
        }
        my $Attach = {
            Content     => $Param{Body},
            ContentType => $Param{ContentType},
            Filename    => $FileName,
        };
        push @{ $Param{Attachment} }, $Attach;

        # set ascii body
        $Param{MimeType}    = 'text/plain';
        $Param{ContentType} = 'text/plain';
        $Param{Body}        = '- no text message => see attachment -';
    }

    # fix some bad stuff from some browsers (Opera)!
    else {
        $Param{Body} =~ s/(\n\r|\r\r\n|\r\n)/\n/g;
    }

    # strip not wanted stuff
    for my $Attribute (qw(From To Cc Subject MessageID InReplyTo References ReplyTo)) {
        if ( defined $Param{$Attribute} ) {
            $Param{$Attribute} =~ s/\n|\r//g;
        }
        else {
            $Param{$Attribute} = '';
        }
    }
    ATTRIBUTE:
    for my $Attribute (qw(MessageID)) {
        next ATTRIBUTE if !$Param{$Attribute};
        $Param{$Attribute} = substr( $Param{$Attribute}, 0, 3800 );
    }

    # check if this is the first article (for notifications)
    my @Index = $Self->ArticleIndex( TicketID => $Param{TicketID} );
    my $FirstArticle = scalar @Index ? 0 : 1;

    # calculate MD5 of Message ID
    if ( $Param{MessageID} ) {
        $Param{MD5} = $Kernel::OM->Get('Kernel::System::Main')->MD5sum( String => $Param{MessageID} );
    }

    # Generate unique fingerprint for searching created article in database to prevent race conditions
    #   (see https://bugs.otrs.org/show_bug.cgi?id=12438).
    my $RandomString = $Kernel::OM->Get('Kernel::System::Main')->GenerateRandomString(
        Length => 32,
    );
    my $ArticleInsertFingerprint = $$ . '-' . $RandomString . '-' . ($Param{MessageID} // '');

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # if the original article body contains just one pasted picture and no text, at this point of
    # the code the body is an empty string, Oracle databases will transform the empty string value
    # to NULL and will try to insert a NULL value in a field that should not be NULL. see bug 7533.
    if (
        $DBObject->GetDatabaseFunction('Type') eq 'oracle'
        && defined $Param{Body}
        && !$Param{Body}
        )
    {
        $Param{Body} = ' ';
    }

    # do db insert
    return if !$DBObject->Do(
        SQL => 'INSERT INTO article '
            . '(ticket_id, article_type_id, article_sender_type_id, a_from, a_reply_to, a_to, '
            . 'a_cc, a_subject, a_message_id, a_message_id_md5, a_in_reply_to, a_references, a_body, a_content_type, '
            . 'content_path, valid_id, incoming_time, create_time, create_by, change_time, change_by) '
            . 'VALUES '
            . '(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, current_timestamp, ?, current_timestamp, ?)',
        Bind => [
            \$Param{TicketID}, \$Param{ArticleTypeID}, \$Param{SenderTypeID},
            \$Param{From},     \$Param{ReplyTo},       \$Param{To},
            \$Param{Cc},       \$Param{Subject},
            \$ArticleInsertFingerprint,    # just for next search; will be updated with correct MessageID
            \$Param{MD5},
            \$Param{InReplyTo}, \$Param{References}, \$Param{Body},
            \$Param{ContentType}, \$Self->{ArticleContentPath}, \$ValidID,
            \$IncomingTime, \$Param{UserID}, \$Param{UserID},
        ],
    );

    # get article id
    my $ArticleID = $Self->_ArticleGetId(
        TicketID     => $Param{TicketID},
        MessageID    => $ArticleInsertFingerprint,
        From         => $Param{From},
        Subject      => $Param{Subject},
        IncomingTime => $IncomingTime
    );

    # return if there is not article created
    if ( !$ArticleID ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Can't get ArticleID from insert (TicketID=$Param{TicketID}, MessageID=$Param{MessageID})!",
        );
        return;
    }

    # Save correct Message-ID now.
    return if !$DBObject->Do(
        SQL  => 'UPDATE article SET a_message_id = ? WHERE id = ?',
        Bind => [ \$Param{MessageID}, \$ArticleID ],
    );

    # check for base64 encoded images in html body and upload them
    for my $Attachment (@AttachmentConvert) {

        if (
            $Attachment->{ContentType} eq "text/html; charset=\"$Param{Charset}\""
            && $Attachment->{Filename} eq 'file-2'
            )
        {
            $HTMLUtilsObject->EmbeddedImagesExtract(
                DocumentRef    => \$Attachment->{Content},
                AttachmentsRef => \@AttachmentConvert,
            );
        }
    }

    # add converted attachments
    for my $Attachment (@AttachmentConvert) {
        $Self->ArticleWriteAttachment(
            %{$Attachment},
            ArticleID => $ArticleID,
            UserID    => $Param{UserID},
        );
    }

    # add attachments
    if ( $Param{Attachment} ) {
        for my $Attachment ( @{ $Param{Attachment} } ) {
            $Self->ArticleWriteAttachment(
                %{$Attachment},
                ArticleID => $ArticleID,
                UserID    => $Param{UserID},
            );
        }
    }

    $Self->_TicketCacheClear( TicketID => $Param{TicketID} );

    # add history row
    $Self->HistoryAdd(
        ArticleID    => $ArticleID,
        TicketID     => $Param{TicketID},
        CreateUserID => $Param{UserID},
        HistoryType  => $Param{HistoryType},
        Name         => $Param{HistoryComment},
    );

    # get needed objects
    my $ConfigObject = $Kernel::OM->Get('Kernel::Config');
    my $UserObject   = $Kernel::OM->Get('Kernel::System::User');

    # unlock ticket if the owner is away (and the feature is enabled)
    if (
        $Param{UnlockOnAway}
        && $OldTicketData{Lock} eq 'lock'
        && $ConfigObject->Get('Ticket::UnlockOnAway')
        )
    {
        my %OwnerInfo = $UserObject->GetUserData(
            UserID => $OldTicketData{OwnerID},
        );

        if ( $OwnerInfo{OutOfOfficeMessage} ) {
            $Self->TicketLockSet(
                TicketID => $Param{TicketID},
                Lock     => 'unlock',
                UserID   => $Param{UserID},
            );
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'notice',
                Message =>
                    "Ticket [$OldTicketData{TicketNumber}] unlocked, current owner is out of office!",
            );
        }
    }

    # event
    $Self->EventHandler(
        Event => 'ArticleCreate',
        Data  => {
            ArticleID     => $ArticleID,
            TicketID      => $Param{TicketID},
            OldTicketData => \%OldTicketData,
        },
        UserID => $Param{UserID},
    );

    # reset unlock if needed
    if ( !$Param{SenderType} ) {
        $Param{SenderType} = $Self->ArticleSenderTypeLookup( SenderTypeID => $Param{SenderTypeID} );
    }
    if ( !$Param{ArticleType} ) {
        $Param{ArticleType} = $Self->ArticleTypeLookup( ArticleTypeID => $Param{ArticleTypeID} );
    }

    # reset unlock time if customer sent an update
    if ( $Param{SenderType} eq 'customer' ) {

        # check if latest article comes from customer
        my $LastSender = '';
        return if !$DBObject->Prepare(
            SQL => 'SELECT ast.name FROM article art, article_sender_type ast WHERE '
                . ' art.ticket_id = ? AND art.id NOT IN (?) AND '
                . ' art.article_sender_type_id = ast.id ORDER BY art.create_time ASC',
            Bind => [ \$Param{TicketID}, \$ArticleID ],
        );
        while ( my @Row = $DBObject->FetchrowArray() ) {
            if ( $Row[0] ne 'system' ) {
                $LastSender = $Row[0];
            }
        }
        if ( $LastSender eq 'agent' ) {
            $Self->TicketUnlockTimeoutUpdate(
                UnlockTimeout => $TimeObject->SystemTime(),
                TicketID      => $Param{TicketID},
                UserID        => $Param{UserID},
            );
        }
    }

    # check if latest article is sent to customer
    elsif (
        $Param{SenderType} eq 'agent'
        && $Param{ArticleType} =~ /email-ext|phone|fax|sms|note-ext/
        )
    {
        $Self->TicketUnlockTimeoutUpdate(
            UnlockTimeout => $TimeObject->SystemTime(),
            TicketID      => $Param{TicketID},
            UserID        => $Param{UserID},
        );
    }

    # send auto response
    if ( $Param{AutoResponseType} ) {
        $Self->SendAutoResponse(
            OrigHeader       => $Param{OrigHeader},
            TicketID         => $Param{TicketID},
            UserID           => $Param{UserID},
            AutoResponseType => $Param{AutoResponseType},
        );
    }

    # send no agent notification!?
    return $ArticleID if $Param{NoAgentNotify};

    my %Ticket = $Self->TicketGet(
        TicketID      => $Param{TicketID},
        DynamicFields => 0,
    );

    # remember agent to exclude notifications
    my @SkipRecipients;
    if ( $Param{ExcludeNotificationToUserID} && ref $Param{ExcludeNotificationToUserID} eq 'ARRAY' )
    {
        for my $UserID ( @{ $Param{ExcludeNotificationToUserID} } ) {
            push @SkipRecipients, $UserID;
        }
    }

    # remember agent to exclude notifications / already sent
    my %DoNotSendMute;
    if (
        $Param{ExcludeMuteNotificationToUserID}
        && ref $Param{ExcludeMuteNotificationToUserID} eq 'ARRAY'
        )
    {
        for my $UserID ( @{ $Param{ExcludeMuteNotificationToUserID} } ) {
            push @SkipRecipients, $UserID;
        }
    }

    my $ExtraRecipients;
    if ( $Param{ForceNotificationToUserID} && ref $Param{ForceNotificationToUserID} eq 'ARRAY' ) {
        $ExtraRecipients = $Param{ForceNotificationToUserID};
    }

    # send agent notification on ticket create
    if (
        $FirstArticle &&
        $Param{HistoryType}
        =~ /^(EmailAgent|EmailCustomer|PhoneCallCustomer|WebRequestCustomer|SystemRequest)$/i
        )
    {
        # trigger notification event
        $Self->EventHandler(
            Event => 'NotificationNewTicket',
            Data  => {
                TicketID              => $Param{TicketID},
                ArticleID             => $ArticleID,
                ArticleType           => $Param{ArticleType},
                Queue                 => $Param{Queue},
                Recipients            => $ExtraRecipients,
                SkipRecipients        => \@SkipRecipients,
                CustomerMessageParams => {%Param},
            },
            UserID => $Param{UserID},
        );
    }

    # send agent notification on adding a note
    elsif ( $Param{HistoryType} =~ /^AddNote$/i ) {

        # trigger notification event
        $Self->EventHandler(
            Event => 'NotificationAddNote',
            Data  => {
                TicketID              => $Param{TicketID},
                ArticleID             => $ArticleID,
                ArticleType           => $Param{ArticleType},
                Queue                 => $Param{Queue},
                Recipients            => $ExtraRecipients,
                SkipRecipients        => \@SkipRecipients,
                CustomerMessageParams => {},
            },
            UserID => $Param{UserID},
        );
    }

    # send agent notification on follow up
    elsif ( $Param{HistoryType} =~ /^FollowUp$/i ) {

        # trigger notification event
        $Self->EventHandler(
            Event => 'NotificationFollowUp',
            Data  => {
                TicketID              => $Param{TicketID},
                ArticleID             => $ArticleID,
                ArticleType           => $Param{ArticleType},
                Queue                 => $Param{Queue},
                Recipients            => $ExtraRecipients,
                SkipRecipients        => \@SkipRecipients,
                CustomerMessageParams => {%Param},
            },
            UserID => $Param{UserID},
        );
    }

    # return ArticleID
    return $ArticleID;
}
</pre></div>

<p>create an article</p>

<pre>    my $ArticleID = $TicketObject-&gt;ArticleCreate(
        TicketID         =&gt; 123,
        ArticleType      =&gt; 'note-internal',                        # email-external|email-internal|phone|fax|...
        SenderType       =&gt; 'agent',                                # agent|system|customer
        From             =&gt; 'Some Agent &lt;email@example.com&gt;',       # not required but useful
        To               =&gt; 'Some Customer A &lt;customer-a@example.com&gt;', # not required but useful
        Cc               =&gt; 'Some Customer B &lt;customer-b@example.com&gt;', # not required but useful
        ReplyTo          =&gt; 'Some Customer B &lt;customer-b@example.com&gt;', # not required
        Subject          =&gt; 'some short description',               # required
        Body             =&gt; 'the message text',                     # required
        MessageID        =&gt; '&lt;asdasdasd.123@example.com&gt;',          # not required but useful
        InReplyTo        =&gt; '&lt;asdasdasd.12@example.com&gt;',           # not required but useful
        References       =&gt; '&lt;asdasdasd.1@example.com&gt; &lt;asdasdasd.12@example.com&gt;', # not required but useful
        ContentType      =&gt; 'text/plain; charset=ISO-8859-15',      # or optional Charset &amp; MimeType
        HistoryType      =&gt; 'OwnerUpdate',                          # EmailCustomer|Move|AddNote|PriorityUpdate|WebRequestCustomer|...
        HistoryComment   =&gt; 'Some free text!',
        UserID           =&gt; 123,
        Attachment =&gt; [
            {
                Content     =&gt; $Content,
                ContentType =&gt; $ContentType,
                Filename    =&gt; 'lala.txt',
            },
            {
                Content     =&gt; $Content,
                ContentType =&gt; $ContentType,
                Filename    =&gt; 'lala1.txt',
            },
        ],
        NoAgentNotify    =&gt; 0,                                      # if you don't want to send agent notifications
        AutoResponseType =&gt; 'auto reply'                            # auto reject|auto follow up|auto reply/new ticket|auto remove

        ForceNotificationToUserID   =&gt; [ 1, 43, 56 ],               # if you want to force somebody
        ExcludeNotificationToUserID =&gt; [ 43,56 ],                   # if you want full exclude somebody from notfications,
                                                                    # will also be removed in To: line of article,
                                                                    # higher prio as ForceNotificationToUserID
        ExcludeMuteNotificationToUserID =&gt; [ 43,56 ],               # the same as ExcludeNotificationToUserID but only the
                                                                    # sending gets muted, agent will still shown in To:
                                                                    # line of article
    );
</pre><p>example with &quot;Charset &amp; MimeType&quot; and no &quot;ContentType&quot;</p>

<pre>    my $ArticleID = $TicketObject-&gt;ArticleCreate(
        TicketID         =&gt; 123,
        ArticleType      =&gt; 'note-internal',                        # email-external|email-internal|phone|fax|...
        SenderType       =&gt; 'agent',                                # agent|system|customer
        From             =&gt; 'Some Agent &lt;email@example.com&gt;',       # not required but useful
        To               =&gt; 'Some Customer A &lt;customer-a@example.com&gt;', # not required but useful
        Subject          =&gt; 'some short description',               # required
        Body             =&gt; 'the message text',                     # required
        Charset          =&gt; 'ISO-8859-15',
        MimeType         =&gt; 'text/plain',
        HistoryType      =&gt; 'OwnerUpdate',                          # EmailCustomer|Move|AddNote|PriorityUpdate|WebRequestCustomer|...
        HistoryComment   =&gt; 'Some free text!',
        UserID           =&gt; 123,
        UnlockOnAway     =&gt; 1,                                      # Unlock ticket if owner is away
    );
</pre><p>Events:
    ArticleCreate</p>

<h2 id="ArticleGetTicketIDOfMessageID">ArticleGetTicketIDOfMessageID()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleGetTicketIDOfMessageID');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleGetTicketIDOfMessageID">
                                        <pre>

sub ArticleGetTicketIDOfMessageID {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{MessageID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need MessageID!'
        );
        return;
    }
    my $MD5 = $Kernel::OM->Get('Kernel::System::Main')->MD5sum( String => $Param{MessageID} );

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # sql query
    return if !$DBObject->Prepare(
        SQL   => 'SELECT ticket_id FROM article WHERE a_message_id_md5 = ?',
        Bind  => [ \$MD5 ],
        Limit => 10,
    );

    my $TicketID;
    my $Count = 0;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        $Count++;
        $TicketID = $Row[0];
    }

    # no reference found
    return if $Count == 0;

    # one found
    return $TicketID if $Count == 1;

    # more than one found! that should not be, a message_id should be unique!
    $Kernel::OM->Get('Kernel::System::Log')->Log(
        Priority => 'notice',
        Message  => "The MessageID '$Param{MessageID}' is in your database "
            . "more than one time! That should not be, a message_id should be unique!",
    );
    return;
}
</pre></div>

<p>get ticket id of given message id</p>

<pre>    my $TicketID = $TicketObject-&gt;ArticleGetTicketIDOfMessageID(
        MessageID =&gt; '&lt;13231231.1231231.32131231@example.com&gt;',
    );
</pre><h2 id="ArticleGetContentPath">ArticleGetContentPath()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleGetContentPath');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleGetContentPath">
                                        <pre>

sub ArticleGetContentPath {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{ArticleID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need ArticleID!'
        );
        return;
    }

    # check key
    my $CacheKey = 'ArticleGetContentPath::' . $Param{ArticleID};

    # check cache
    my $Cache = $Kernel::OM->Get('Kernel::System::Cache')->Get(
        Type => $Self->{CacheType},
        Key  => $CacheKey,
    );
    return $Cache if $Cache;

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # sql query
    return if !$DBObject->Prepare(
        SQL  => 'SELECT content_path FROM article WHERE id = ?',
        Bind => [ \$Param{ArticleID} ],
    );

    my $Result;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        $Result = $Row[0];
    }

    # set cache
    $Kernel::OM->Get('Kernel::System::Cache')->Set(
        Type  => $Self->{CacheType},
        TTL   => $Self->{CacheTTL},
        Key   => $CacheKey,
        Value => $Result,
    );

    # return
    return $Result;
}
</pre></div>

<p>get article content path</p>

<pre>    my $Path = $TicketObject-&gt;ArticleGetContentPath(
        ArticleID =&gt; 123,
    );
</pre><h2 id="ArticleSenderTypeList">ArticleSenderTypeList()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleSenderTypeList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleSenderTypeList">
                                        <pre>

sub ArticleSenderTypeList {
    my ( $Self, %Param ) = @_;

    # get needed objects
    my $DBObject    = $Kernel::OM->Get('Kernel::System::DB');
    my $ValidObject = $Kernel::OM->Get('Kernel::System::Valid');

    return if !$DBObject->Prepare(
        SQL => "SELECT id, name FROM article_sender_type WHERE "
            . "valid_id IN (${\(join ', ', $ValidObject->ValidIDsGet())})",
    );

    my @Array;
    my %Hash;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        push @Array, $Row[1];
        $Hash{ $Row[0] } = $Row[1];
    }

    if ( $Param{Result} && $Param{Result} eq 'HASH' ) {
        return %Hash;
    }

    return @Array;

}
</pre></div>

<p>get a article sender type list</p>

<pre>    my @ArticleSenderTypeList = $TicketObject-&gt;ArticleSenderTypeList(
        Result =&gt; 'ARRAY', # optional, ARRAY|HASH
    );
</pre><h2 id="ArticleSenderTypeLookup">ArticleSenderTypeLookup()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleSenderTypeLookup');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleSenderTypeLookup">
                                        <pre>

sub ArticleSenderTypeLookup {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{SenderType} && !$Param{SenderTypeID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need SenderType or SenderTypeID!',
        );
        return;
    }

    # get key
    my $Key;
    my $CacheKey;
    if ( $Param{SenderType} ) {
        $Key      = $Param{SenderType};
        $CacheKey = 'ArticleSenderTypeLookup::' . $Param{SenderType};
    }
    else {
        $Key      = $Param{SenderTypeID};
        $CacheKey = 'ArticleSenderTypeLookup::' . $Param{SenderTypeID};
    }

    # check cache
    my $Cache = $Kernel::OM->Get('Kernel::System::Cache')->Get(
        Type => $Self->{CacheType},
        Key  => $CacheKey,
    );
    return $Cache if $Cache;

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # get data
    if ( $Param{SenderType} ) {
        return if !$DBObject->Prepare(
            SQL  => 'SELECT id FROM article_sender_type WHERE name = ?',
            Bind => [ \$Param{SenderType} ],
        );
    }
    else {
        return if !$DBObject->Prepare(
            SQL  => 'SELECT name FROM article_sender_type WHERE id = ?',
            Bind => [ \$Param{SenderTypeID} ],
        );
    }

    # store result
    my $Result;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        $Result = $Row[0];
    }

    # check if data exists
    if ( !$Result ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Found no SenderType(ID) for $Key!",
        );
        return;
    }

    # set cache
    $Kernel::OM->Get('Kernel::System::Cache')->Set(
        Type  => $Self->{CacheType},
        TTL   => $Self->{CacheTTL},
        Key   => $CacheKey,
        Value => $Result,
    );

    return $Result;
}
</pre></div>

<p>article sender lookup</p>

<pre>    my $SenderTypeID = $TicketObject-&gt;ArticleSenderTypeLookup(
        SenderType =&gt; 'customer', # customer|system|agent
    );

    my $SenderType = $TicketObject-&gt;ArticleSenderTypeLookup(
        SenderTypeID =&gt; 1,
    );
</pre><h2 id="ArticleTypeLookup">ArticleTypeLookup()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleTypeLookup');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleTypeLookup">
                                        <pre>

sub ArticleTypeLookup {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{ArticleType} && !$Param{ArticleTypeID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need ArticleType or ArticleTypeID!',
        );
        return;
    }

    # get key
    my $Key;
    my $CacheKey;
    if ( $Param{ArticleType} ) {
        $Key      = $Param{ArticleType};
        $CacheKey = 'ArticleTypeLookup::ArticleType::' . $Param{ArticleType};
    }
    else {
        $Key      = $Param{ArticleTypeID};
        $CacheKey = 'ArticleTypeLookup::ArticleTypeID::' . $Param{ArticleTypeID};
    }

    # check cache
    my $Cache = $Kernel::OM->Get('Kernel::System::Cache')->Get(
        Type => $Self->{CacheType},
        Key  => $CacheKey,
    );
    return $Cache if $Cache;

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # get data
    if ( $Param{ArticleType} ) {
        return if !$DBObject->Prepare(
            SQL  => 'SELECT id FROM article_type WHERE name = ?',
            Bind => [ \$Param{ArticleType} ],
        );
    }
    else {
        return if !$DBObject->Prepare(
            SQL  => 'SELECT name FROM article_type WHERE id = ?',
            Bind => [ \$Param{ArticleTypeID} ],
        );
    }

    # store result
    my $Result;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        $Result = $Row[0];
    }

    # check if data exists
    if ( !$Result ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Found no ArticleType(ID) for $Key!",
        );
        return;
    }

    # set cache
    $Kernel::OM->Get('Kernel::System::Cache')->Set(
        Type  => $Self->{CacheType},
        TTL   => $Self->{CacheTTL},
        Key   => $CacheKey,
        Value => $Result,
    );

    # return
    return $Result;
}
</pre></div>

<p>article type lookup</p>

<pre>    my $ArticleTypeID = $TicketObject-&gt;ArticleTypeLookup(
        ArticleType =&gt; 'webrequest-customer', # note-internal|...
    );

    my $ArticleType = $TicketObject-&gt;ArticleTypeLookup(
        ArticleTypeID =&gt; 1,
    );
</pre><h2 id="ArticleTypeList">ArticleTypeList()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleTypeList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleTypeList">
                                        <pre>

sub ArticleTypeList {
    my ( $Self, %Param ) = @_;

    # get needed objects
    my $DBObject    = $Kernel::OM->Get('Kernel::System::DB');
    my $ValidObject = $Kernel::OM->Get('Kernel::System::Valid');

    return if !$DBObject->Prepare(
        SQL => "SELECT id, name FROM article_type WHERE "
            . "valid_id IN (${\(join ', ', $ValidObject->ValidIDsGet())})",
    );

    my @Array;
    my %Hash;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        if ( $Param{Type} && $Param{Type} eq 'Customer' ) {

            # Skip internal articles.
            if ( $Row[1] !~ /-int/i ) {
                push @Array, $Row[1];
                $Hash{ $Row[0] } = $Row[1];
            }
        }
        else {
            push @Array, $Row[1];
            $Hash{ $Row[0] } = $Row[1];
        }
    }

    if ( $Param{Result} && $Param{Result} eq 'HASH' ) {
        return %Hash;
    }

    return @Array;
}
</pre></div>

<p>get a article type list</p>

<pre>    my @ArticleTypeList = $TicketObject-&gt;ArticleTypeList(
        Result =&gt; 'ARRAY', # optional, ARRAY|HASH
    );

    # to get only article types visible for customers
    my @ArticleTypeList = $TicketObject-&gt;ArticleTypeList(
        Result =&gt; 'ARRAY',    # optional, ARRAY|HASH
        Type   =&gt; 'Customer', # optional to get only customer viewable article types
    );
</pre><h2 id="ArticleLastCustomerArticle">ArticleLastCustomerArticle()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleLastCustomerArticle');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleLastCustomerArticle">
                                        <pre>

sub ArticleLastCustomerArticle {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{TicketID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Need TicketID!"
        );
        return;
    }

    # get article index
    my @Index = $Self->ArticleIndex(
        TicketID   => $Param{TicketID},
        SenderType => 'customer'
    );

    # get article data
    if (@Index) {
        return $Self->ArticleGet(
            ArticleID     => $Index[-1],
            Extended      => $Param{Extended},
            DynamicFields => $Param{DynamicFields},
        );
    }

    # get whole article index
    @Index = $Self->ArticleIndex( TicketID => $Param{TicketID} );
    return if !@Index;

    # second try, return latest non internal article
    for my $ArticleID ( reverse @Index ) {
        my %Article = $Self->ArticleGet(
            ArticleID     => $ArticleID,
            Extended      => $Param{Extended},
            DynamicFields => $Param{DynamicFields},
        );
        if ( $Article{StateType} eq 'merged' || $Article{ArticleType} !~ /-int/ ) {
            return %Article;
        }
    }

    # third try, if we got no internal article, return the latest one
    return $Self->ArticleGet(
        ArticleID     => $Index[-1],
        Extended      => $Param{Extended},
        DynamicFields => $Param{DynamicFields},
    );
}
</pre></div>

<p>get last customer article</p>

<pre>    my %Article = $TicketObject-&gt;ArticleLastCustomerArticle(
        TicketID      =&gt; 123,
        Extended      =&gt; 1,      # 0 or 1, see ArticleGet(),
        DynamicFields =&gt; 1,      # 0 or 1, see ArticleGet(),
    );
</pre><h2 id="ArticleFirstArticle">ArticleFirstArticle()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleFirstArticle');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleFirstArticle">
                                        <pre>

sub ArticleFirstArticle {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{TicketID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Need TicketID!"
        );
        return;
    }

    # get article index
    my @Index = $Self->ArticleIndex( TicketID => $Param{TicketID} );

    # get article data
    return if !@Index;

    return $Self->ArticleGet(
        ArticleID     => $Index[0],
        Extended      => $Param{Extended},
        DynamicFields => $Param{DynamicFields},
    );
}
</pre></div>

<p>get first article</p>

<pre>    my %Article = $TicketObject-&gt;ArticleFirstArticle(
        TicketID      =&gt; 123,
        DynamicFields =&gt; 1,     # 0 or 1, see ArticleGet()
    );
</pre><h2 id="ArticleIndex">ArticleIndex()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleIndex');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleIndex">
                                        <pre>

sub ArticleIndex {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{TicketID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need TicketID!'
        );
        return;
    }

    # Only cache known sender types, because the cache keys of
    #   unknown ones cannot be invalidated in _TicketCacheClear().
    my %CacheableSenderTypes = (
        'agent'    => 1,
        'customer' => 1,
        'system'   => 1,
        'ALL'      => 1,
    );

    my $UseCache = $CacheableSenderTypes{ $Param{SenderType} || 'ALL' };

    my $CacheKey = 'ArticleIndex::' . $Param{TicketID} . '::' . ( $Param{SenderType} || 'ALL' );

    if ($UseCache) {
        my $Cached = $Kernel::OM->Get('Kernel::System::Cache')->Get(
            Type => $Self->{CacheType},
            Key  => $CacheKey,
        );

        if ( ref $Cached eq 'ARRAY' ) {
            return @{$Cached};
        }

    }

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # db query
    if ( $Param{SenderType} ) {
        return if !$DBObject->Prepare(
            SQL => '
                SELECT art.id FROM article art, article_sender_type ast
                WHERE art.ticket_id = ?
                    AND art.article_sender_type_id = ast.id
                    AND ast.name = ?
                ORDER BY art.id',
            Bind => [ \$Param{TicketID}, \$Param{SenderType} ],
        );
    }
    else {
        return if !$DBObject->Prepare(
            SQL => '
                SELECT id
                FROM article
                WHERE ticket_id = ?
                ORDER BY id',
            Bind => [ \$Param{TicketID} ],
        );
    }

    my @Index;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        push @Index, $Row[0];
    }

    if ($UseCache) {
        $Kernel::OM->Get('Kernel::System::Cache')->Set(
            Type  => $Self->{CacheType},
            TTL   => $Self->{CacheTTL},
            Key   => $CacheKey,
            Value => \@Index,
        );
    }

    return @Index;
}
</pre></div>

<p>returns an array with article IDs</p>

<pre>    my @ArticleIDs = $TicketObject-&gt;ArticleIndex(
        TicketID =&gt; 123,
    );

    my @ArticleIDs = $TicketObject-&gt;ArticleIndex(
        SenderType =&gt; 'customer',                   # optional, to limit to a certain sender type
        TicketID   =&gt; 123,
    );
</pre><h2 id="ArticleContentIndex">ArticleContentIndex()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleContentIndex');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleContentIndex">
                                        <pre>

sub ArticleContentIndex {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(TicketID UserID)) {
        if ( !$Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    my @ArticleBox = $Self->ArticleGet(
        TicketID            => $Param{TicketID},
        ArticleType         => $Param{ArticleType},
        UserID              => $Param{UserID},
        DynamicFields       => $Param{DynamicFields},
        Page                => $Param{Page},
        Limit               => $Param{Limit},
        ArticleTypeID       => $Param{ArticleTypeID},
        ArticleSenderTypeID => $Param{ArticleSenderTypeID},
        Order               => $Param{Order},
    );

    # article attachments of each article
    for my $Article (@ArticleBox) {

        # get attachment index (without attachments)
        my %AtmIndex = $Self->ArticleAttachmentIndex(
            ContentPath                => $Article->{ContentPath},
            ArticleID                  => $Article->{ArticleID},
            StripPlainBodyAsAttachment => $Param{StripPlainBodyAsAttachment},
            Article                    => $Article,
            UserID                     => $Param{UserID},
        );
        $Article->{Atms} = \%AtmIndex;
    }
    return @ArticleBox;
}
</pre></div>

<p>returns an array with hash ref (hash contains result of ArticleGet())</p>

<pre>    my @ArticleBox = $TicketObject-&gt;ArticleContentIndex(
        TicketID      =&gt; 123,
        DynamicFields =&gt; 1,         # 0 or 1, default 1. To include or not the dynamic field values on the return structure.
        UserID        =&gt; 1,
        Order         =&gt; 'ASC',     # 'ASC' or 'DESC', default 'ASC'
    );
</pre><p>or with &quot;StripPlainBodyAsAttachment =&gt; 1&quot; feature to not include first
attachment / body and html body as attachment</p>

<pre>    my @ArticleBox = $TicketObject-&gt;ArticleContentIndex(
        TicketID                   =&gt; 123,
        UserID                     =&gt; 1,
        StripPlainBodyAsAttachment =&gt; 1,
    );
</pre><p>or with &quot;StripPlainBodyAsAttachment =&gt; 2&quot; feature to not include first
attachment / body as attachment (html body will be shown as attachment)</p>

<pre>    my @ArticleBox = $TicketObject-&gt;ArticleContentIndex(
        TicketID                   =&gt; 123,
        UserID                     =&gt; 1,
        StripPlainBodyAsAttachment =&gt; 2,
    );
</pre><p>returns an array with hash ref (hash contains result of ArticleGet())
only with given article types</p>

<pre>    my @ArticleBox = $TicketObject-&gt;ArticleContentIndex(
        TicketID    =&gt; 123,
        UserID      =&gt; 1,
        ArticleType =&gt; [ $ArticleType1, $ArticleType2 ],
        # or
        ArticleTypeID =&gt; [ $ArticleTypeID1, $ArticleTypeID2 ],
    );
</pre><p>Likewise <code>ArticleSenderTypeID</code> allows filtering of only articles with
the given sender type IDs.</p>

<p>example of how to access the hash ref</p>

<pre>    for my $Article (@ArticleBox) {
        print &quot;From: $Article-&gt;{From}\n&quot;;
    }
</pre><p>Note: If an attachment with html body content is available, the attachment id
is returned as 'AttachmentIDOfHTMLBody' in hash ref.</p>

<p>You can limit the list of returned elements with the <code>Page</code> and <code>Limit</code>
parameters:</p>

<pre>    my @ArticleBox = $TicketObject-&gt;ArticleContentIndex(
        TicketID    =&gt; 123,
        UserID      =&gt; 1,
        Limit       =&gt; 5,
        Page        =&gt; 3,   # get 11th to 16th element
    );
</pre><h2 id="ArticleGet">ArticleGet()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleGet">
                                        <pre>

sub ArticleGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{ArticleID} && !$Param{TicketID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need ArticleID or TicketID!'
        );
        return;
    }

    my $FetchDynamicFields = $Param{DynamicFields} ? 1 : 0;

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # article type lookup
    my $ArticleTypeSQL = '';
    if ( $Param{ArticleType} && ref $Param{ArticleType} eq 'ARRAY' ) {
        for ( @{ $Param{ArticleType} } ) {
            if ( $Self->ArticleTypeLookup( ArticleType => $_ ) ) {
                if ($ArticleTypeSQL) {
                    $ArticleTypeSQL .= ',';
                }
                $ArticleTypeSQL .= $DBObject->Quote(
                    $Self->ArticleTypeLookup( ArticleType => $_ ),
                    'Integer',
                );
            }
        }
        if ($ArticleTypeSQL) {
            $ArticleTypeSQL = " AND sa.article_type_id IN ($ArticleTypeSQL)";
        }
    }
    my $ArticleTypeIDSQL = '';
    if ( IsArrayRefWithData( $Param{ArticleTypeID} ) ) {
        my $QuotedIDs = join ', ',
            map { $DBObject->Quote( $_, 'Integer' ) }
            @{ $Param{ArticleTypeID} };
        $ArticleTypeIDSQL = " AND sa.article_type_id IN ($QuotedIDs)";
    }

    # sender type lookup
    my $SenderTypeSQL = '';
    if ( $Param{ArticleSenderType} && ref $Param{ArticleSenderType} eq 'ARRAY' ) {
        for ( @{ $Param{ArticleSenderType} } ) {
            if ( $Self->ArticleSenderTypeLookup( SenderType => $_ ) ) {
                if ($SenderTypeSQL) {
                    $SenderTypeSQL .= ',';
                }
                $SenderTypeSQL .= $DBObject->Quote(
                    $Self->ArticleSenderTypeLookup( SenderType => $_ ),
                    'Integer',
                );
            }
        }
        if ($SenderTypeSQL) {
            $SenderTypeSQL = " AND sa.article_sender_type_id IN ($SenderTypeSQL)";
        }
    }

    my $SenderTypeIDSQL;
    if ( IsArrayRefWithData( $Param{ArticleSenderTypeID} ) ) {
        my $QuotedIDs = join ', ',
            map { $DBObject->Quote( $_, 'Integer' ) }
            @{ $Param{ArticleSenderTypeID} };
        $SenderTypeIDSQL = " AND sa.article_sender_type_id IN ($QuotedIDs)";
    }

    # sql query
    my @Content;
    my @Bind;
    my $SQL = '
        SELECT sa.ticket_id, sa.a_from, sa.a_to, sa.a_cc, sa.a_subject,
            sa.a_reply_to, sa.a_message_id, sa.a_in_reply_to, sa.a_references, sa.a_body,
            st.create_time_unix, st.ticket_state_id, st.queue_id, sa.create_time,
            sa.a_content_type, sa.create_by, st.tn, article_sender_type_id, st.customer_id,
            st.until_time, st.ticket_priority_id, st.customer_user_id, st.user_id,
            st.responsible_user_id, sa.article_type_id,
            sa.incoming_time, sa.id,
            st.ticket_lock_id, st.title, st.escalation_update_time,
            st.type_id, st.service_id, st.sla_id, st.escalation_response_time,
            st.escalation_solution_time, st.escalation_time, st.change_time
        FROM article sa
        JOIN ticket st ON sa.ticket_id = st.id
        WHERE ';

    if ( $Param{ArticleID} ) {
        $SQL .= 'sa.id = ?';
        push @Bind, \$Param{ArticleID};
    }
    else {
        $SQL .= 'sa.ticket_id = ?';
        push @Bind, \$Param{TicketID};
    }

    # add article types
    if ($ArticleTypeSQL) {
        $SQL .= $ArticleTypeSQL;
    }
    if ($ArticleTypeIDSQL) {
        $SQL .= $ArticleTypeIDSQL;
    }

    # add sender types
    if ($SenderTypeSQL) {
        $SQL .= $SenderTypeSQL;
    }
    if ($SenderTypeIDSQL) {
        $SQL .= $SenderTypeIDSQL;
    }

    # set order
    if ( $Param{Order} && $Param{Order} eq 'DESC' ) {
        $SQL .= ' ORDER BY sa.create_time DESC, sa.id DESC';
    }
    else {
        $SQL .= ' ORDER BY sa.create_time, sa.id ASC';
    }

    my $Start;

    if ( $Param{Page} ) {
        $Start = $Param{Limit} * ( $Param{Page} - 1 );
    }

    # get time object
    my $TimeObject = $Kernel::OM->Get('Kernel::System::Time');

    return if !$DBObject->Prepare(
        SQL   => $SQL,
        Bind  => \@Bind,
        Limit => $Param{Limit},
        Start => $Start,
    );

    my %Ticket;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        my %Data;
        $Data{TicketID}   = $Row[0];
        $Ticket{TicketID} = $Data{TicketID};
        $Data{From}       = $Row[1];
        $Data{To}         = $Row[2];
        $Data{Cc}         = $Row[3];
        $Data{Subject}    = $Row[4];

        $Data{ReplyTo}    = $Row[5];
        $Data{MessageID}  = $Row[6];
        $Data{InReplyTo}  = $Row[7];
        $Data{References} = $Row[8];
        $Data{Body}       = $Row[9];

        $Ticket{CreateTimeUnix} = $Row[10];
        $Data{StateID}          = $Row[11];
        $Ticket{StateID}        = $Row[11];
        $Data{QueueID}          = $Row[12];
        $Ticket{QueueID}        = $Row[12];
        $Ticket{AgeTimeUnix}    = $TimeObject->SystemTime()
            - $TimeObject->TimeStamp2SystemTime( String => $Row[13] );
        $Ticket{Created} = $TimeObject->SystemTime2TimeStamp( SystemTime => $Ticket{CreateTimeUnix} );
        $Data{ContentType} = $Row[14];

        $Data{CreatedBy}           = $Row[15];
        $Data{TicketNumber}        = $Row[16];
        $Data{SenderTypeID}        = $Row[17];
        $Data{CustomerID}          = $Row[18];
        $Ticket{CustomerID}        = $Row[18];
        $Data{RealTillTimeNotUsed} = $Row[19];

        $Data{PriorityID}       = $Row[20];
        $Ticket{PriorityID}     = $Row[20];
        $Data{CustomerUserID}   = $Row[21];
        $Ticket{CustomerUserID} = $Row[21];
        $Data{OwnerID}          = $Row[22];
        $Ticket{OwnerID}        = $Row[22];
        $Data{ResponsibleID}    = $Row[23] || 1;
        $Ticket{ResponsibleID}  = $Row[23] || 1;
        $Data{ArticleTypeID}    = $Row[24];

        $Data{IncomingTime} = $Row[25];
        $Data{Created}      = $TimeObject->SystemTime2TimeStamp(
            SystemTime => $Row[25],
        );
        $Data{ArticleID}              = $Row[26];
        $Ticket{LockID}               = $Row[27];
        $Data{Title}                  = $Row[28];
        $Ticket{Title}                = $Data{Title};
        $Data{EscalationUpdateTime}   = $Row[29];
        $Ticket{EscalationUpdateTime} = $Data{EscalationUpdateTime};

        $Data{TypeID}                   = $Row[30];
        $Ticket{TypeID}                 = $Row[30];
        $Data{ServiceID}                = $Row[31];
        $Ticket{ServiceID}              = $Row[31];
        $Data{SLAID}                    = $Row[32];
        $Ticket{SLAID}                  = $Row[32];
        $Data{EscalationResponseTime}   = $Row[33];
        $Ticket{EscalationResponseTime} = $Data{EscalationResponseTime};
        $Data{EscalationSolutionTime}   = $Row[34];
        $Ticket{EscalationSolutionTime} = $Data{EscalationSolutionTime};
        $Data{EscalationTime}           = $Row[35];
        $Ticket{EscalationTime}         = $Data{EscalationTime};
        $Ticket{Changed}                = $Row[36];

        if ( $Data{ContentType} && $Data{ContentType} =~ /charset=/i ) {
            $Data{Charset} = $Data{ContentType};
            $Data{Charset} =~ s/.+?charset=("|'|)(\w+)/$2/gi;
            $Data{Charset} =~ s/"|'//g;
            $Data{Charset} =~ s/(.+?);.*/$1/g;

        }
        else {
            $Data{Charset} = '';
        }

        # compat.
        $Data{ContentCharset} = $Data{Charset};

        if ( $Data{ContentType} && $Data{ContentType} =~ /^(\w+\/\w+)/i ) {
            $Data{MimeType} = $1;
            $Data{MimeType} =~ s/"|'//g;
        }
        else {
            $Data{MimeType} = '';
        }

        # fill up dynamic variables
        $Data{Age} = $TimeObject->SystemTime() - $Ticket{CreateTimeUnix};

        # strip not wanted stuff
        RECIPIENT:
        for my $Key (qw(From To Cc Subject)) {
            next RECIPIENT if !$Data{$Key};
            $Data{$Key} =~ s/\n|\r//g;
        }

        push @Content, { %Ticket, %Data };
    }

    # check if need to return dynamic fields
    if ($FetchDynamicFields) {

        # get dynamic field objects
        my $DynamicFieldObject        = $Kernel::OM->Get('Kernel::System::DynamicField');
        my $DynamicFieldBackendObject = $Kernel::OM->Get('Kernel::System::DynamicField::Backend');

        my $DynamicFieldArticleList = $DynamicFieldObject->DynamicFieldListGet(
            ObjectType => 'Article'
        );

        my $DynamicFieldTicketList = $DynamicFieldObject->DynamicFieldListGet(
            ObjectType => 'Ticket'
        );

        for my $Article (@Content) {
            DYNAMICFIELD:
            for my $DynamicFieldConfig ( @{$DynamicFieldArticleList} ) {

                # validate each dynamic field
                next DYNAMICFIELD if !$DynamicFieldConfig;
                next DYNAMICFIELD if !IsHashRefWithData($DynamicFieldConfig);
                next DYNAMICFIELD if !$DynamicFieldConfig->{Name};
                next DYNAMICFIELD if !IsHashRefWithData( $DynamicFieldConfig->{Config} );

                # get the current value for each dynamic field
                my $Value = $DynamicFieldBackendObject->ValueGet(
                    DynamicFieldConfig => $DynamicFieldConfig,
                    ObjectID           => $Article->{ArticleID},
                );

                # set the dynamic field name and value into the ticket hash
                $Article->{ 'DynamicField_' . $DynamicFieldConfig->{Name} } = $Value;
            }

            DYNAMICFIELD:
            for my $DynamicFieldConfig ( @{$DynamicFieldTicketList} ) {

                # validate each dynamic field
                next DYNAMICFIELD if !$DynamicFieldConfig;
                next DYNAMICFIELD if !IsHashRefWithData($DynamicFieldConfig);
                next DYNAMICFIELD if !$DynamicFieldConfig->{Name};
                next DYNAMICFIELD if !IsHashRefWithData( $DynamicFieldConfig->{Config} );

                # get the current value for each dynamic field
                my $Value = $DynamicFieldBackendObject->ValueGet(
                    DynamicFieldConfig => $DynamicFieldConfig,
                    ObjectID           => $Article->{TicketID},
                );

                # set the dynamic field name and value into the ticket hash
                $Article->{ 'DynamicField_' . $DynamicFieldConfig->{Name} } = $Value;

                # check if field is TicketFreeKey[1-16], TicketFreeText[1-6] or TicketFreeTime[1-6]
                # Compatibility feature can be removed on further versions
                if (
                    $DynamicFieldConfig->{Name} =~ m{
                        \A
                        (
                            TicketFree
                            (?:
                                (?:Text|Key)
                                (?:1[0-6]|[1-9])
                                |
                                (?:Time [1-6])
                            )
                        )
                        \z
                    }smxi
                    )
                {

                    # Set field for 3.0 and 2.4 compatibility
                    $Article->{ $DynamicFieldConfig->{Name} } = $Value;
                }
            }
        }
    }

    # return if content is empty
    if ( !@Content ) {

        # Log an error only if a specific article was requested and there is no filter active.
        if ( $Param{ArticleID} && !$ArticleTypeSQL && !$SenderTypeSQL ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "No such article for ArticleID ($Param{ArticleID})!",
            );
        }

        return;
    }

    # get type object
    my $TypeObject = $Kernel::OM->Get('Kernel::System::Type');

    # get default ticket type
    my $DefaultTicketType = $Kernel::OM->Get('Kernel::Config')->Get('Ticket::Type::Default');

    # check if default ticket type exists
    my %AllTicketTypes = reverse $TypeObject->TypeList();

    # get type
    if ( defined $Ticket{TypeID} ) {
        $Ticket{Type} = $TypeObject->TypeLookup(
            TypeID => $Ticket{TypeID}
        );
    }
    elsif ( $AllTicketTypes{$DefaultTicketType} ) {
        $Ticket{Type} = $DefaultTicketType;
    }
    else {
        $Ticket{Type} = $TypeObject->TypeLookup(
            TypeID => 1
        );
    }

    # get user object
    my $UserObject = $Kernel::OM->Get('Kernel::System::User');

    # get owner
    $Ticket{Owner} = $UserObject->UserLookup(
        UserID => $Ticket{OwnerID},
    );

    # get responsible
    $Ticket{Responsible} = $UserObject->UserLookup(
        UserID => $Ticket{ResponsibleID},
    );

    # get priority
    $Ticket{Priority} = $Kernel::OM->Get('Kernel::System::Priority')->PriorityLookup(
        PriorityID => $Ticket{PriorityID},
    );

    # get lock
    $Ticket{Lock} = $Kernel::OM->Get('Kernel::System::Lock')->LockLookup(
        LockID => $Ticket{LockID},
    );

    # get service
    if ( $Ticket{ServiceID} ) {
        $Ticket{Service} = $Kernel::OM->Get('Kernel::System::Service')->ServiceLookup(
            ServiceID => $Ticket{ServiceID},
        );
    }

    # get sla
    if ( $Ticket{SLAID} ) {
        $Ticket{SLA} = $Kernel::OM->Get('Kernel::System::SLA')->SLALookup(
            SLAID => $Ticket{SLAID},
        );
    }

    # get queue name and other stuff
    my %Queue = $Kernel::OM->Get('Kernel::System::Queue')->QueueGet(
        ID => $Ticket{QueueID},
    );

    # get state info
    my %StateData = $Kernel::OM->Get('Kernel::System::State')->StateGet(
        ID => $Ticket{StateID},
    );

    $Ticket{StateType} = $StateData{TypeName};
    $Ticket{State}     = $StateData{Name};

    # get escalation attributes
    my %Escalation = $Self->TicketEscalationDateCalculation(
        Ticket => \%Ticket,
        UserID => $Param{UserID} || 1,
    );
    for my $Part (@Content) {
        for ( sort keys %Escalation ) {
            $Part->{$_} = $Escalation{$_};
        }
    }

    # do extended lookups
    if ( $Param{Extended} ) {
        my %TicketExtended = $Self->_TicketGetExtended(
            TicketID => $Ticket{TicketID},
            Ticket   => \%Ticket,
        );
        for my $Key ( sort keys %TicketExtended ) {
            $Ticket{$Key} = $TicketExtended{$Key};
        }
        for my $Part (@Content) {
            for ( sort keys %TicketExtended ) {
                $Part->{$_} = $TicketExtended{$_};
            }
        }
    }

    # create email parser object
    my $EmailParser = Kernel::System::EmailParser->new(
        Mode => 'Standalone',
    );

    # article stuff
    for my $Part (@Content) {

        # get type
        $Part->{Type} = $Ticket{Type};

        # get owner
        $Part->{Owner} = $Ticket{Owner};

        # get responsible
        $Part->{Responsible} = $Ticket{Responsible};

        # get sender type
        $Part->{SenderType} = $Self->ArticleSenderTypeLookup(
            SenderTypeID => $Part->{SenderTypeID},
        );

        # get article type
        $Part->{ArticleType} = $Self->ArticleTypeLookup(
            ArticleTypeID => $Part->{ArticleTypeID},
        );

        # get priority name
        $Part->{Priority} = $Ticket{Priority};
        $Part->{LockID}   = $Ticket{LockID};
        $Part->{Lock}     = $Ticket{Lock};
        $Part->{Queue}    = $Queue{Name};
        $Part->{Service}  = $Ticket{Service} || '';
        $Part->{SLA}      = $Ticket{SLA} || '';
        if ( !$Part->{RealTillTimeNotUsed} || $StateData{TypeName} !~ /^pending/i ) {
            $Part->{UntilTime} = 0;
        }
        else {
            $Part->{UntilTime} = $Part->{RealTillTimeNotUsed} - $TimeObject->SystemTime();
        }
        $Part->{StateType} = $StateData{TypeName};
        $Part->{State}     = $StateData{Name};

        # add real name lines
        RECIPIENT:
        for my $Key (qw( From To Cc)) {
            next RECIPIENT if !$Part->{$Key};

            # check if it's a queue
            if ( $Part->{$Key} !~ /@/ ) {
                $Part->{ $Key . 'Realname' } = $Part->{$Key};
                next RECIPIENT;
            }

            # strip out real names
            my $Realname = '';
            EMAILADDRESS:
            for my $EmailSplit ( $EmailParser->SplitAddressLine( Line => $Part->{$Key} ) ) {
                my $Name = $EmailParser->GetRealname( Email => $EmailSplit );
                if ( !$Name ) {
                    $Name = $EmailParser->GetEmailAddress( Email => $EmailSplit );
                }
                next EMAILADDRESS if !$Name;
                if ($Realname) {
                    $Realname .= ', ';
                }
                $Realname .= $Name;
            }

            $Part->{ $Key . 'Realname' } = $Realname;
        }
    }

    if ( $Param{ArticleID} ) {
        return %{ $Content[0] };
    }
    return @Content;
}
</pre></div>

<p>returns article data</p>

<pre>    my %Article = $TicketObject-&gt;ArticleGet(
        ArticleID     =&gt; 123,
        DynamicFields =&gt; 1,      # Optional. To include the dynamic field values for this article on the return structure.
        UserID        =&gt; 123,
    );
</pre><p>Article:
    ArticleID
    From
    To
    Cc
    Subject
    Body
    ReplyTo
    MessageID
    InReplyTo
    References
    SenderType
    SenderTypeID
    ArticleType
    ArticleTypeID
    ContentType
    Charset
    MimeType
    IncomingTime</p>

<pre>    # If DynamicFields =&gt; 1 was passed, you'll get an entry like this for each dynamic field:
    DynamicField_X     =&gt; 'value_x',
</pre><p>Ticket:
    - see TicketGet() for ticket attributes -</p>

<p>returns articles in array / hash by given ticket id</p>

<pre>    my @ArticleIndex = $TicketObject-&gt;ArticleGet(
        TicketID =&gt; 123,
        UserID   =&gt; 123,
    );
</pre><p>returns articles in array / hash by given ticket id but
only requested article types</p>

<pre>    my @ArticleIndex = $TicketObject-&gt;ArticleGet(
        TicketID      =&gt; 123,
        ArticleType   =&gt; [ $ArticleType1, $ArticleType2 ],
        # or
        ArticleTypeID =&gt; [ $ArticleTypeID1, $ArticleTypeID2 ],
        UserID        =&gt; 123,
    );
</pre><p>returns articles in array / hash by given ticket id but
only requested article sender types (could be useful when
trying to exclude autoreplies sent by system sender from
certain views)</p>

<pre>    my @ArticleIndex = $TicketObject-&gt;ArticleGet(
        TicketID            =&gt; 123,
        ArticleSenderType   =&gt; [ $ArticleSenderType1, $ArticleSenderType2 ],
        # or
        ArticleSenderTypeID =&gt; [ $ArticleSenderTypeID1, $ArticleSenderTypeID2 ],
        UserID              =&gt; 123,
    );
</pre><p>to get extended ticket attributes, use param Extended - see TicketGet() for extended attributes -</p>

<pre>    my @ArticleIndex = $TicketObject-&gt;ArticleGet(
        TicketID =&gt; 123,
        UserID   =&gt; 123,
        Extended =&gt; 1,
    );
</pre><p>to get only a dedicated count you can use Limit and Order attributes</p>

<pre>    my @ArticleIndex = $TicketObject-&gt;ArticleGet(
        TicketID =&gt; 123,
        UserID   =&gt; 123,
        Order    =&gt; 'DESC', # DESC,ASC - default is ASC
        Limit    =&gt; 5,
    );
</pre><p>You can also provide an offset by passing the <code>Page</code> argument. To get the
6th to 10th article, you can say</p>

<pre>    my @ArticleIndex = $TicketObject-&gt;ArticleGet(
        TicketID =&gt; 123,
        UserID   =&gt; 123,
        Limit    =&gt; 5,
        Page     =&gt; 2,
    );
</pre><p>Page numbers start with 1.</p>

<h2 id="ArticleCount">ArticleCount()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleCount');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleCount">
                                        <pre>

sub ArticleCount {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{TicketID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need TicketID!'
        );
        return;
    }

    my $SQL  = 'SELECT COUNT(id) FROM article WHERE ticket_id = ?';
    my @Bind = ( \$Param{TicketID} );
    if ( IsArrayRefWithData( $Param{ArticleTypeID} ) ) {
        $SQL .= sprintf ' AND article_type_id IN (%s) ',
            join ', ', ('?') x @{ $Param{ArticleTypeID} };
        push @Bind, map { \$_ } @{ $Param{ArticleTypeID} };
    }
    if ( IsArrayRefWithData( $Param{ArticleSenderTypeID} ) ) {
        $SQL .= sprintf ' AND article_sender_type_id IN (%s) ',
            join ', ', ('?') x @{ $Param{ArticleSenderTypeID} };
        push @Bind, map { \$_ } @{ $Param{ArticleSenderTypeID} };
    }

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    if ( defined $Param{UpToArticleID} ) {

        $DBObject->Prepare(
            SQL  => 'SELECT create_time FROM article WHERE id = ?',
            Bind => [ \$Param{UpToArticleID} ],
        );

        my $CreateTime;

        while ( my @Row = $DBObject->FetchrowArray() ) {
            $CreateTime = $Row[0];
        }

        if ( !defined $CreateTime ) {
            return 0;
        }

        my $Op = ( $Param{Order} // 'ASC' ) eq 'DESC' ? '>' : '<';

        $SQL .= " AND (create_time $Op ? OR (create_time = ? AND id $Op= ?))";
        push @Bind, \$CreateTime, \$CreateTime, \$Param{UpToArticleID};
    }

    return if !$DBObject->Prepare(
        SQL  => $SQL,
        Bind => \@Bind
    );

    my $Count;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        $Count = $Row[0];
    }

    return $Count;
}
</pre></div>

<p>Returns the number of articles for a ticket, possibly filtered by
ArticleSenderTypeID and ArticleTypeID</p>

<pre>    my $ArticleCount = $TicketID-&gt;ArticleCount(
        TicketID            =&gt; 123,
        ArticleTypeID       =&gt; [1, 2], # optional
        ArticleSenderTypeID =&gt; [1, 2], # optional
    );
</pre><p>If the argument <code>UpToArticleID</code> is given, only articles that would normally
shown before (and including) this article are shown; <code>Order</code> (which can
be <code>ASC</code> or <code>DESC</code>) controls whether ascending or descending order is used.</p>

<h2 id="ArticlePage">ArticlePage()</h2>

<p><a href="#" onclick="toggleCode('method_ArticlePage');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticlePage">
                                        <pre>

sub ArticlePage {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(ArticleID TicketID RowsPerPage)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!"
            );
            return;
        }
    }

    my $Count = $Self->ArticleCount(
        TicketID            => $Param{TicketID},
        UpToArticleID       => $Param{ArticleID},
        ArticleSenderTypeID => $Param{ArticleSenderTypeID},
        ArticleTypeID       => $Param{ArticleTypeID},
        Order               => $Param{Order},
    );

    return ceil( $Count / $Param{RowsPerPage} );
}
</pre></div>

<p>Get the page number of a given article when pagination is active</p>

<pre>    my $Page = $TicketObject-&gt;ArticlePage(
        TicketID            =&gt; 123,
        ArticleID           =&gt; 4242,
        RowsPerPage         =&gt; 20,
        ArticleTypeID       =&gt; [1, 2], # optional
        ArticleSenderTypeID =&gt; [1],    # optional
        Order               =&gt; 'DESC', # optional, 'ASC' or 'DESC'
    );
</pre><h2 id="ArticleUpdate">ArticleUpdate()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleUpdate');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleUpdate">
                                        <pre>

sub ArticleUpdate {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(ArticleID UserID Key TicketID)) {
        if ( !$Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    # check needed stuff
    if ( !defined $Param{Value} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need Value!'
        );
        return;
    }

    # lookup for ArticleType
    if ( $Param{Key} eq 'ArticleType' ) {
        $Param{Key}   = 'ArticleTypeID';
        $Param{Value} = $Self->ArticleTypeLookup(
            ArticleType => $Param{Value},
        );
    }

    # lookup for SenderType
    if ( $Param{Key} eq 'SenderType' ) {
        $Param{Key}   = 'SenderTypeID';
        $Param{Value} = $Self->ArticleSenderTypeLookup(
            SenderType => $Param{Value},
        );
    }

    # map
    my %Map = (
        Body          => 'a_body',
        Subject       => 'a_subject',
        From          => 'a_from',
        ReplyTo       => 'a_reply_to',
        To            => 'a_to',
        Cc            => 'a_cc',
        ArticleTypeID => 'article_type_id',
        SenderTypeID  => 'article_sender_type_id',
    );

    # db update
    return if !$Kernel::OM->Get('Kernel::System::DB')->Do(
        SQL => "UPDATE article SET $Map{$Param{Key}} = ?, "
            . "change_time = current_timestamp, change_by = ? WHERE id = ?",
        Bind => [ \$Param{Value}, \$Param{UserID}, \$Param{ArticleID} ],
    );

    $Self->_TicketCacheClear( TicketID => $Param{TicketID} );

    # event
    $Self->EventHandler(
        Event => 'ArticleUpdate',
        Data  => {
            TicketID  => $Param{TicketID},
            ArticleID => $Param{ArticleID},
        },
        UserID => $Param{UserID},
    );

    return 1;
}
</pre></div>

<p>update an article</p>

<p>Note: Keys &quot;Body&quot;, &quot;Subject&quot;, &quot;From&quot;, &quot;To&quot;, &quot;Cc&quot;, &quot;ReplyTo&quot;, &quot;ArticleType&quot; and &quot;SenderType&quot; are implemented.</p>

<pre>    my $Success = $TicketObject-&gt;ArticleUpdate(
        ArticleID =&gt; 123,
        Key       =&gt; 'Body',
        Value     =&gt; 'New Body',
        UserID    =&gt; 123,
        TicketID  =&gt; 123,
    );

    my $Success = $TicketObject-&gt;ArticleUpdate(
        ArticleID =&gt; 123,
        Key       =&gt; 'ArticleType',
        Value     =&gt; 'email-internal',
        UserID    =&gt; 123,
        TicketID  =&gt; 123,
    );
</pre><p>Events:
    ArticleUpdate</p>

<h2 id="ArticleSend">ArticleSend()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleSend');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleSend">
                                        <pre>

sub ArticleSend {
    my ( $Self, %Param ) = @_;

    my $ToOrig      = $Param{To}          || '';
    my $Loop        = $Param{Loop}        || 0;
    my $HistoryType = $Param{HistoryType} || 'SendAnswer';

    # check needed stuff
    for (qw(TicketID UserID From Body Charset MimeType)) {
        if ( !$Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    if ( !$Param{ArticleType} && !$Param{ArticleTypeID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need ArticleType or ArticleTypeID!',
        );
        return;
    }
    if ( !$Param{SenderType} && !$Param{SenderTypeID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need SenderType or SenderTypeID!',
        );
        return;
    }

    # map ReplyTo into Reply-To if present
    if ( $Param{ReplyTo} ) {
        $Param{'Reply-To'} = $Param{ReplyTo};
    }

    # clean up
    $Param{Body} =~ s/(\r\n|\n\r)/\n/g;
    $Param{Body} =~ s/\r/\n/g;

    # initialize parameter for attachments, so that the content pushed into that ref from
    # EmbeddedImagesExtract will stay available
    if ( !$Param{Attachment} ) {
        $Param{Attachment} = [];
    }

    # check for base64 images in body and process them
    $Kernel::OM->Get('Kernel::System::HTMLUtils')->EmbeddedImagesExtract(
        DocumentRef    => \$Param{Body},
        AttachmentsRef => $Param{Attachment},
    );

    # create article
    my $Time      = $Kernel::OM->Get('Kernel::System::Time')->SystemTime();
    my $Random    = rand 999999;
    my $FQDN      = $Kernel::OM->Get('Kernel::Config')->Get('FQDN');
    my $MessageID = "<$Time.$Random\@$FQDN>";
    my $ArticleID = $Self->ArticleCreate(
        %Param,
        MessageID => $MessageID,
    );
    return if !$ArticleID;

    # send mail
    my ( $HeadRef, $BodyRef ) = $Kernel::OM->Get('Kernel::System::Email')->Send(
        'Message-ID' => $MessageID,
        %Param,
    );

    # return if no mail was able to send
    if ( !$HeadRef || !$BodyRef ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Message  => "Impossible to send message to: $Param{'To'} .",
            Priority => 'error',
        );
        return;
    }

    # write article to fs
    my $Plain = $Self->ArticleWritePlain(
        ArticleID => $ArticleID,
        Email     => ${$HeadRef} . "\n" . ${$BodyRef},
        UserID    => $Param{UserID}
    );
    return if !$Plain;

    # log
    $Kernel::OM->Get('Kernel::System::Log')->Log(
        Priority => 'info',
        Message  => "Sent email to '$ToOrig' from '$Param{From}'. "
            . "HistoryType => $HistoryType, Subject => $Param{Subject};",
    );

    # event
    $Self->EventHandler(
        Event => 'ArticleSend',
        Data  => {
            TicketID  => $Param{TicketID},
            ArticleID => $ArticleID,
        },
        UserID => $Param{UserID},
    );

    return $ArticleID;
}
</pre></div>

<p>send article via email and create article with attachments</p>

<pre>    my $ArticleID = $TicketObject-&gt;ArticleSend(
        TicketID    =&gt; 123,
        ArticleType =&gt; 'note-internal',                                        # email-external|email-internal|phone|fax|...
        SenderType  =&gt; 'agent',                                                # agent|system|customer
        From        =&gt; 'Some Agent &lt;email@example.com&gt;',                       # not required but useful
        To          =&gt; 'Some Customer A &lt;customer-a@example.com&gt;',             # not required but useful
        Cc          =&gt; 'Some Customer B &lt;customer-b@example.com&gt;',             # not required but useful
        ReplyTo     =&gt; 'Some Customer B &lt;customer-b@example.com&gt;',             # not required, is possible to use 'Reply-To' instead
        Subject     =&gt; 'some short description',                               # required
        Body        =&gt; 'the message text',                                     # required
        InReplyTo   =&gt; '&lt;asdasdasd.12@example.com&gt;',                           # not required but useful
        References  =&gt; '&lt;asdasdasd.1@example.com&gt; &lt;asdasdasd.12@example.com&gt;', # not required but useful
        Charset     =&gt; 'iso-8859-15'
        MimeType    =&gt; 'text/plain',
        Loop        =&gt; 0, # 1|0 used for bulk emails
        Attachment =&gt; [
            {
                Content     =&gt; $Content,
                ContentType =&gt; $ContentType,
                Filename    =&gt; 'lala.txt',
            },
            {
                Content     =&gt; $Content,
                ContentType =&gt; $ContentType,
                Filename    =&gt; 'lala1.txt',
            },
        ],
        EmailSecurity =&gt; {
            Backend     =&gt; 'PGP',                       # PGP or SMIME
            Method      =&gt; 'Detached',                  # Optional Detached or Inline (defaults to Detached)
            SignKey     =&gt; '81877F5E',                  # Optional
            EncryptKeys =&gt; [ '81877F5E', '3b630c80' ],  # Optional
        }
        HistoryType    =&gt; 'OwnerUpdate',  # Move|AddNote|PriorityUpdate|WebRequestCustomer|...
        HistoryComment =&gt; 'Some free text!',
        NoAgentNotify  =&gt; 0,            # if you don't want to send agent notifications
        UserID         =&gt; 123,
    );




    my $ArticleID = $TicketObject-&gt;ArticleSend(                (Backwards compatibility)
        TicketID    =&gt; 123,
        ArticleType =&gt; 'note-internal',                                        # email-external|email-internal|phone|fax|...
        SenderType  =&gt; 'agent',                                                # agent|system|customer
        From        =&gt; 'Some Agent &lt;email@example.com&gt;',                       # not required but useful
        To          =&gt; 'Some Customer A &lt;customer-a@example.com&gt;',             # not required but useful
        Cc          =&gt; 'Some Customer B &lt;customer-b@example.com&gt;',             # not required but useful
        ReplyTo     =&gt; 'Some Customer B &lt;customer-b@example.com&gt;',             # not required, is possible to use 'Reply-To' instead
        Subject     =&gt; 'some short description',                               # required
        Body        =&gt; 'the message text',                                     # required
        InReplyTo   =&gt; '&lt;asdasdasd.12@example.com&gt;',                           # not required but useful
        References  =&gt; '&lt;asdasdasd.1@example.com&gt; &lt;asdasdasd.12@example.com&gt;', # not required but useful
        Charset     =&gt; 'iso-8859-15'
        MimeType    =&gt; 'text/plain',
        Loop        =&gt; 0, # 1|0 used for bulk emails
        Attachment =&gt; [
            {
                Content     =&gt; $Content,
                ContentType =&gt; $ContentType,
                Filename    =&gt; 'lala.txt',
            },
            {
                Content     =&gt; $Content,
                ContentType =&gt; $ContentType,
                Filename    =&gt; 'lala1.txt',
            },
        ],
        Sign =&gt; {
            Type    =&gt; 'PGP',
            SubType =&gt; 'Inline|Detached',
            Key     =&gt; '81877F5E',
            Type    =&gt; 'SMIME',
            Key     =&gt; '3b630c80',
        },
        Crypt =&gt; {
            Type    =&gt; 'PGP',
            SubType =&gt; 'Inline|Detached',
            Key     =&gt; '81877F5E',
            Type    =&gt; 'SMIME',
            Key     =&gt; '3b630c80',
        },
        HistoryType    =&gt; 'OwnerUpdate',  # Move|AddNote|PriorityUpdate|WebRequestCustomer|...
        HistoryComment =&gt; 'Some free text!',
        NoAgentNotify  =&gt; 0,            # if you don't want to send agent notifications
        UserID         =&gt; 123,
    );
</pre><p>Events:
    ArticleSend</p>

<h2 id="ArticleBounce">ArticleBounce()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleBounce');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleBounce">
                                        <pre>

sub ArticleBounce {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(TicketID ArticleID From To UserID)) {
        if ( !$Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    # create message id
    my $Time         = $Kernel::OM->Get('Kernel::System::Time')->SystemTime();
    my $Random       = rand 999999;
    my $FQDN         = $Kernel::OM->Get('Kernel::Config')->Get('FQDN');
    my $NewMessageID = "<$Time.$Random.0\@$FQDN>";
    my $Email        = $Self->ArticlePlain( ArticleID => $Param{ArticleID} );

    # check if plain email exists
    if ( !$Email ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "No such plain article for ArticleID ($Param{ArticleID})!",
        );
        return;
    }

    # pipe all into sendmail
    return if !$Kernel::OM->Get('Kernel::System::Email')->Bounce(
        'Message-ID' => $NewMessageID,
        From         => $Param{From},
        To           => $Param{To},
        Email        => $Email,
    );

    # write history
    my $HistoryType = $Param{HistoryType} || 'Bounce';
    $Self->HistoryAdd(
        TicketID     => $Param{TicketID},
        ArticleID    => $Param{ArticleID},
        HistoryType  => $HistoryType,
        Name         => "\%\%$Param{To}",
        CreateUserID => $Param{UserID},
    );

    # event
    $Self->EventHandler(
        Event => 'ArticleBounce',
        Data  => {
            TicketID  => $Param{TicketID},
            ArticleID => $Param{ArticleID},
        },
        UserID => $Param{UserID},
    );

    return 1;
}
</pre></div>

<p>bounce an article</p>

<pre>    my $Success = $TicketObject-&gt;ArticleBounce(
        From      =&gt; 'some@example.com',
        To        =&gt; 'webmaster@example.com',
        TicketID  =&gt; 123,
        ArticleID =&gt; 123,
        UserID    =&gt; 123,
    );
</pre><p>Events:
    ArticleBounce</p>

<h2 id="SendAutoResponse">SendAutoResponse()</h2>

<p><a href="#" onclick="toggleCode('method_SendAutoResponse');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SendAutoResponse">
                                        <pre>

sub SendAutoResponse {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(TicketID UserID OrigHeader AutoResponseType)) {
        if ( !$Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    # return if no notification is active
    return 1 if $Self->{SendNoNotification};

    # get orig email header
    my %OrigHeader = %{ $Param{OrigHeader} };

    # get ticket
    my %Ticket = $Self->TicketGet(
        TicketID      => $Param{TicketID},
        DynamicFields => 0,                  # not needed here, TemplateGenerator will fetch the ticket on its own
    );

    # get auto default responses
    my %AutoResponse = $Kernel::OM->Get('Kernel::System::TemplateGenerator')->AutoResponse(
        TicketID         => $Param{TicketID},
        AutoResponseType => $Param{AutoResponseType},
        OrigHeader       => $Param{OrigHeader},
        UserID           => $Param{UserID},
    );

    # return if no valid auto response exists
    return if !$AutoResponse{Text};
    return if !$AutoResponse{SenderRealname};
    return if !$AutoResponse{SenderAddress};

    # send if notification should be sent (not for closed tickets)!?
    my %State = $Kernel::OM->Get('Kernel::System::State')->StateGet( ID => $Ticket{StateID} );
    if (
        $Param{AutoResponseType} eq 'auto reply'
        && ( $State{TypeName} eq 'closed' || $State{TypeName} eq 'removed' )
        )
    {

        # add history row
        $Self->HistoryAdd(
            TicketID    => $Param{TicketID},
            HistoryType => 'Misc',
            Name        => "Sent no auto response or agent notification because ticket is "
                . "state-type '$State{TypeName}'!",
            CreateUserID => $Param{UserID},
        );

        # return
        return;
    }

    # log that no auto response was sent!
    if ( $OrigHeader{'X-OTRS-Loop'} && $OrigHeader{'X-OTRS-Loop'} !~ /^(false|no)$/i ) {

        # add history row
        $Self->HistoryAdd(
            TicketID    => $Param{TicketID},
            HistoryType => 'Misc',
            Name        => "Sent no auto-response because the sender doesn't want "
                . "an auto-response (e. g. loop or precedence header)",
            CreateUserID => $Param{UserID},
        );
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'info',
            Message  => "Sent no '$Param{AutoResponseType}' for Ticket ["
                . "$Ticket{TicketNumber}] ($OrigHeader{From}) because the "
                . "sender doesn't want an auto-response (e. g. loop or precedence header)"
        );
        return;
    }

    # check reply to for auto response recipient
    if ( $OrigHeader{ReplyTo} ) {
        $OrigHeader{From} = $OrigHeader{ReplyTo};
    }

    # get loop protection object
    my $LoopProtectionObject = $Kernel::OM->Get('Kernel::System::PostMaster::LoopProtection');

    # create email parser object
    my $EmailParser = Kernel::System::EmailParser->new(
        Mode => 'Standalone',
    );

    my @AutoReplyAddresses;
    my @Addresses = $EmailParser->SplitAddressLine( Line => $OrigHeader{From} );
    ADDRESS:
    for my $Address (@Addresses) {
        my $Email = $EmailParser->GetEmailAddress( Email => $Address );
        if ( !$Email ) {

            # add it to ticket history
            $Self->HistoryAdd(
                TicketID     => $Param{TicketID},
                CreateUserID => $Param{UserID},
                HistoryType  => 'Misc',
                Name         => "Sent no auto response to '$Address' - no valid email address.",
            );

            # log
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'notice',
                Message  => "Sent no auto response to '$Address' because of invalid address.",
            );
            next ADDRESS;

        }
        if ( !$LoopProtectionObject->Check( To => $Email ) ) {

            # add history row
            $Self->HistoryAdd(
                TicketID     => $Param{TicketID},
                HistoryType  => 'LoopProtection',
                Name         => "\%\%$Email",
                CreateUserID => $Param{UserID},
            );

            # log
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'notice',
                Message  => "Sent no '$Param{AutoResponseType}' for Ticket ["
                    . "$Ticket{TicketNumber}] ($Email) because of loop protection."
            );
            next ADDRESS;
        }
        else {

            # increase loop count
            return if !$LoopProtectionObject->SendEmail( To => $Email );
        }

        # check if sender is e. g. MAILER-DAEMON or Postmaster
        my $NoAutoRegExp = $Kernel::OM->Get('Kernel::Config')->Get('SendNoAutoResponseRegExp');
        if ( $Email =~ /$NoAutoRegExp/i ) {

            # add it to ticket history
            $Self->HistoryAdd(
                TicketID     => $Param{TicketID},
                CreateUserID => $Param{UserID},
                HistoryType  => 'Misc',
                Name         => "Sent no auto response to '$Email', SendNoAutoResponseRegExp matched.",
            );

            # log
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'info',
                Message  => "Sent no auto response to '$Email' because config"
                    . " option SendNoAutoResponseRegExp (/$NoAutoRegExp/i) matched.",
            );
            next ADDRESS;
        }

        push @AutoReplyAddresses, $Address;
    }

    my $AutoReplyAddresses = join( ', ', @AutoReplyAddresses );
    my $Cc;

    # also send CC to customer user if customer user id is used and addresses do not match
    if ( $Ticket{CustomerUserID} ) {

        my %CustomerUser = $Kernel::OM->Get('Kernel::System::CustomerUser')->CustomerUserDataGet(
            User => $Ticket{CustomerUserID},
        );

        if ( $CustomerUser{UserEmail} && $OrigHeader{From} !~ /\Q$CustomerUser{UserEmail}\E/i ) {
            $Cc = $CustomerUser{UserEmail};
        }
    }

    # get history type
    my $HistoryType;
    if ( $Param{AutoResponseType} =~ /^auto follow up$/i ) {
        $HistoryType = 'SendAutoFollowUp';
    }
    elsif ( $Param{AutoResponseType} =~ /^auto reply$/i ) {
        $HistoryType = 'SendAutoReply';
    }
    elsif ( $Param{AutoResponseType} =~ /^auto reply\/new ticket$/i ) {
        $HistoryType = 'SendAutoReply';
    }
    elsif ( $Param{AutoResponseType} =~ /^auto reject$/i ) {
        $HistoryType = 'SendAutoReject';
    }
    else {
        $HistoryType = 'Misc';
    }

    if ( !@AutoReplyAddresses && !$Cc ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'info',
            Message  => "No auto response addresses for Ticket [$Ticket{TicketNumber}]"
                . " (TicketID=$Param{TicketID})."
        );
        return;
    }

    # send email
    my $ArticleID = $Self->ArticleSend(
        ArticleType    => 'email-external',
        SenderType     => 'system',
        TicketID       => $Param{TicketID},
        HistoryType    => $HistoryType,
        HistoryComment => "\%\%$AutoReplyAddresses",
        From           => "$AutoResponse{SenderRealname} <$AutoResponse{SenderAddress}>",
        To             => $AutoReplyAddresses,
        Cc             => $Cc,
        Charset        => 'utf-8',
        MimeType       => $AutoResponse{ContentType},
        Subject        => $AutoResponse{Subject},
        Body           => $AutoResponse{Text},
        InReplyTo      => $OrigHeader{'Message-ID'},
        Loop           => 1,
        UserID         => $Param{UserID},
    );

    # log
    $Kernel::OM->Get('Kernel::System::Log')->Log(
        Priority => 'info',
        Message  => "Sent auto response ($HistoryType) for Ticket [$Ticket{TicketNumber}]"
            . " (TicketID=$Param{TicketID}, ArticleID=$ArticleID) to '$AutoReplyAddresses'."
    );

    # event
    $Self->EventHandler(
        Event => 'ArticleAutoResponse',
        Data  => {
            TicketID => $Param{TicketID},
        },
        UserID => $Param{UserID},
    );

    return 1;
}
</pre></div>

<p>send an auto response to a customer via email</p>

<pre>    my $ArticleID = $TicketObject-&gt;SendAutoResponse(
        TicketID         =&gt; 123,
        AutoResponseType =&gt; 'auto reply',
        OrigHeader       =&gt; {
            From    =&gt; 'some@example.com',
            Subject =&gt; 'For the message!',
        },
        UserID          =&gt; 123,
    );
</pre><p>Events:
    ArticleAutoResponse</p>

<h2 id="ArticleFlagSet">ArticleFlagSet()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleFlagSet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleFlagSet">
                                        <pre>

sub ArticleFlagSet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(ArticleID Key Value UserID)) {
        if ( !defined $Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    my %Flag = $Self->ArticleFlagGet(%Param);

    # check if set is needed
    return 1 if defined $Flag{ $Param{Key} } && $Flag{ $Param{Key} } eq $Param{Value};

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # set flag
    return if !$DBObject->Do(
        SQL => '
            DELETE FROM article_flag
            WHERE article_id = ?
                AND article_key = ?
                AND create_by = ?',
        Bind => [ \$Param{ArticleID}, \$Param{Key}, \$Param{UserID} ],
    );
    return if !$DBObject->Do(
        SQL => 'INSERT INTO article_flag
            (article_id, article_key, article_value, create_time, create_by)
            VALUES (?, ?, ?, current_timestamp, ?)',
        Bind => [ \$Param{ArticleID}, \$Param{Key}, \$Param{Value}, \$Param{UserID} ],
    );

    # event
    my %Article = $Self->ArticleGet(
        ArticleID     => $Param{ArticleID},
        UserID        => $Param{UserID},
        DynamicFields => 0,
    );
    $Self->EventHandler(
        Event => 'ArticleFlagSet',
        Data  => {
            TicketID  => $Article{TicketID},
            ArticleID => $Param{ArticleID},
            Key       => $Param{Key},
            Value     => $Param{Value},
            UserID    => $Param{UserID},
        },
        UserID => $Param{UserID},
    );

    return 1;
}
</pre></div>

<p>set article flags</p>

<pre>    my $Success = $TicketObject-&gt;ArticleFlagSet(
        ArticleID =&gt; 123,
        Key       =&gt; 'Seen',
        Value     =&gt; 1,
        UserID    =&gt; 123,
    );
</pre><p>Events:
    ArticleFlagSet</p>

<h2 id="ArticleFlagDelete">ArticleFlagDelete()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleFlagDelete');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleFlagDelete">
                                        <pre>

sub ArticleFlagDelete {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(ArticleID Key)) {
        if ( !$Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    if ( !$Param{AllUsers} && !$Param{UserID} ) {
        if ( !$Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need AllUsers or UserID!"
            );
            return;
        }
    }

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    if ( $Param{AllUsers} ) {
        return if !$DBObject->Do(
            SQL => '
                DELETE FROM article_flag
                WHERE article_id = ?
                    AND article_key = ?',
            Bind => [ \$Param{ArticleID}, \$Param{Key} ],
        );
    }
    else {
        return if !$DBObject->Do(
            SQL => '
                DELETE FROM article_flag
                WHERE article_id = ?
                    AND create_by = ?
                    AND article_key = ?',
            Bind => [ \$Param{ArticleID}, \$Param{UserID}, \$Param{Key} ],
        );

        # event
        my %Article = $Self->ArticleGet(
            ArticleID     => $Param{ArticleID},
            UserID        => $Param{UserID},
            DynamicFields => 0,
        );

        $Self->EventHandler(
            Event => 'ArticleFlagDelete',
            Data  => {
                TicketID  => $Article{TicketID},
                ArticleID => $Param{ArticleID},
                Key       => $Param{Key},
                UserID    => $Param{UserID},
            },
            UserID => $Param{UserID},
        );
    }

    return 1;
}
</pre></div>

<p>delete article flag</p>

<pre>    my $Success = $TicketObject-&gt;ArticleFlagDelete(
        ArticleID =&gt; 123,
        Key       =&gt; 'seen',
        UserID    =&gt; 123,
    );

    my $Success = $TicketObject-&gt;ArticleFlagDelete(
        ArticleID =&gt; 123,
        Key       =&gt; 'seen',
        AllUsers  =&gt; 1,         # delete for all users
    );
</pre><p>Events:
    ArticleFlagDelete</p>

<h2 id="ArticleFlagGet">ArticleFlagGet()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleFlagGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleFlagGet">
                                        <pre>

sub ArticleFlagGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(ArticleID UserID)) {
        if ( !$Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # sql query
    return if !$DBObject->Prepare(
        SQL => '
            SELECT article_key, article_value
            FROM article_flag
            WHERE article_id = ?
                AND create_by = ?',
        Bind  => [ \$Param{ArticleID}, \$Param{UserID} ],
        Limit => 1500,
    );

    my %Flag;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        $Flag{ $Row[0] } = $Row[1];
    }

    return %Flag;
}
</pre></div>

<p>get article flags</p>

<pre>    my %Flags = $TicketObject-&gt;ArticleFlagGet(
        ArticleID =&gt; 123,
        UserID    =&gt; 123,
    );
</pre><h2 id="ArticleFlagsOfTicketGet">ArticleFlagsOfTicketGet()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleFlagsOfTicketGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleFlagsOfTicketGet">
                                        <pre>

sub ArticleFlagsOfTicketGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(TicketID UserID)) {
        if ( !$Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # sql query
    return if !$DBObject->Prepare(
        SQL => '
            SELECT article.id, article_flag.article_key, article_flag.article_value
            FROM article_flag, article
            WHERE article.id = article_flag.article_id
                AND article.ticket_id = ?
                AND article_flag.create_by = ?',
        Bind  => [ \$Param{TicketID}, \$Param{UserID} ],
        Limit => 1500,
    );

    my %Flag;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        $Flag{ $Row[0] }->{ $Row[1] } = $Row[2];
    }

    return %Flag;
}
</pre></div>

<p>get all article flags of a ticket</p>

<pre>    my %Flags = $TicketObject-&gt;ArticleFlagsOfTicketGet(
        TicketID  =&gt; 123,
        UserID    =&gt; 123,
    );

    returns (
        123 =&gt; {                    # ArticleID
            'Seen'  =&gt; 1,
            'Other' =&gt; 'something',
        },
    )
</pre><h2 id="ArticleAccountedTimeGet">ArticleAccountedTimeGet()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleAccountedTimeGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleAccountedTimeGet">
                                        <pre>

sub ArticleAccountedTimeGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{ArticleID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need ArticleID!'
        );
        return;
    }

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # db query
    return if !$DBObject->Prepare(
        SQL  => 'SELECT time_unit FROM time_accounting WHERE article_id = ?',
        Bind => [ \$Param{ArticleID} ],
    );

    my $AccountedTime = 0;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        $Row[0] =~ s/,/./g;
        $AccountedTime = $AccountedTime + $Row[0];
    }

    return $AccountedTime;
}
</pre></div>

<p>returns the accounted time of a article.</p>

<pre>    my $AccountedTime = $TicketObject-&gt;ArticleAccountedTimeGet(
        ArticleID =&gt; $ArticleID,
    );
</pre><h2 id="ArticleAccountedTimeDelete">ArticleAccountedTimeDelete()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleAccountedTimeDelete');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleAccountedTimeDelete">
                                        <pre>

sub ArticleAccountedTimeDelete {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{ArticleID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need ArticleID!'
        );
        return;
    }

    # db query
    return if !$Kernel::OM->Get('Kernel::System::DB')->Do(
        SQL  => 'DELETE FROM time_accounting WHERE article_id = ?',
        Bind => [ \$Param{ArticleID} ],
    );

    return 1;
}
</pre></div>

<p>delete accounted time of article</p>

<pre>    my $Success = $TicketObject-&gt;ArticleAccountedTimeDelete(
        ArticleID =&gt; $ArticleID,
    );
</pre><h2 id="ArticleDelete">ArticleDelete()</h2>

<p>delete an article, its plain message, and all attachments</p>

<pre>    my $Success = $TicketObject-&gt;ArticleDelete(
        ArticleID =&gt; 123,
        UserID    =&gt; 123,
    );
</pre><h2 id="ArticleDeletePlain">ArticleDeletePlain()</h2>

<p>delete a plain article</p>

<pre>    my $Success = $TicketObject-&gt;ArticleDeletePlain(
        ArticleID =&gt; 123,
        UserID    =&gt; 123,
    );
</pre><h2 id="ArticleDeleteAttachment">ArticleDeleteAttachment()</h2>

<p>delete all attachments of an article</p>

<pre>    my $Success = $TicketObject-&gt;ArticleDeleteAttachment(
        ArticleID =&gt; 123,
        UserID    =&gt; 123,
    );
</pre><h2 id="ArticleWritePlain">ArticleWritePlain()</h2>

<p>write a plain email to storage</p>

<pre>    my $Success = $TicketObject-&gt;ArticleWritePlain(
        ArticleID =&gt; 123,
        Email     =&gt; $EmailAsString,
        UserID    =&gt; 123,
    );
</pre><h2 id="ArticlePlain">ArticlePlain()</h2>

<p>get plain article/email</p>

<pre>    my $PlainMessage = $TicketObject-&gt;ArticlePlain(
        ArticleID =&gt; 123,
        UserID    =&gt; 123,
    );
</pre><h2 id="ArticleWriteAttachment">ArticleWriteAttachment()</h2>

<p>write an article attachment to storage</p>

<pre>    my $Success = $TicketObject-&gt;ArticleWriteAttachment(
        Content            =&gt; $ContentAsString,
        ContentType        =&gt; 'text/html; charset=&quot;iso-8859-15&quot;',
        Filename           =&gt; 'lala.html',
        ContentID          =&gt; 'cid-1234',   # optional
        ContentAlternative =&gt; 0,            # optional, alternative content to shown as body
        Disposition        =&gt; 'attachment', # or 'inline'
        ArticleID          =&gt; 123,
        UserID             =&gt; 123,
    );
</pre><h2 id="ArticleAttachment">ArticleAttachment()</h2>

<p>get article attachment (Content, ContentType, Filename and optional ContentID, ContentAlternative)</p>

<pre>    my %Attachment = $TicketObject-&gt;ArticleAttachment(
        ArticleID =&gt; 123,
        FileID    =&gt; 1,   # as returned by ArticleAttachmentIndex
        UserID    =&gt; 123,
    );
</pre><p>returns:</p>

<pre>    my %Attachment = (
        Content            =&gt; &quot;xxxx&quot;,     # actual attachment contents
        ContentAlternative =&gt; &quot;&quot;,
        ContentID          =&gt; &quot;&quot;,
        ContentType        =&gt; &quot;application/pdf&quot;,
        Filename           =&gt; &quot;StdAttachment-Test1.pdf&quot;,
        Filesize           =&gt; &quot;4.6 KBytes&quot;,
        FilesizeRaw        =&gt; 4722,
        Disposition        =&gt; 'attachment',
    );
</pre><h2 id="ArticleAttachmentIndex">ArticleAttachmentIndex()</h2>

<p><a href="#" onclick="toggleCode('method_ArticleAttachmentIndex');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ArticleAttachmentIndex">
                                        <pre>

sub ArticleAttachmentIndex {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(ArticleID UserID)) {
        if ( !$Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    # get attachment index from backend
    my %Attachments = $Self->ArticleAttachmentIndexRaw(%Param);

    # stript plain attachments and e. g. html attachments
    if ( $Param{StripPlainBodyAsAttachment} && $Param{Article} ) {

        # plain attachment mime type vs. html attachment mime type check
        # remove plain body, rename html attachment
        my $AttachmentIDPlain = 0;
        my $AttachmentIDHTML  = 0;
        for my $AttachmentID ( sort keys %Attachments ) {
            my %File = %{ $Attachments{$AttachmentID} };

            # find plain attachment
            if (
                !$AttachmentIDPlain
                &&
                $File{Filename} eq 'file-1'
                && $File{ContentType} =~ /text\/plain/i
                )
            {
                $AttachmentIDPlain = $AttachmentID;
            }

            # find html attachment
            #  o file-[12], is plain+html attachment
            #  o file-1.html, is only html attachment
            if (
                !$AttachmentIDHTML
                &&
                ( $File{Filename} =~ /^file-[12]$/ || $File{Filename} eq 'file-1.html' )
                && $File{ContentType} =~ /text\/html/i
                )
            {
                $AttachmentIDHTML = $AttachmentID;
            }
        }
        if ($AttachmentIDHTML) {
            delete $Attachments{$AttachmentIDPlain};

            # remove any files with content-id from attachment list and listed in html body
            if ( $Param{StripPlainBodyAsAttachment} eq 1 ) {

                # get html body
                my %Attachment = $Self->ArticleAttachment(
                    ArticleID => $Param{ArticleID},
                    FileID    => $AttachmentIDHTML,
                    UserID    => $Param{UserID},
                );

                ATTACHMENT:
                for my $AttachmentID ( sort keys %Attachments ) {
                    my %File = %{ $Attachments{$AttachmentID} };
                    next ATTACHMENT if !$File{ContentID};

                    # content id cleanup
                    $File{ContentID} =~ s/^<//;
                    $File{ContentID} =~ s/>$//;
                    if (
                        $File{ContentID}
                        && $Attachment{Content} =~ /\Q$File{ContentID}\E/i
                        && $File{Disposition} eq 'inline'
                        )
                    {
                        delete $Attachments{$AttachmentID};
                    }
                }
            }

            # only strip html body attachment by "1" or "3"
            if (
                $Param{StripPlainBodyAsAttachment} eq 1
                || $Param{StripPlainBodyAsAttachment} eq 3
                )
            {
                delete $Attachments{$AttachmentIDHTML};
            }
            $Param{Article}->{AttachmentIDOfHTMLBody} = $AttachmentIDHTML;
        }

        # plain body size vs. attched body size check
        # and remove attachment if it's email body
        if ( !$AttachmentIDHTML ) {
            my $AttachmentIDPlain = 0;
            my %AttachmentFilePlain;
            ATTACHMENT_ID:
            for my $AttachmentID ( sort keys %Attachments ) {
                my %File = %{ $Attachments{$AttachmentID} };

                # remember, file-1 got defined by parsing if no filename was given
                if (
                    $File{Filename} eq 'file-1'
                    && $File{ContentType} =~ /text\/plain/i
                    )
                {
                    $AttachmentIDPlain   = $AttachmentID;
                    %AttachmentFilePlain = %File;
                    last ATTACHMENT_ID;
                }
            }

            # plain attachment detected and remove it from attachment index
            if (%AttachmentFilePlain) {

                # check body size vs. attachment size to be sure
                my $BodySize = bytes::length( $Param{Article}->{Body} );

                # check size by tolerance of 1.1 factor (because of charset difs)
                if (
                    $BodySize / 1.1 < $AttachmentFilePlain{FilesizeRaw}
                    && $BodySize * 1.1 > $AttachmentFilePlain{FilesizeRaw}
                    )
                {
                    delete $Attachments{$AttachmentIDPlain};
                }
            }
        }
    }

    return %Attachments;
}
</pre></div>

<p>get article attachment index as hash</p>

<pre> (ID =&gt; hashref (Filename, Filesize, ContentID (if exists), ContentAlternative(if exists) ))

    my %Index = $TicketObject-&gt;ArticleAttachmentIndex(
        ArticleID =&gt; 123,
        UserID    =&gt; 123,
    );
</pre><p>or with &quot;StripPlainBodyAsAttachment =&gt; 1&quot; feature to not include first
attachment (not include text body, html body as attachment and inline attachments)</p>

<pre>    my %Index = $TicketObject-&gt;ArticleAttachmentIndex(
        ArticleID                  =&gt; 123,
        UserID                     =&gt; 123,
        Article                    =&gt; \%Article,
        StripPlainBodyAsAttachment =&gt; 1,
    );
</pre><p>or with &quot;StripPlainBodyAsAttachment =&gt; 2&quot; feature to not include first
attachment (not include text body as attachment)</p>

<pre>    my %Index = $TicketObject-&gt;ArticleAttachmentIndex(
        ArticleID                  =&gt; 123,
        UserID                     =&gt; 123,
        Article                    =&gt; \%Article,
        StripPlainBodyAsAttachment =&gt; 2,
    );
</pre><p>or with &quot;StripPlainBodyAsAttachment =&gt; 3&quot; feature to not include first
attachment (not include text body and html body as attachment)</p>

<pre>    my %Index = $TicketObject-&gt;ArticleAttachmentIndex(
        ArticleID                  =&gt; 123,
        UserID                     =&gt; 123,
        Article                    =&gt; \%Article,
        StripPlainBodyAsAttachment =&gt; 3,
    );
</pre><p>returns:</p>

<pre>    my %Index = {
        '1' =&gt; {
            ContentAlternative =&gt; '',
            ContentID          =&gt; '',
            Filesize           =&gt; '4.6 KBytes',
            ContentType        =&gt; 'application/pdf',
            Filename           =&gt; 'StdAttachment-Test1.pdf',
            FilesizeRaw        =&gt; 4722,
            Disposition        =&gt; attachment,
        },
        '2' =&gt; {
            ContentAlternative =&gt; '',
            ContentID          =&gt; '',
            Filesize           =&gt; '183 Bytes',
            ContentType        =&gt; 'text/html; charset=&quot;utf-8&quot;',
            Filename           =&gt; 'file-2',
            FilesizeRaw        =&gt; 183,
            Disposition        =&gt; attachment,
        },
    };
</pre><h1 id="TERMS_AND_CONDITIONS">TERMS AND CONDITIONS <a href="#TOP" class="toplink"><img alt="^" src="../../../up.gif" /></a></h1>

<p>This software is part of the OTRS project (<a href="http://otrs.org/">http://otrs.org/</a>).</p>

<p>This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see <a href="http://www.gnu.org/licenses/agpl.txt">http://www.gnu.org/licenses/agpl.txt</a>.</p>


</div><div class="footer">generated by <a href="http://search.cpan.org/perldoc?Pod%3A%3AProjectDocs">Pod::ProjectDocs</a></div></body>
</html>
