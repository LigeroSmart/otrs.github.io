<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<!-- otrs.github.io -->
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../../../../../../documentation.css">
<script src="https://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../../../../../documentation.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
<script>
$(document).ready(function() {
    // programlistings in manuals
    $('pre.programlisting').each(function(i, block) {
        hljs.highlightBlock(block);
    });
    // code snippets in Perl API docs
    $('.pod pre').addClass('perl').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});</script>
<!-- otrs.github.io -->

	<title>Kernel::System::DateTime</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <script type="text/javascript">

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  </script></head>
<body>
<div class="box">
  <h1 class="t1">OTRS 6.0 API Reference Perl</h1>
  <table>
    <tr>
      <td class="label">Description</td>
      <td class="cell">manuals and libraries</td>
    </tr>
  </table>
</div>
<div class="path">
  <a href="../../index.html">OTRS 6.0 API Reference Perl</a> &gt; Perl Modules &gt;
  Kernel::System::DateTime
</div>
<div>
<a href="../../src/Kernel/System/DateTime.pm">Source</a>
</div>


<div class="pod">
<!-- INDEX START -->
<h3 id="TOP">Index</h3>
<ul>
	<li><a href="#NAME">NAME</a></li>
	<li><a href="#SYNOPSIS">SYNOPSIS</a></li>
	<li><a href="#PUBLIC_INTERFACE">PUBLIC INTERFACE</a><br />
<ul>
	<li><a href="#new">new()</a></li>
	<li><a href="#Get">Get()</a></li>
	<li><a href="#Set">Set()</a></li>
	<li><a href="#Add">Add()</a></li>
	<li><a href="#Subtract">Subtract()</a></li>
	<li><a href="#Delta">Delta()</a></li>
	<li><a href="#Compare">Compare()</a></li>
	<li><a href="#ToTimeZone">ToTimeZone()</a></li>
	<li><a href="#ToOTRSTimeZone">ToOTRSTimeZone()</a></li>
	<li><a href="#Validate">Validate()</a></li>
	<li><a href="#Format">Format()</a></li>
	<li><a href="#ToEpoch">ToEpoch()</a></li>
	<li><a href="#ToString">ToString()</a></li>
	<li><a href="#ToEmailTimeStamp">ToEmailTimeStamp()</a></li>
	<li><a href="#ToCTimeString">ToCTimeString()</a></li>
	<li><a href="#IsVacationDay">IsVacationDay()</a></li>
	<li><a href="#LastDayOfMonthGet">LastDayOfMonthGet()</a></li>
	<li><a href="#Clone">Clone()</a></li>
	<li><a href="#TimeZoneList">TimeZoneList()</a></li>
	<li><a href="#TimeZoneByOffsetList">TimeZoneByOffsetList()</a></li>
	<li><a href="#IsTimeZoneValid">IsTimeZoneValid()</a></li>
	<li><a href="#OTRSTimeZoneGet">OTRSTimeZoneGet()</a></li>
	<li><a href="#UserDefaultTimeZoneGet">UserDefaultTimeZoneGet()</a></li>
	<li><a href="#SystemTimeZoneGet">SystemTimeZoneGet()</a></li>
</ul>
</li>
	<li><a href="#TERMS_AND_CONDITIONS">TERMS AND CONDITIONS</a></li>
</ul>
<hr />
<!-- INDEX END -->

<h1 id="NAME">NAME <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<p>Kernel::System::DateTime - Handles date and time calculations.</p>

<h1 id="SYNOPSIS">SYNOPSIS <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<p>Handles date and time calculations.</p>

<h1 id="PUBLIC_INTERFACE">PUBLIC INTERFACE <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>




<h2 id="new">new()</h2>

<p><a href="#" onclick="toggleCode('method_new');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_new">
                                        <pre>

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # CPAN DateTime:
    # Only use English descriptions and abbreviations internally.
    # This has nothing to do with the user's locale settings in OTRS.
    $Self->{Locale} = 'en_US';

    # create CPAN/Perl DateTime object
    my $CPANDateTimeObject = $Self->_CPANDateTimeObjectCreate(%Param);
    if ( !$CPANDateTimeObject ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            'Priority' => 'Error',
            'Message'  => 'Error creating DateTime object.',
        );

        return;
    }

    $Self->{CPANDateTimeObject} = $CPANDateTimeObject;

    return $Self;
}
</pre></div>

<p>Creates a DateTime object. Do not use new() directly, instead use the object manager:</p>

<pre>    use Kernel::System::ObjectManager;
    local $Kernel::OM = Kernel::System::ObjectManager-&gt;new();

    # Create an object with current date and time
    # within time zone set in SysConfig OTRSTimeZone:
    my $DateTimeObject = $Kernel::OM-&gt;Create(
        'Kernel::System::DateTime'
    );

    # Create an object with current date and time
    # within a certain time zone:
    my $DateTimeObject = $Kernel::OM-&gt;Create(
        'Kernel::System::DateTime',
        ObjectParams =&gt; {
            TimeZone =&gt; 'Europe/Berlin',        # optional
        }
    );

    # Create an object with a specific date and time:
    my $DateTimeObject = $Kernel::OM-&gt;Create(
        'Kernel::System::DateTime',
        ObjectParams =&gt; {
            Year     =&gt; 2016,
            Month    =&gt; 1,
            Day      =&gt; 22,
            Hour     =&gt; 12,                     # optional, defaults to 0
            Minute   =&gt; 35,                     # optional, defaults to 0
            Second   =&gt; 59,                     # optional, defaults to 0
            TimeZone =&gt; 'Europe/Berlin',        # optional, defaults to setting of SysConfig OTRSTimeZone
        }
    );

    # Create an object from an epoch timestamp. These timestamps are always UTC/GMT,
    # hence time zone will automatically be set to UTC.
    #
    # If parameter Epoch is present, all other parameters will be ignored.
    my $DateTimeObject = $Kernel::OM-&gt;Create(
        'Kernel::System::DateTime',
        ObjectParams =&gt; {
            Epoch =&gt; 1453911685,
        }
    );

    # Create an object from a date/time string.
    #
    # If parameter String is given, Year, Month, Day, Hour, Minute and Second will be ignored
    my $DateTimeObject = $Kernel::OM-&gt;Create(
        'Kernel::System::DateTime',
        ObjectParams =&gt; {
            String   =&gt; '2016-08-14 22:45:00',
            TimeZone =&gt; 'Europe/Berlin',        # optional, defaults to setting of SysConfig OTRSTimeZone
        }
    );

</pre><h2 id="Get">Get()</h2>

<p><a href="#" onclick="toggleCode('method_Get');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Get">
                                        <pre>

sub Get {
    my ( $Self, %Param ) = @_;

    my $Values = {
        Year      => $Self->{CPANDateTimeObject}->year(),
        Month     => $Self->{CPANDateTimeObject}->month(),
        MonthAbbr => $Self->{CPANDateTimeObject}->month_abbr(),
        Day       => $Self->{CPANDateTimeObject}->day(),
        Hour      => $Self->{CPANDateTimeObject}->hour(),
        Minute    => $Self->{CPANDateTimeObject}->minute(),
        Second    => $Self->{CPANDateTimeObject}->second(),
        DayOfWeek => $Self->{CPANDateTimeObject}->day_of_week(),
        DayAbbr   => $Self->{CPANDateTimeObject}->day_abbr(),
        TimeZone  => $Self->{CPANDateTimeObject}->time_zone_long_name(),
    };

    return $Values;
}
</pre></div>

<p>Returns hash ref with the date, time and time zone values of this object.</p>

<pre>    my $DateTimeSettings = $DateTimeObject-&gt;Get();

</pre><p>Returns:</p>

<pre>    my $DateTimeSettings = {
        Year      =&gt; 2016,
        Month     =&gt; 1,         # starting at 1
        Day       =&gt; 22,
        Hour      =&gt; 16,
        Minute    =&gt; 35,
        Second    =&gt; 59,
        DayOfWeek =&gt; 5,         # starting with 1 for Monday, ending with 7 for Sunday
        TimeZone  =&gt; 'Europe/Berlin',
    };

</pre><h2 id="Set">Set()</h2>

<p><a href="#" onclick="toggleCode('method_Set');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Set">
                                        <pre>

sub Set {
    my ( $Self, %Param ) = @_;

    if ( defined $Param{String} ) {
        my $DateTimeHash = $Self->_StringToHash( String => $Param{String} );
        return if !$DateTimeHash;

        %Param = %{$DateTimeHash};
    }

    my @DateTimeParams = qw ( Year Month Day Hour Minute Second );

    # Check given parameters
    my $ParamGiven;
    DATETIMEPARAM:
    for my $DateTimeParam (@DateTimeParams) {
        next DATETIMEPARAM if !defined $Param{$DateTimeParam};

        $ParamGiven = 1;
        last DATETIMEPARAM;
    }

    if ( !$ParamGiven ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            'Priority' => 'Error',
            'Message'  => 'Missing at least one parameter.',
        );
        return;
    }

    # Validate given values by using the current settings + the given ones.
    my $CurrentValues = $Self->Get();
    DATETIMEPARAM:
    for my $DateTimeParam (@DateTimeParams) {
        next DATETIMEPARAM if !defined $Param{$DateTimeParam};

        $CurrentValues->{$DateTimeParam} = $Param{$DateTimeParam};
    }

    # Create a new DateTime object with the new/added values
    my $CPANDateTimeParams = $Self->_ToCPANDateTimeParamNames( %{$CurrentValues} );

    # Delete parameters that are not allowed for set method
    delete $CPANDateTimeParams->{time_zone};

    my $Result;
    eval {
        $Result = $Self->{CPANDateTimeObject}->set( %{$CPANDateTimeParams} );
    };

    return $Result;
}
</pre></div>

<p>Sets date and time values of this object.
You have to give at least one parameter.
Only given values will be changed.
Note that the resulting date and time have to be valid.
On validation error, the current date and time of the object won't be changed.</p>

<p>Note that for changing the time zone, you have to use method ToTimeZone.</p>

<pre>    # Setting values by hash:
    my $Success = $DateTimeObject-&gt;Set(
        Year     =&gt; 2016,
        Month    =&gt; 1,
        Day      =&gt; 22,
        Hour     =&gt; 16,
        Minute   =&gt; 35,
        Second   =&gt; 59,
    );

    # Settings values by date/time string:
    # If parameter String is present, all other parameters will be ignored.
    my $Success = $DateTimeObject-&gt;Set( String =&gt; '2016-02-25 20:34:01' );

</pre><p>Returns:</p>

<pre>   $Success = 1;    # On success, or false otherwise.

</pre><h2 id="Add">Add()</h2>

<p><a href="#" onclick="toggleCode('method_Add');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Add">
                                        <pre>

sub Add {
    my ( $Self, %Param ) = @_;

    #
    # Check parameters
    #
    my @DateTimeParams = qw ( Years Months Weeks Days Hours Minutes Seconds );
    @DateTimeParams = qw( Days Hours Minutes Seconds ) if $Param{AsWorkingTime};

    # Check for needed parameters
    my $ParamsGiven = 0;
    my $ParamsValid = 1;
    DATETIMEPARAM:
    for my $DateTimeParam (@DateTimeParams) {
        next DATETIMEPARAM if !defined $Param{$DateTimeParam};

        if ( !looks_like_number( $Param{$DateTimeParam} ) ) {
            $ParamsValid = 0;
            last DATETIMEPARAM;
        }

        # negative values are not allowed when calculating working time
        if ( int $Param{$DateTimeParam} < 0 && $Param{AsWorkingTime} ) {
            $ParamsValid = 0;
            last DATETIMEPARAM;
        }

        $ParamsGiven = 1;
    }

    if ( !$ParamsGiven || !$ParamsValid ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            'Priority' => 'Error',
            'Message'  => 'Missing or invalid date/time parameter(s).',
        );
        return;
    }

    # Check for not allowed parameters
    my %AllowedParams = map { $_ => 1 } @DateTimeParams;
    $AllowedParams{AsWorkingTime} = 1;
    if ( $Param{AsWorkingTime} ) {
        $AllowedParams{Calendar} = 1;
    }

    for my $Param ( sort keys %Param ) {
        if ( !$AllowedParams{$Param} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                'Priority' => 'Error',
                'Message'  => "Parameter $Param is not allowed.",
            );
            return;
        }
    }

    # NOTE: For performance reasons, the following code for calculating date and time
    # works directly with the CPAN DateTime object instead of methods of Kernel::System::DateTime.

    #
    # Working time calculation
    #
    if ( $Param{AsWorkingTime} ) {

        # Combine time parameters to seconds
        my $RemainingSeconds = 0;
        if ( defined $Param{Seconds} ) {
            $RemainingSeconds += int $Param{Seconds};
        }
        if ( defined $Param{Minutes} ) {
            $RemainingSeconds += int $Param{Minutes} * 60;
        }
        if ( defined $Param{Hours} ) {
            $RemainingSeconds += int $Param{Hours} * 60 * 60;
        }
        if ( defined $Param{Days} ) {
            $RemainingSeconds += int $Param{Days} * 60 * 60 * 24;
        }

        return if !$RemainingSeconds;

        # Backup current date/time to be able to revert to it in case of failure
        my $OriginalDateTimeObject = $Self->{CPANDateTimeObject}->clone();

        my $TimeZone = $OriginalDateTimeObject->time_zone();

        # Get working and vacation times, use calendar if given
        my $ConfigObject            = $Kernel::OM->Get('Kernel::Config');
        my $TimeWorkingHours        = $ConfigObject->Get('TimeWorkingHours');
        my $TimeVacationDays        = $ConfigObject->Get('TimeVacationDays');
        my $TimeVacationDaysOneTime = $ConfigObject->Get('TimeVacationDaysOneTime');
        if (
            $Param{Calendar}
            && $ConfigObject->Get( "TimeZone::Calendar" . $Param{Calendar} . "Name" )
            )
        {
            $TimeWorkingHours        = $ConfigObject->Get( "TimeWorkingHours::Calendar" . $Param{Calendar} );
            $TimeVacationDays        = $ConfigObject->Get( "TimeVacationDays::Calendar" . $Param{Calendar} );
            $TimeVacationDaysOneTime = $ConfigObject->Get(
                "TimeVacationDaysOneTime::Calendar" . $Param{Calendar}
            );

            # Switch to time zone of calendar
            $TimeZone = $ConfigObject->Get( "TimeZone::Calendar" . $Param{Calendar} )
                || $Self->OTRSTimeZoneGet();

            # Use Kernel::System::DateTime's ToTimeZone() here because of error handling
            # and because performance is irrelevant at this point.
            if ( !$Self->ToTimeZone( TimeZone => $TimeZone ) ) {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message  => "Error setting time zone $TimeZone.",
                );

                return;
            }
        }

        # If there are for some reason no working hours configured, stop here
        # to prevent failing via loop protection below.
        my $WorkingHoursConfigured;
        WORKINGHOURCONFIGDAY:
        for my $WorkingHourConfigDay ( sort keys %{$TimeWorkingHours} ) {
            if ( IsArrayRefWithData( $TimeWorkingHours->{$WorkingHourConfigDay} ) ) {
                $WorkingHoursConfigured = 1;
                last WORKINGHOURCONFIGDAY;
            }
        }
        return 1 if !$WorkingHoursConfigured;

        # Convert $TimeWorkingHours into Hash
        my %TimeWorkingHours;
        for my $DayName ( sort keys %{$TimeWorkingHours} ) {
            $TimeWorkingHours{$DayName} = { map { $_ => 1 } @{ $TimeWorkingHours->{$DayName} } };
        }

        # Protection for endless loop
        my $LoopStartTime = time();
        LOOP:
        while ( $RemainingSeconds > 0 ) {

            # Fail if this loop takes longer than 5 seconds
            if ( time() - $LoopStartTime > 5 ) {

                # Reset this object to original date/time.
                $Self->{CPANDateTimeObject} = $OriginalDateTimeObject->clone();

                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message  => 'Adding working time took too long, aborting.',
                );

                return;
            }

            my $Year    = $Self->{CPANDateTimeObject}->year();
            my $Month   = $Self->{CPANDateTimeObject}->month();
            my $Day     = $Self->{CPANDateTimeObject}->day();
            my $DayName = $Self->{CPANDateTimeObject}->day_abbr();
            my $Hour    = $Self->{CPANDateTimeObject}->hour();
            my $Minute  = $Self->{CPANDateTimeObject}->minute();
            my $Second  = $Self->{CPANDateTimeObject}->second();

            # Check working times and vacation days
            my $IsWorkingDay = !$TimeVacationDays->{$Month}->{$Day}
                && !$TimeVacationDaysOneTime->{$Year}->{$Month}->{$Day}
                && exists $TimeWorkingHours->{$DayName}
                && keys %{ $TimeWorkingHours{$DayName} };

            # On start of day check if whole day can be processed in one chunk
            # instead of hour by hour (performance reasons).
            if ( !$Hour && !$Minute && !$Second ) {

                # The following code is slightly faster than using CPAN DateTime's add(),
                # presumably because add() always creates a DateTime::Duration object.
                my $Epoch = $Self->{CPANDateTimeObject}->epoch();
                $Epoch += 60 * 60 * 24;

                my $NextDayDateTimeObject = DateTime->from_epoch(
                    epoch     => $Epoch,
                    time_zone => $TimeZone,
                    locale    => $Self->{Locale},
                );

                # Only handle days with exactly 24 hours here
                if (
                    !$NextDayDateTimeObject->hour()
                    && !$NextDayDateTimeObject->minute()
                    && !$NextDayDateTimeObject->second()
                    && $NextDayDateTimeObject->day() != $Day
                    )
                {
                    my $FullDayProcessed = 1;

                    if ($IsWorkingDay) {
                        my $WorkingHours   = keys %{ $TimeWorkingHours{$DayName} };
                        my $WorkingSeconds = $WorkingHours * 60 * 60;

                        if ( $RemainingSeconds > $WorkingSeconds ) {
                            $RemainingSeconds -= $WorkingSeconds;
                        }
                        else {
                            $FullDayProcessed = 0;
                        }
                    }

                    # Move forward 24 hours if full day has been processed
                    if ($FullDayProcessed) {

                        # Time implicitly set to 0
                        $Self->{CPANDateTimeObject}->set(
                            year  => $NextDayDateTimeObject->year(),
                            month => $NextDayDateTimeObject->month(),
                            day   => $NextDayDateTimeObject->day(),
                        );

                        next LOOP;
                    }
                }
            }

            # Calculate remaining seconds of the current hour
            my $SecondsOfCurrentHour = ( $Minute * 60 ) + $Second;
            my $SecondsToAdd         = ( 60 * 60 ) - $SecondsOfCurrentHour;

            if ( $IsWorkingDay && $TimeWorkingHours{$DayName}->{$Hour} ) {
                $SecondsToAdd = $RemainingSeconds if $SecondsToAdd > $RemainingSeconds;
                $RemainingSeconds -= $SecondsToAdd;
            }

            # The following code is slightly faster than using CPAN DateTime's add(),
            # presumably because add() always creates a DateTime::Duration object.
            my $Epoch = $Self->{CPANDateTimeObject}->epoch();
            $Epoch += $SecondsToAdd;

            $Self->{CPANDateTimeObject} = DateTime->from_epoch(
                epoch     => $Epoch,
                time_zone => $TimeZone,
                locale    => $Self->{Locale},
            );
        }

        # Return to original time zone, might have been changed by calendar
        $Self->{CPANDateTimeObject}->set_time_zone( $OriginalDateTimeObject->time_zone() );

        return 1;
    }

    #
    # "Normal" date/time calculation
    #

    # Calculations are only made in UTC/floating time zone to prevent errors with times that
    # would not exist in the given time zone (e. g. on/around daylight saving time switch).
    # CPAN DateTime fails if adding days, months or years which would result in a non-existing
    # time in the given time zone. Converting it to UTC and back has the desired effect.
    #
    # Also see http://stackoverflow.com/questions/18489927/a-day-without-midnight
    my $TimeZone = $Self->{CPANDateTimeObject}->time_zone();
    $Self->{CPANDateTimeObject}->set_time_zone('UTC');

    # Convert to floating time zone to get rid of leap seconds which can lead to times like 23:59:61
    $Self->{CPANDateTimeObject}->set_time_zone('floating');

    # Add duration
    my $DurationParameters = $Self->_ToCPANDateTimeParamNames(%Param);
    eval {
        $Self->{CPANDateTimeObject}->add( %{$DurationParameters} );
    };

    # Store possible error before it might get lost by call to ToTimeZone
    my $Error = $@;

    # First convert floating time zone back to UTC and from there to the original time zone
    $Self->{CPANDateTimeObject}->set_time_zone('UTC');
    $Self->{CPANDateTimeObject}->set_time_zone($TimeZone);

    return if $Error;

    return 1;
}
</pre></div>

<p>Adds duration or working time to date and time of this object.
You have to give at least one of the valid parameters.
On error, the current date and time of this object won't be changed.</p>

<pre>    my $Success = $DateTimeObject-&gt;Add(
        Years         =&gt; 1,
        Months        =&gt; 2,
        Weeks         =&gt; 4,
        Days          =&gt; 34,
        Hours         =&gt; 2,
        Minutes       =&gt; 5,
        Seconds       =&gt; 459,

        # Calculate &quot;destination date&quot; by adding given time values as
        # working time. Note that for adding working time,
        # only parameters Seconds, Minutes, Hours and Days are allowed.
        AsWorkingTime =&gt; 0, # set to 1 to add given values as working time

        # Calendar to use for working time calculations, optional
        Calendar =&gt; 9,
    );

</pre><p>Returns:</p>

<pre>    $Success = 1;    # On success, or false otherwise.

</pre><h2 id="Subtract">Subtract()</h2>

<p><a href="#" onclick="toggleCode('method_Subtract');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Subtract">
                                        <pre>

sub Subtract {
    my ( $Self, %Param ) = @_;

    my @DateTimeParams = qw ( Years Months Weeks Days Hours Minutes Seconds );

    # Check for needed parameters
    my $ParamsGiven = 0;
    my $ParamsValid = 1;
    DATETIMEPARAM:
    for my $DateTimeParam (@DateTimeParams) {
        next DATETIMEPARAM if !defined $Param{$DateTimeParam};

        if ( !looks_like_number( $Param{$DateTimeParam} ) ) {
            $ParamsValid = 0;
            last DATETIMEPARAM;
        }

        # negative values are not allowed when calculating working time
        if ( int $Param{$DateTimeParam} < 0 && $Param{AsWorkingTime} ) {
            $ParamsValid = 0;
            last DATETIMEPARAM;
        }

        $ParamsGiven = 1;
    }

    if ( !$ParamsGiven || !$ParamsValid ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            'Priority' => 'Error',
            'Message'  => 'Missing or invalid date/time parameter(s).',
        );
        return;
    }

    # Check for not allowed parameters
    my %AllowedParams = map { $_ => 1 } @DateTimeParams;
    $AllowedParams{AsWorkingTime} = 1;
    if ( $Param{AsWorkingTime} ) {
        $AllowedParams{Calendar} = 1;
    }

    for my $Param ( sort keys %Param ) {
        if ( !$AllowedParams{$Param} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                'Priority' => 'Error',
                'Message'  => "Parameter $Param is not allowed.",
            );
            return;
        }
    }

    # Calculations are only made in UTC/floating time zone to prevent errors with times that
    # would not exist in the given time zone (e. g. on/around daylight saving time switch).
    my $DateTimeValues = $Self->Get();
    $Self->ToTimeZone( TimeZone => 'UTC' );

    # Convert to floating time zone to get rid of leap seconds which can lead to times like 23:59:61
    $Self->{CPANDateTimeObject}->set_time_zone('floating');

    # Subtract duration
    my $DurationParameters = $Self->_ToCPANDateTimeParamNames(%Param);
    eval {
        $Self->{CPANDateTimeObject}->subtract( %{$DurationParameters} );
    };

    # Store possible error before it might get lost by call to ToTimeZone
    my $Error = $@;

    # First convert floating time zone back to UTC and from there to the original time zone
    $Self->{CPANDateTimeObject}->set_time_zone('UTC');
    $Self->ToTimeZone( TimeZone => $DateTimeValues->{TimeZone} );

    return if $@;

    return 1;
}
</pre></div>

<p>Subtracts duration from date and time of this object.
You have to give at least one of the valid parameters.
On validation error, the current date and time of this object won't be changed.</p>

<pre>    my $Success = $DateTimeObject-&gt;Subtract(
        Years     =&gt; 1,
        Months    =&gt; 2,
        Weeks     =&gt; 4,
        Days      =&gt; 34,
        Hours     =&gt; 2,
        Minutes   =&gt; 5,
        Seconds   =&gt; 459,
    );

</pre><p>Returns:</p>

<pre>    $Success =  1;  # On success, or false otherwise.

</pre><h2 id="Delta">Delta()</h2>

<p><a href="#" onclick="toggleCode('method_Delta');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Delta">
                                        <pre>

sub Delta {
    my ( $Self, %Param ) = @_;

    #
    # check required params
    #
    if (
        !defined $Param{DateTimeObject}
        || ref $Param{DateTimeObject} ne ref $Self
        )
    {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            'Priority' => 'Error',
            'Message'  => "Missing or invalid parameter DateTimeObject.",
        );
        return;
    }

    my $Delta = {
        Years           => 0,
        Months          => 0,
        Weeks           => 0,
        Days            => 0,
        Hours           => 0,
        Minutes         => 0,
        Seconds         => 0,
        AbsoluteSeconds => 0,
    };

    #
    # Calculate delta for working time
    #
    if ( $Param{ForWorkingTime} ) {

        # NOTE: For performance reasons, the following code for calculating the working time
        # works directly with the CPAN DateTime object instead of Kernel::System::DateTime.

        # Clone StartDateTime object because it will be changed while calculating
        # but the original object must not be changed.
        my $StartDateTimeObject = $Self->{CPANDateTimeObject}->clone();
        my $TimeZone            = $StartDateTimeObject->time_zone();

        # Get working and vacation times, use calendar if given
        my $ConfigObject            = $Kernel::OM->Get('Kernel::Config');
        my $TimeWorkingHours        = $ConfigObject->Get('TimeWorkingHours');
        my $TimeVacationDays        = $ConfigObject->Get('TimeVacationDays');
        my $TimeVacationDaysOneTime = $ConfigObject->Get('TimeVacationDaysOneTime');
        if (
            $Param{Calendar}
            && $ConfigObject->Get( "TimeZone::Calendar" . $Param{Calendar} . "Name" )
            )
        {
            $TimeWorkingHours        = $ConfigObject->Get( "TimeWorkingHours::Calendar" . $Param{Calendar} );
            $TimeVacationDays        = $ConfigObject->Get( "TimeVacationDays::Calendar" . $Param{Calendar} );
            $TimeVacationDaysOneTime = $ConfigObject->Get(
                "TimeVacationDaysOneTime::Calendar" . $Param{Calendar}
            );

            # switch to time zone of calendar
            $TimeZone = $ConfigObject->Get( "TimeZone::Calendar" . $Param{Calendar} )
                || $Self->OTRSTimeZoneGet();

            eval {
                $StartDateTimeObject->set_time_zone($TimeZone);
            };

            if ($@) {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message  => "Error setting time zone $TimeZone for start DateTime object.",
                );

                return;
            }
        }

        # If there are for some reason no working hours configured, stop here
        # to prevent failing via loop protection below.
        my $WorkingHoursConfigured;
        WORKINGHOURCONFIGDAY:
        for my $WorkingHourConfigDay ( sort keys %{$TimeWorkingHours} ) {
            if ( IsArrayRefWithData( $TimeWorkingHours->{$WorkingHourConfigDay} ) ) {
                $WorkingHoursConfigured = 1;
                last WORKINGHOURCONFIGDAY;
            }
        }
        return $Delta if !$WorkingHoursConfigured;

        # Convert $TimeWorkingHours into Hash
        my %TimeWorkingHours;
        for my $DayName ( sort keys %{$TimeWorkingHours} ) {
            $TimeWorkingHours{$DayName} = { map { $_ => 1 } @{ $TimeWorkingHours->{$DayName} } };
        }

        my $StartTime   = $StartDateTimeObject->epoch();
        my $StopTime    = $Param{DateTimeObject}->{CPANDateTimeObject}->epoch();
        my $WorkingTime = 0;

        # Protection for endless loop
        my $LoopStartTime = time();
        LOOP:
        while ( $StartTime < $StopTime ) {

            # Fail if this loop takes longer than 5 seconds
            if ( time() - $LoopStartTime > 5 ) {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message  => 'Delta calculation of working time took too long, aborting.',
                );

                return;
            }

            my $RemainingSeconds = $StopTime - $StartTime;

            my $Year    = $StartDateTimeObject->year();
            my $Month   = $StartDateTimeObject->month();
            my $Day     = $StartDateTimeObject->day();
            my $DayName = $StartDateTimeObject->day_abbr();
            my $Hour    = $StartDateTimeObject->hour();
            my $Minute  = $StartDateTimeObject->minute();
            my $Second  = $StartDateTimeObject->second();

            # Check working times and vacation days
            my $IsWorkingDay = !$TimeVacationDays->{$Month}->{$Day}
                && !$TimeVacationDaysOneTime->{$Year}->{$Month}->{$Day}
                && exists $TimeWorkingHours->{$DayName}
                && keys %{ $TimeWorkingHours{$DayName} };

            # On start of day check if whole day can be processed in one chunk
            # instead of hour by hour (performance reasons).
            if ( !$Hour && !$Minute && !$Second ) {

                # The following code is slightly faster than using CPAN DateTime's add(),
                # presumably because add() always creates a DateTime::Duration object.
                my $Epoch = $StartDateTimeObject->epoch();
                $Epoch += 60 * 60 * 24;

                my $NextDayDateTimeObject = DateTime->from_epoch(
                    epoch     => $Epoch,
                    time_zone => $TimeZone,
                    locale    => $Self->{Locale},
                );

                # Only handle days with exactly 24 hours here
                if (
                    !$NextDayDateTimeObject->hour()
                    && !$NextDayDateTimeObject->minute()
                    && !$NextDayDateTimeObject->second()
                    && $NextDayDateTimeObject->day() != $Day
                    && $RemainingSeconds > 60 * 60 * 24
                    )
                {
                    my $FullDayProcessed = 1;

                    if ($IsWorkingDay) {
                        my $WorkingHours   = keys %{ $TimeWorkingHours{$DayName} };
                        my $WorkingSeconds = $WorkingHours * 60 * 60;

                        if ( $RemainingSeconds > $WorkingSeconds ) {
                            $WorkingTime += $WorkingSeconds;
                        }
                        else {
                            $FullDayProcessed = 0;
                        }
                    }

                    # Move forward 24 hours if full day has been processed
                    if ($FullDayProcessed) {

                        # Time implicitly set to 0
                        $StartDateTimeObject->set(
                            year  => $NextDayDateTimeObject->year(),
                            month => $NextDayDateTimeObject->month(),
                            day   => $NextDayDateTimeObject->day(),
                        );

                        $StartTime = $Epoch;

                        next LOOP;
                    }
                }
            }

            # Calculate remaining seconds of the current hour
            my $SecondsOfCurrentHour = ( $Minute * 60 ) + $Second;
            my $SecondsToAdd         = ( 60 * 60 ) - $SecondsOfCurrentHour;

            if ( $IsWorkingDay && $TimeWorkingHours{$DayName}->{$Hour} ) {
                $SecondsToAdd = $RemainingSeconds if $SecondsToAdd > $RemainingSeconds;
                $WorkingTime += $SecondsToAdd;
            }

            # The following code is slightly faster than using CPAN DateTime's add(),
            # presumably because add() always creates a DateTime::Duration object.
            my $Epoch = $StartDateTimeObject->epoch();
            $Epoch += $SecondsToAdd;

            $StartDateTimeObject = DateTime->from_epoch(
                epoch     => $Epoch,
                time_zone => $TimeZone,
                locale    => $Self->{Locale},
            );

            $StartTime = $Epoch;
        }

        # Set values for delta
        my $RemainingWorkingTime = $WorkingTime;

        $Delta->{Hours} = int $RemainingWorkingTime / ( 60 * 60 );
        $RemainingWorkingTime -= $Delta->{Hours} * 60 * 60;

        $Delta->{Minutes} = int $RemainingWorkingTime / 60;
        $RemainingWorkingTime -= $Delta->{Minutes} * 60;

        $Delta->{Seconds} = $RemainingWorkingTime;
        $RemainingWorkingTime = 0;

        $Delta->{AbsoluteSeconds} = $WorkingTime;

        return $Delta;
    }

    #
    # Calculate delta for "normal" date/time
    #
    my $DeltaDuration = $Self->{CPANDateTimeObject}->subtract_datetime(
        $Param{DateTimeObject}->{CPANDateTimeObject}
    );

    $Delta->{Years}   = $DeltaDuration->years();
    $Delta->{Months}  = $DeltaDuration->months();
    $Delta->{Weeks}   = $DeltaDuration->weeks();
    $Delta->{Days}    = $DeltaDuration->days();
    $Delta->{Hours}   = $DeltaDuration->hours();
    $Delta->{Minutes} = $DeltaDuration->minutes();
    $Delta->{Seconds} = $DeltaDuration->seconds();

    # Absolute seconds
    $DeltaDuration = $Self->{CPANDateTimeObject}->subtract_datetime_absolute(
        $Param{DateTimeObject}->{CPANDateTimeObject}
    );

    $Delta->{AbsoluteSeconds} = $DeltaDuration->seconds();

    return $Delta;
}
</pre></div>

<p>Calculates delta between this and another DateTime object. Optionally calculates the working
time between the two.</p>

<pre>    my $Delta = $DateTimeObject-&gt;Delta( DateTimeObject =&gt; $AnotherDateTimeObject );

    Note that the returned values are always positive. Use the comparison methods
    to see if a date is newer/older/equal.

    # Calculate &quot;working time&quot;
    ForWorkingTime =&gt; 0, # set to 1 to calculate working time between the two DateTime objects

    # Calendar to use for working time calculations, optional
    Calendar =&gt; 9,




</pre><p>Returns:</p>

<pre>    my $Delta = {
        Years           =&gt; 1,           # Set to 0 if working time was calculated
        Months          =&gt; 2,           # Set to 0 if working time was calculated
        Weeks           =&gt; 4,           # Set to 0 if working time was calculated
        Days            =&gt; 34,          # Set to 0 if working time was calculated
        Hours           =&gt; 2,
        Minutes         =&gt; 5,
        Seconds         =&gt; 459,
        AbsoluteSeconds =&gt; 42084759,    # complete delta in seconds
    };

</pre><h2 id="Compare">Compare()</h2>

<p><a href="#" onclick="toggleCode('method_Compare');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Compare">
                                        <pre>

sub Compare {
    my ( $Self, %Param ) = @_;

    # check required params
    if (
        !defined $Param{DateTimeObject}
        || ref $Param{DateTimeObject} ne ref $Self
        )
    {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            'Priority' => 'Error',
            'Message'  => "Missing or invalid parameter DateTimeObject.",
        );
        return;
    }

    my $Result;
    eval {
        $Result = DateTime->compare(
            $Self->{CPANDateTimeObject},
            $Param{DateTimeObject}->{CPANDateTimeObject}
        );
    };

    return $Result;
}
</pre></div>

<p>Compares dates and returns a value suitable for using Perl's sort function (-1, 0, 1).</p>

<pre>    my $Result = $DateTimeObject-&gt;Compare( DateTimeObject =&gt; $AnotherDateTimeObject );

    You can also use this as a function for Perl's sort:

    my @SortedDateTimeObjects = sort { $a-&gt;Compare( DateTimeObject =&gt; $b ); } @UnsortedDateTimeObjects:

</pre><p>Returns:</p>

<pre>    $Result = -1;       # if date/time of this object &lt; date/time of given object
    $Result = 0;        # if date/time are equal
    $Result = 1:        # if date/time of this object &gt; date/time of given object

</pre><h2 id="ToTimeZone">ToTimeZone()</h2>

<p><a href="#" onclick="toggleCode('method_ToTimeZone');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ToTimeZone">
                                        <pre>

sub ToTimeZone {
    my ( $Self, %Param ) = @_;

    # check required params
    for my $RequiredParam (qw( TimeZone )) {
        if ( !defined $Param{$RequiredParam} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                'Priority' => 'Error',
                'Message'  => "Missing parameter $RequiredParam.",
            );
            return;
        }
    }

    eval {
        $Self->{CPANDateTimeObject}->set_time_zone( $Param{TimeZone} );
    };

    return if $@;

    return 1;
}
</pre></div>

<p>Converts the date and time of this object to the given time zone.</p>

<pre>    my $Success = $DateTimeObject-&gt;ToTimeZone(
        TimeZone =&gt; 'Europe/Berlin',
    );

</pre><p>Returns:</p>

<pre>    $Success = 1;   # success, or false otherwise.

</pre><h2 id="ToOTRSTimeZone">ToOTRSTimeZone()</h2>

<p><a href="#" onclick="toggleCode('method_ToOTRSTimeZone');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ToOTRSTimeZone">
                                        <pre>

sub ToOTRSTimeZone {
    my ( $Self, %Param ) = @_;

    return $Self->ToTimeZone( TimeZone => $Self->OTRSTimeZoneGet() );
}
</pre></div>

<p>Converts the date and time of this object to the data storage time zone.</p>

<pre>    my $Success = $DateTimeObject-&gt;ToOTRSTimeZone();

</pre><p>Returns:</p>

<pre>    $Success = 1;   # success, or false otherwise.

</pre><h2 id="Validate">Validate()</h2>

<p><a href="#" onclick="toggleCode('method_Validate');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Validate">
                                        <pre>

sub Validate {
    my ( $Self, %Param ) = @_;

    # Check given parameters
    my @DateTimeParams = qw ( Year Month Day Hour Minute Second TimeZone );
    for my $RequiredDateTimeParam (@DateTimeParams) {
        if ( !defined $Param{$RequiredDateTimeParam} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                'Priority' => 'Error',
                'Message'  => "Missing parameter $RequiredDateTimeParam.",
            );
            return;
        }
    }

    my $DateTimeObject = $Self->_CPANDateTimeObjectCreate(%Param);
    return if !$DateTimeObject;

    return 1;
}
</pre></div>

<p>Checks if given date, time and time zone would result in a valid date.</p>

<pre>    my $IsValid = $DateTimeObject-&gt;Validate(
        Year     =&gt; 2016,
        Month    =&gt; 1,
        Day      =&gt; 22,
        Hour     =&gt; 16,
        Minute   =&gt; 35,
        Second   =&gt; 59,
        TimeZone =&gt; 'Europe/Berlin',
    );

</pre><p>Returns:</p>

<pre>    $IsValid = 1;   # if date/time is valid, or false otherwise.

</pre><h2 id="Format">Format()</h2>

<p><a href="#" onclick="toggleCode('method_Format');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Format">
                                        <pre>

sub Format {
    my ( $Self, %Param ) = @_;

    for my $RequiredParam (qw( Format )) {
        if ( !defined $Param{$RequiredParam} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                'Priority' => 'Error',
                'Message'  => "Missing parameter $RequiredParam.",
            );

            return;
        }
    }

    return $Self->{CPANDateTimeObject}->strftime( $Param{Format} );
}
</pre></div>

<p>Returns the date/time as string formatted according to format given.
See http://search.cpan.org/~drolsky/DateTime-1.21/lib/DateTime.pm#strftime_Patterns for formatting
the time.</p>

<p>Short overview of essential formatting options:</p>

<pre>    %Y or %{year}: four digit year

    %m: month with leading zero
    %{month}: month without leading zero

    %d: day of month with leading zero
    %{day}: day of month without leading zero

    %H: 24 hour with leading zero
    %{hour}: 24 hour without leading zero

    %l: 12 hour with leading zero
    %{hour_12}: 12 hour without leading zero

    %M: minute with leading zero
    %{minute}: minute without leading zero

    %S: second with leading zero
    %{second}: second without leading zero

    %{time_zone_long_name}: Time zone, e. g. 'Europe/Berlin'

    %{epoch}: Seconds since the epoch (OS specific)
    %{offset}: Offset in seconds to GMT/UTC

    my $DateTimeString = $DateTimeObject-&gt;Format( Format =&gt; '%Y-%m-%d %H:%M:%S' );

</pre><p>Returns:</p>

<pre>    my $String = '2016-01-22 18:07:23';

</pre><h2 id="ToEpoch">ToEpoch()</h2>

<p><a href="#" onclick="toggleCode('method_ToEpoch');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ToEpoch">
                                        <pre>

sub ToEpoch {
    my ( $Self, %Param ) = @_;

    return $Self->{CPANDateTimeObject}->epoch();
}
</pre></div>

<p>Returns date/time as seconds since the epoch.</p>

<pre>    my $Epoch = $DateTimeObject-&gt;ToEpoch();

</pre><p>Returns e. g.:</p>

<pre>    my $Epoch = 1454420017;

</pre><h2 id="ToString">ToString()</h2>

<p><a href="#" onclick="toggleCode('method_ToString');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ToString">
                                        <pre>

sub ToString {
    my ( $Self, %Param ) = @_;

    return $Self->Format( Format => '%Y-%m-%d %H:%M:%S' );
}
</pre></div>

<p>Returns date/time as string.</p>

<pre>    my $DateTimeString = $DateTimeObject-&gt;ToString();

</pre><p>Returns e. g.:</p>

<pre>    $DateTimeString = '2016-01-31 14:05:45'

</pre><h2 id="ToEmailTimeStamp">ToEmailTimeStamp()</h2>

<p><a href="#" onclick="toggleCode('method_ToEmailTimeStamp');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ToEmailTimeStamp">
                                        <pre>

sub ToEmailTimeStamp {
    my ( $Self, %Param ) = @_;

    # According to RFC 2822, section 3.3

    # ---
    # The date and time-of-day SHOULD express local time.

    # The zone specifies the offset from Coordinated Universal Time (UTC,
    # formerly referred to as "Greenwich Mean Time") that the date and
    # time-of-day represent.  The "+" or "-" indicates whether the
    # time-of-day is ahead of (i.e., east of) or behind (i.e., west of)
    # Universal Time.  The first two digits indicate the number of hours
    # difference from Universal Time, and the last two digits indicate the
    # number of minutes difference from Universal Time.  (Hence, +hhmm
    # means +(hh * 60 + mm) minutes, and -hhmm means -(hh * 60 + mm)
    # minutes).  The form "+0000" SHOULD be used to indicate a time zone at
    # Universal Time.  Though "-0000" also indicates Universal Time, it is
    # used to indicate that the time was generated on a system that may be
    # in a local time zone other than Universal Time and therefore
    # indicates that the date-time contains no information about the local
    # time zone.
    # ---

    my $EmailTimeStamp = $Self->Format(
        Format => '%a, %{day} %b %Y %H:%M:%S %z',
    );

    return $EmailTimeStamp;
}
</pre></div>

<p>Returns the date/time of this object as time stamp in RFC 2822 format to be used in email headers.</p>

<pre>    my $MailTimeStamp = $DateTimeObject-&gt;ToEmailTimeStamp();

    # Typical usage:
    # You want to have the date/time of OTRS + its UTC offset, so:
    my $DateTimeObject = $Kernel::OM-&gt;Create('Kernel::System::DateTime');
    my $MailTimeStamp = $DateTimeObject-&gt;ToEmailTimeStamp();

    # If you already have a DateTime object, possibly in another time zone:
    $DateTimeObject-&gt;ToOTRSTimeZone();
    my $MailTimeStamp = $DateTimeObject-&gt;ToEmailTimeStamp();




</pre><p>Returns:</p>

<pre>    my $String = 'Wed, 2 Sep 2014 16:30:57 +0200';

</pre><h2 id="ToCTimeString">ToCTimeString()</h2>

<p><a href="#" onclick="toggleCode('method_ToCTimeString');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ToCTimeString">
                                        <pre>

sub ToCTimeString {
    my ( $Self, %Param ) = @_;

    my $LocalTimeString = $Self->Format(
        Format => '%a %b %{day} %H:%M:%S %Y',
    );

    return $LocalTimeString;
}
</pre></div>

<p>Returns date and time as ctime string, as for example returned by Perl's localtime and gmtime in scalar context.</p>

<pre>    my $CTimeString = $DateTimeObject-&gt;ToCTimeString();

</pre><p>Returns</p>

<pre>    my $String = 'Fri Feb 19 16:07:31 2016';

</pre><h2 id="IsVacationDay">IsVacationDay()</h2>

<p><a href="#" onclick="toggleCode('method_IsVacationDay');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_IsVacationDay">
                                        <pre>

sub IsVacationDay {
    my ( $Self, %Param ) = @_;

    my $OriginalDateTimeValues = $Self->Get();

    # Get configured vacation days
    my $ConfigObject            = $Kernel::OM->Get('Kernel::Config');
    my $TimeVacationDays        = $ConfigObject->Get('TimeVacationDays');
    my $TimeVacationDaysOneTime = $ConfigObject->Get('TimeVacationDaysOneTime');
    if ( $Param{Calendar} ) {
        if ( $ConfigObject->Get( "TimeZone::Calendar" . $Param{Calendar} . "Name" ) ) {
            $TimeVacationDays        = $ConfigObject->Get( "TimeVacationDays::Calendar" . $Param{Calendar} );
            $TimeVacationDaysOneTime = $ConfigObject->Get(
                "TimeVacationDaysOneTime::Calendar" . $Param{Calendar}
            );

            # Switch to time zone of calendar
            my $TimeZone = $ConfigObject->Get( "TimeZone::Calendar" . $Param{Calendar} )
                || $Self->OTRSTimeZoneGet();

            if ( defined $TimeZone ) {
                $Self->ToTimeZone( TimeZone => $TimeZone );
            }
        }
    }

    my $DateTimeValues = $Self->Get();

    my $VacationDay        = $TimeVacationDays->{ $DateTimeValues->{Month} }->{ $DateTimeValues->{Day} };
    my $VacationDayOneTime = $TimeVacationDaysOneTime->{ $DateTimeValues->{Year} }->{ $DateTimeValues->{Month} }
        ->{ $DateTimeValues->{Day} };

    # Switch back to original time zone
    $Self->ToTimeZone( TimeZone => $OriginalDateTimeValues->{TimeZone} );

    return $VacationDay        if defined $VacationDay;
    return $VacationDayOneTime if defined $VacationDayOneTime;

    return 0;
}
</pre></div>

<p>Checks if date/time of this object is a vacation day.</p>

<pre>    my $IsVacationDay = $DateTimeObject-&gt;IsVacationDay(
        Calendar =&gt; 9, # optional, OTRS vacation days otherwise
    );

</pre><p>Returns:</p>

<pre>    my $IsVacationDay = 'some vacation day',    # description of vacation day or 0 if no vacation day.

</pre><h2 id="LastDayOfMonthGet">LastDayOfMonthGet()</h2>

<p><a href="#" onclick="toggleCode('method_LastDayOfMonthGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_LastDayOfMonthGet">
                                        <pre>

sub LastDayOfMonthGet {
    my ( $Self, %Param ) = @_;

    my $DateTimeValues = $Self->Get();

    my $TempCPANDateTimeObject;
    eval {
        $TempCPANDateTimeObject = DateTime->last_day_of_month(
            year  => $DateTimeValues->{Year},
            month => $DateTimeValues->{Month},
        );
    };

    return if !$TempCPANDateTimeObject;

    my $Result = {
        Day       => $TempCPANDateTimeObject->day(),
        DayOfWeek => $TempCPANDateTimeObject->day_of_week(),
        DayAbbr   => $TempCPANDateTimeObject->day_abbr(),
    };

    return $Result;
}
</pre></div>

<p>Returns the last day of the month.</p>

<pre>    $LastDayOfMonth = $DateTimeObject-&gt;LastDayOfMonthGet();

</pre><p>Returns:</p>

<pre>    my $LastDayOfMonth = {
        Day       =&gt; 31,
        DayOfWeek =&gt; 5,
        DayAbbr   =&gt; 'Fri',
    };

</pre><h2 id="Clone">Clone()</h2>

<p><a href="#" onclick="toggleCode('method_Clone');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Clone">
                                        <pre>

sub Clone {
    my ( $Self, %Param ) = @_;

    my $ClonedDateTimeObject = $Kernel::OM->Create(
        __PACKAGE__,
        ObjectParams => $Self->Get(),
    );

    return $ClonedDateTimeObject;
}
</pre></div>

<p>Clones the DateTime object.</p>

<pre>    my $ClonedDateTimeObject = $DateTimeObject-&gt;Clone();

</pre><h2 id="TimeZoneList">TimeZoneList()</h2>

<p><a href="#" onclick="toggleCode('method_TimeZoneList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_TimeZoneList">
                                        <pre>

sub TimeZoneList {
    my @TimeZones = @{ DateTime::TimeZone->all_names() };

    # add missing UTC time zone for certain DateTime versions
    my %TimeZones = map { $_ => 1 } @TimeZones;
    if ( !exists $TimeZones{UTC} ) {
        push @TimeZones, 'UTC';
    }

    return \@TimeZones;
}
</pre></div>

<p>Returns an array ref of available time zones.</p>

<pre>    my $TimeZones = $DateTimeObject-&gt;TimeZoneList();

    # You can also call this method without an object:
    #my $TimeZones = Kernel::System::DateTime-&gt;TimeZoneList();

</pre><p>Returns:</p>

<pre>    my $TimeZoneList = [
        # ...
        'Europe/Amsterdam',
        'Europe/Andorra',
        'Europe/Athens',
        # ...
    ];

</pre><h2 id="TimeZoneByOffsetList">TimeZoneByOffsetList()</h2>

<p><a href="#" onclick="toggleCode('method_TimeZoneByOffsetList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_TimeZoneByOffsetList">
                                        <pre>

sub TimeZoneByOffsetList {
    my ( $Self, %Param ) = @_;

    my $DateTimeObject = $Self->Clone();

    my $TimeZones = $Self->TimeZoneList();

    my %TimeZoneByOffset;
    for my $TimeZone ( sort @{$TimeZones} ) {
        $DateTimeObject->ToTimeZone( TimeZone => $TimeZone );
        my $TimeZoneOffset = $DateTimeObject->Format( Format => '%{offset}' ) / 60 / 60;

        if ( exists $TimeZoneByOffset{$TimeZoneOffset} ) {
            push @{ $TimeZoneByOffset{$TimeZoneOffset} }, $TimeZone;
        }
        else {
            $TimeZoneByOffset{$TimeZoneOffset} = [ $TimeZone, ];
        }
    }

    return \%TimeZoneByOffset;
}
</pre></div>

<p>Returns a list of time zones by offset in hours.
Of course the resulting list depends on the date/time set within this DateTime object.</p>

<pre>    my %TimeZoneByOffset = $DateTimeObject-&gt;TimeZoneByOffsetList();

</pre><p>Returns:</p>

<pre>    my $TimeZoneByOffsetList = {
        # ...
        -9 =&gt; [ 'America/Adak', 'Pacific/Gambier', ],
        # ...
        2  =&gt; [
            # ...
            'Europe/Berlin',
            # ...
        ],
        # ...
        8.75 =&gt; [ 'Australia/Eucla', ],
        # ...
    };

</pre><h2 id="IsTimeZoneValid">IsTimeZoneValid()</h2>

<p><a href="#" onclick="toggleCode('method_IsTimeZoneValid');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_IsTimeZoneValid">
                                        <pre>

sub IsTimeZoneValid {
    my ( $Self, %Param ) = @_;

    # check required params
    for my $RequiredParam (qw( TimeZone )) {
        if ( !defined $Param{$RequiredParam} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                'Priority' => 'Error',
                'Message'  => "Missing parameter $RequiredParam.",
            );
            return;
        }
    }

    # allow DateTime internal time zone in 'floating'
    return 1 if $Param{TimeZone} eq 'floating';

    if ( !%ValidTimeZones ) {
        %ValidTimeZones = map { $_ => 1 } @{ $Self->TimeZoneList() };
    }

    return $ValidTimeZones{ $Param{TimeZone} } ? 1 : 0;
}
</pre></div>

<p>Checks if the given time zone is valid.</p>

<pre>    my $Valid = $DateTimeObject-&gt;IsTimeZoneValid( TimeZone =&gt; 'Europe/Berlin' );

</pre><p>Returns:
    $ValidID = 1;    # if given time zone is valid, 0 otherwise.</p>

<h2 id="OTRSTimeZoneGet">OTRSTimeZoneGet()</h2>

<p><a href="#" onclick="toggleCode('method_OTRSTimeZoneGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_OTRSTimeZoneGet">
                                        <pre>

sub OTRSTimeZoneGet {
    return $Kernel::OM->Get('Kernel::Config')->Get('OTRSTimeZone') || 'UTC';
}
</pre></div>

<p>Returns the time zone set for OTRS.</p>

<pre>    my $OTRSTimeZone = $DateTimeObject-&gt;OTRSTimeZoneGet();

    # You can also call this method without an object:
    #my $OTRSTimeZone = Kernel::System::DateTime-&gt;OTRSTimeZoneGet();

</pre><p>Returns:</p>

<pre>    my $OTRSTimeZone = 'Europe/Berlin';

</pre><h2 id="UserDefaultTimeZoneGet">UserDefaultTimeZoneGet()</h2>

<p><a href="#" onclick="toggleCode('method_UserDefaultTimeZoneGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_UserDefaultTimeZoneGet">
                                        <pre>

sub UserDefaultTimeZoneGet {
    return $Kernel::OM->Get('Kernel::Config')->Get('UserDefaultTimeZone') || 'UTC';
}
</pre></div>

<p>Returns the time zone set as default in SysConfig UserDefaultTimeZone for
newly created users or existing users without time zone setting.</p>

<pre>    my $UserDefaultTimeZoneGet = $DateTimeObject-&gt;UserDefaultTimeZoneGet();

    # You can also call this method without an object:
    #my $UserDefaultTimeZoneGet = Kernel::System::DateTime-&gt;UserDefaultTimeZoneGet();

</pre><p>Returns:</p>

<pre>    my $UserDefaultTimeZone = 'Europe/Berlin';

</pre><h2 id="SystemTimeZoneGet">SystemTimeZoneGet()</h2>

<p><a href="#" onclick="toggleCode('method_SystemTimeZoneGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SystemTimeZoneGet">
                                        <pre>

sub SystemTimeZoneGet {
    return DateTime::TimeZone->new( name => 'local' )->name();
}
</pre></div>

<p>Returns the time zone of the system.</p>

<pre>    my $SystemTimeZone = $DateTimeObject-&gt;SystemTimeZoneGet();

    # You can also call this method without an object:
    #my $SystemTimeZone = Kernel::System::DateTime-&gt;SystemTimeZoneGet();

</pre><p>Returns:</p>

<pre>    my $SystemTimeZone = 'Europe/Berlin';

</pre><h1 id="TERMS_AND_CONDITIONS">TERMS AND CONDITIONS <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<p>This software is part of the OTRS project (<a href="http://otrs.org/">http://otrs.org/</a>).</p>

<p>This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see <a href="http://www.gnu.org/licenses/agpl.txt">http://www.gnu.org/licenses/agpl.txt</a>.</p>


</div><div class="footer">generated by <a href="http://search.cpan.org/perldoc?Pod%3A%3AProjectDocs">Pod::ProjectDocs</a></div></body>
</html>
