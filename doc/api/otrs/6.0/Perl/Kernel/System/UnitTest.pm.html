<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<!-- otrs.github.io -->
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../../../../../../documentation.css">
<script src="https://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../../../../../documentation.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script>
$(document).ready(function() {

    // Hint languages to prevent false matches (php for example).
    hljs.configure({
        languages: ['perl', 'javascript', 'xml', 'html', 'css', 'json', 'yaml']
    });

    // programlistings in manuals
    $('pre.programlisting').each(function(i, block) {
        hljs.highlightBlock(block);
    });
    // code snippets in Perl API docs
    $('.pod pre').addClass('perl').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});</script>
<!-- otrs.github.io -->

	<title>Kernel::System::UnitTest</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <script type="text/javascript">

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  </script></head>
<body>
<div class="box">
  <h1 class="t1">OTRS 6.0 API Reference Perl</h1>
  <table>
    <tr>
      <td class="label">Description</td>
      <td class="cell">manuals and libraries</td>
    </tr>
  </table>
</div>
<div class="path">
  <a href="../../index.html">OTRS 6.0 API Reference Perl</a> &gt; Perl Modules &gt;
  Kernel::System::UnitTest
</div>
<div>
<a href="../../src/Kernel/System/UnitTest.pm">Source</a>
</div>
<div class="pod">
<!-- INDEX START -->
<h3 id="TOP">Index</h3>
<ul>
	<li><a href="#NAME">NAME</a></li>
	<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
	<li><a href="#PUBLIC_INTERFACE">PUBLIC INTERFACE</a><br />
<ul>
	<li><a href="#new">new()</a></li>
	<li><a href="#Run">Run()</a></li>
	<li><a href="#True">True()</a></li>
	<li><a href="#False">False()</a></li>
	<li><a href="#Is">Is()</a></li>
	<li><a href="#IsNot">IsNot()</a></li>
	<li><a href="#IsDeeply">IsDeeply()</a></li>
	<li><a href="#IsNotDeeply">IsNotDeeply()</a></li>
</ul>
</li>
	<li><a href="#TERMS_AND_CONDITIONS">TERMS AND CONDITIONS</a></li>
</ul>
<hr />
<!-- INDEX END -->

<h1 id="NAME">NAME <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<p>Kernel::System::UnitTest - global unit test interface</p>

<h1 id="DESCRIPTION">DESCRIPTION <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<p>Functions to run existing unit tests, as well as functions to define test cases.</p>

<h1 id="PUBLIC_INTERFACE">PUBLIC INTERFACE <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<h2 id="new">new()</h2>

<p><a href="#" onclick="toggleCode('method_new');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_new">
                                        <pre>

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    $Self->{Debug} = $Param{Debug} || 0;
    $Self->{ANSI} = $Param{ANSI};

    $Self->{ResultData} = undef;
    $Self->{TestFile}   = '';

    # Make sure stuff is always flushed to keep it in the right order.
    *STDOUT->autoflush(1);
    *STDERR->autoflush(1);
    $Self->{OriginalSTDOUT} = *STDOUT;
    $Self->{OriginalSTDOUT}->autoflush(1);

    return $Self;
}
</pre></div>

<p>create unit test object. Do not use it directly, instead use:</p>

<pre>    my $UnitTestObject = $Kernel::OM-&gt;Get('Kernel::System::UnitTest');
</pre><h2 id="Run">Run()</h2>

<p><a href="#" onclick="toggleCode('method_Run');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Run">
                                        <pre>

sub Run {
    my ( $Self, %Param ) = @_;

    $Self->{Verbose} = $Param{Verbose};

    my $Product
        = $Kernel::OM->Get('Kernel::Config')->Get('Product') . " " . $Kernel::OM->Get('Kernel::Config')->Get('Version');

    my $Home      = $Kernel::OM->Get('Kernel::Config')->Get('Home');
    my $Directory = "$Home/scripts/test";
    if ( $Param{Directory} ) {
        $Directory .= "/$Param{Directory}";
        $Directory =~ s/\.//g;
    }

    my @TestsToExecute = @{ $Param{Tests} // [] };

    $Self->{TestCountOk}    = 0;
    $Self->{TestCountNotOk} = 0;

    my $StartTime = $Kernel::OM->Get('Kernel::System::Time')->SystemTime();

    my @Files = $Kernel::OM->Get('Kernel::System::Main')->DirectoryRead(
        Directory => $Directory,
        Filter    => '*.t',
        Recursive => 1,
    );

    FILE:
    for my $File (@Files) {

        # check if only some tests are requested
        if ( @TestsToExecute && !grep { $File =~ /\/\Q$_\E\.t$/smx } @TestsToExecute ) {
            next FILE;
        }

        $Self->{TestCount} = 0;

        my $UnitTestFile = $Kernel::OM->Get('Kernel::System::Main')->FileRead( Location => $File );
        if ( !$UnitTestFile ) {
            $Self->True( 0, "ERROR: $!: $File" );
            print STDERR "ERROR: $!: $File\n";
            next FILE;
        }

        print "+-------------------------------------------------------------------+\n";
        print "$File:\n";
        print "+-------------------------------------------------------------------+\n";

        $Self->{TestFile} = $File;

        my $FileStartTime = $Kernel::OM->Get('Kernel::System::Time')->SystemTime();

        # create a new scope to be sure to destroy local object of the test files
        {
            # Make sure every UT uses its own clean environment.
            local $Kernel::OM = Kernel::System::ObjectManager->new(
                'Kernel::System::Log' => {
                    LogPrefix => 'OTRS-otrs.UnitTest',
                },
            );

            # Provide $Self as 'Kernel::System::UnitTest' for convenience.
            $Kernel::OM->ObjectInstanceRegister(
                Package      => 'Kernel::System::UnitTest',
                Object       => $Self,
                Dependencies => [],
            );

            push @{ $Self->{NotOkInfo} }, [$File];

            $Self->{OutputBuffer} = '';
            local *STDOUT = *STDOUT;
            local *STDERR = *STDERR;
            if ( !$Param{Verbose} ) {
                undef *STDOUT;
                undef *STDERR;
                open STDOUT, '>:utf8', \$Self->{OutputBuffer};    ## no critic
                open STDERR, '>:utf8', \$Self->{OutputBuffer};    ## no critic
            }

            # HERE the actual tests are run!!!
            if ( !eval ${$UnitTestFile} ) {                       ## no critic
                if ($@) {
                    $Self->True( 0, "ERROR: Error in $File: $@" );
                }
                else {
                    $Self->True( 0, "ERROR: $File did not return a true value." );
                }
            }
        }

        my $FileDuration = $Kernel::OM->Get('Kernel::System::Time')->SystemTime() - $FileStartTime;
        $Self->{ResultData}->{$File}->{Duration} = $FileDuration;

        print "\n";
    }

    my $EndTime  = $Kernel::OM->Get('Kernel::System::Time')->SystemTime();
    my $Duration = $EndTime - $StartTime;

    my $Host = $Kernel::OM->Get('Kernel::Config')->Get('FQDN');

    print "=====================================================================\n";
    print $Self->_Color( 'yellow', $Host ) . " ran tests in " . $Self->_Color( 'yellow', "${Duration}s" );
    print " for " . $Self->_Color( 'yellow', $Product ) . "\n";

    if ( $Self->{TestCountNotOk} ) {
        print $Self->_Color( 'red', "$Self->{TestCountNotOk} tests failed.\n" );
    }
    else {
        if ( $Self->{TestCountOk} ) {
            print $Self->_Color( 'green', "All $Self->{TestCountOk} tests passed.\n" );
        }
        else {
            print $Self->_Color( 'yellow', "No tests executed.\n" );
        }
    }

    if ( $Self->{TestCountNotOk} ) {
        print " FailedTests:\n";
        FAILEDFILE:
        for my $FailedFile ( @{ $Self->{NotOkInfo} || [] } ) {
            my ( $File, @Tests ) = @{ $FailedFile || [] };
            next FAILEDFILE if !@Tests;
            print sprintf "  %s #%s\n", $File, join ", ", @Tests;
        }
    }

    if ( $Param{SubmitURL} ) {

        my %SupportData = $Kernel::OM->Get('Kernel::System::SupportDataCollector')->Collect();
        die "Could not collect SupportData.\n" if !$SupportData{Success};

        my %SubmitData = (
            Auth     => $Param{SubmitAuth} // '',
            JobID    => $Param{JobID}      // '',
            Scenario => $Param{Scenario}   // '',
            Meta     => {
                StartTime => $StartTime,
                Duration  => $Duration,
                TestOk    => $Self->{TestCountOk},
                TestNotOk => $Self->{TestCountNotOk},
            },
            SupportData => $SupportData{Result},
            Results     => $Self->{ResultData},
        );

        print "=====================================================================\n";
        print "Sending results to " . $Self->_Color( 'yellow', $Param{SubmitURL} ) . " ...\n";

        # Flush possible output log files to be able to submit them.
        *STDOUT->flush();
        *STDERR->flush();

        # Limit attachment sizes to 2MB in total.
        my $AttachmentCount = scalar @{ $Param{AttachmentPath} // [] };
        my $AttachmentsSize = 1024 * 1024 * 2;
        for my $AttachmentPath ( @{ $Param{AttachmentPath} // [] } ) {
            my $FileHandle;
            my $Content;

            if ( !open $FileHandle, '<:encoding(UTF-8)', $AttachmentPath ) {    ## no-critic
                print $Self->_Color( 'red', "Could not open file $AttachmentPath, aborting submission.\n" );
                return;
            }

            # Read only allocated size of file to try to avoid out of memory error.
            if ( !read $FileHandle, $Content, $AttachmentsSize / $AttachmentCount ) {    ## no-critic
                print $Self->_Color( 'red', "Could not read file $AttachmentPath, aborting submission.\n" );
                close $FileHandle;
                return;
            }

            my $Stat = stat($AttachmentPath);

            if ( !$Stat ) {
                print $Self->_Color( 'red', "Cannot stat file $AttachmentPath, aborting submission.\n" );
                return;
            }

            # If file size exceeds the limit, include message about shortening at the end.
            if ( $Stat->size() > $AttachmentsSize / $AttachmentCount ) {
                $Content .= "\nThis file has been shortened because of size constraint.";
            }

            close $FileHandle;

            $SubmitData{Attachments}->{$AttachmentPath} = $Content;
        }

        my $JSONObject = $Kernel::OM->Get('Kernel::System::JSON');

        # Perform web service request and get response.
        my %Response = $Kernel::OM->Get('Kernel::System::WebUserAgent')->Request(
            Type => 'POST',
            URL  => $Param{SubmitURL},
            Data => {
                Action      => 'PublicCIMaster',
                Subaction   => 'TestResults',
                RequestData => $JSONObject->Encode(
                    Data => \%SubmitData,
                ),
            },
        );

        if ( $Response{Status} ne '200 OK' ) {
            print $Self->_Color( 'red', "Submission to server failed (status code '$Response{Status}').\n" );
            return;
        }

        if ( !$Response{Content} ) {
            print $Self->_Color( 'red', "Submission to server failed (no response).\n" );
            return;
        }

        # Convert internal used charset.
        $Kernel::OM->Get('Kernel::System::Encode')->EncodeInput(
            $Response{Content},
        );

        my $ResponseData = $JSONObject->Decode(
            Data => ${ $Response{Content} },
        );

        if ( !$ResponseData ) {
            print $Self->_Color( 'red', "Submission to server failed (invalid response).\n" );
            return;
        }

        if ( !$ResponseData->{Success} && $ResponseData->{ErrorMessage} ) {
            print $Self->_Color(
                'red',
                "Submission to server failed (error message '$ResponseData->{ErrorMessage}').\n"
            );
            return;
        }

        print $Self->_Color( 'green', "Submission was successful.\n" );

        if ( $Param{SubmitResultAsExitCode} ) {
            return 1;
        }
    }

    return $Self->{TestCountNotOk} ? 0 : 1;
}
</pre></div>

<p>Run all tests located in scripts/test/*.t and print result to stdout.</p>

<pre>    $UnitTestObject-&gt;Run(
        Name                   =&gt; ['JSON', 'User'],     # optional, execute certain test files only
        Directory              =&gt; 'Selenium',           # optional, execute tests in subdirectory
        Verbose                =&gt; 1,                    # optional (default 0), only show result details for all tests, not just failing
        SubmitURL              =&gt; $URL,                 # optional, send results to unit test result server
        SubmitAuth             =&gt; '0abc86125f0fd37baae' # optional authentication string for unit test result server
        SubmitResultAsExitCode =&gt; 1,                    # optional, specify if exit code should not indicate if tests were ok/not ok, but if submission was successful instead
        JobID                  =&gt; 12,                   # optional job ID for unit test submission to server
        Scenario               =&gt; 'OTRS 6 git',         # optional scenario identifier for unit test submission to server
    );
</pre><h2 id="True">True()</h2>

<p><a href="#" onclick="toggleCode('method_True');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_True">
                                        <pre>

sub True {
    my ( $Self, $True, $Name ) = @_;

    if ( !$Name ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need Name! E. g. True(\$A, \'Test Name\')!'
        );
        $Self->_Print( 0, 'ERROR: Need Name! E. g. True(\$A, \'Test Name\')' );
        return;
    }

    if ($True) {
        $Self->_Print( 1, $Name );
        return 1;
    }
    else {
        $Self->_Print( 0, $Name );
        return;
    }
}
</pre></div>

<p>test for a scalar value that evaluates to true.</p>

<p>Send a scalar value to this function along with the test's name:</p>

<pre>    $UnitTestObject-&gt;True(1, 'Test Name');

    $UnitTestObject-&gt;True($ParamA, 'Test Name');
</pre><p>Internally, the function receives this value and evaluates it to see
if it's true, returning 1 in this case or undef, otherwise.</p>

<pre>    my $TrueResult = $UnitTestObject-&gt;True(
        $TestValue,
        'Test Name',
    );
</pre><h2 id="False">False()</h2>

<p><a href="#" onclick="toggleCode('method_False');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_False">
                                        <pre>

sub False {
    my ( $Self, $False, $Name ) = @_;

    if ( !$Name ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need Name! E. g. False(\$A, \'Test Name\')!'
        );
        $Self->_Print( 0, 'ERROR: Need Name! E. g. False(\$A, \'Test Name\')' );
        return;
    }

    if ( !$False ) {
        $Self->_Print( 1, $Name );
        return 1;
    }
    else {
        $Self->_Print( 0, $Name );
        return;
    }
}
</pre></div>

<p>test for a scalar value that evaluates to false.</p>

<p>It has the same interface as <a href="#True">True()</a>, but tests
for a false value instead.</p>

<h2 id="Is">Is()</h2>

<p><a href="#" onclick="toggleCode('method_Is');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Is">
                                        <pre>

sub Is {
    my ( $Self, $Test, $ShouldBe, $Name ) = @_;

    if ( !$Name ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need Name! E. g. Is(\$A, \$B, \'Test Name\')!'
        );
        $Self->_Print( 0, 'ERROR: Need Name! E. g. Is(\$A, \$B, \'Test Name\')' );
        return;
    }

    if ( !defined $Test && !defined $ShouldBe ) {
        $Self->_Print( 1, "$Name (is 'undef')" );
        return 1;
    }
    elsif ( !defined $Test && defined $ShouldBe ) {
        $Self->_Print( 0, "$Name (is 'undef' should be '$ShouldBe')" );
        return;
    }
    elsif ( defined $Test && !defined $ShouldBe ) {
        $Self->_Print( 0, "$Name (is '$Test' should be 'undef')" );
        return;
    }
    elsif ( $Test eq $ShouldBe ) {
        $Self->_Print( 1, "$Name (is '$ShouldBe')" );
        return 1;
    }
    else {
        $Self->_Print( 0, "$Name (is '$Test' should be '$ShouldBe')" );
        return;
    }
}
</pre></div>

<p>compares two scalar values for equality.</p>

<p>To this function you must send a pair of scalar values to compare them,
and the name that the test will take, this is done as shown in the examples
below.</p>

<pre>    $UnitTestObject-&gt;Is($A, $B, 'Test Name');
</pre><p>Returns 1 if the values were equal, or undef otherwise.</p>

<pre>    my $IsResult = $UnitTestObject-&gt;Is(
        $ValueFromFunction,      # test data
        1,                       # expected value
        'Test Name',
    );
</pre><h2 id="IsNot">IsNot()</h2>

<p><a href="#" onclick="toggleCode('method_IsNot');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_IsNot">
                                        <pre>

sub IsNot {
    my ( $Self, $Test, $ShouldBe, $Name ) = @_;

    if ( !$Name ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need Name! E. g. IsNot(\$A, \$B, \'Test Name\')!'
        );
        $Self->_Print( 0, 'ERROR: Need Name! E. g. IsNot(\$A, \$B, \'Test Name\')' );
        return;
    }

    if ( !defined $Test && !defined $ShouldBe ) {
        $Self->_Print( 0, "$Name (is 'undef')" );
        return;
    }
    elsif ( !defined $Test && defined $ShouldBe ) {
        $Self->_Print( 1, "$Name (is 'undef')" );
        return 1;
    }
    elsif ( defined $Test && !defined $ShouldBe ) {
        $Self->_Print( 1, "$Name (is '$Test')" );
        return 1;
    }
    if ( $Test ne $ShouldBe ) {
        $Self->_Print( 1, "$Name (is '$Test')" );
        return 1;
    }
    else {
        $Self->_Print( 0, "$Name (is '$Test' should not be '$ShouldBe')" );
        return;
    }
}
</pre></div>

<p>compares two scalar values for inequality.</p>

<p>It has the same interface as <a href="#Is">Is()</a>, but tests
for inequality instead.</p>

<h2 id="IsDeeply">IsDeeply()</h2>

<p><a href="#" onclick="toggleCode('method_IsDeeply');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_IsDeeply">
                                        <pre>

sub IsDeeply {
    my ( $Self, $Test, $ShouldBe, $Name ) = @_;

    if ( !$Name ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need Name! E. g. Is(\$A, \$B, \'Test Name\')!'
        );
        $Self->_Print( 0, 'ERROR: Need Name! E. g. Is(\$A, \$B, \'Test Name\')' );
        return;
    }

    my $Diff = DataIsDifferent(
        Data1 => $Test,
        Data2 => $ShouldBe,
    );

    if ( !defined $Test && !defined $ShouldBe ) {
        $Self->_Print( 1, "$Name (is 'undef')" );
        return 1;
    }
    elsif ( !defined $Test && defined $ShouldBe ) {
        $Self->_Print( 0, "$Name (is 'undef' should be defined)" );
        return;
    }
    elsif ( defined $Test && !defined $ShouldBe ) {
        $Self->_Print( 0, "$Name (is defined should be 'undef')" );
        return;
    }
    elsif ( !$Diff ) {
        $Self->_Print( 1, "$Name matches expected value" );
        return 1;
    }
    else {
        my $ShouldBeDump = $Kernel::OM->Get('Kernel::System::Main')->Dump($ShouldBe);
        my $TestDump     = $Kernel::OM->Get('Kernel::System::Main')->Dump($Test);
        $Self->_Print( 0, "$Name (is '$TestDump' should be '$ShouldBeDump')" );
        return;
    }
}
</pre></div>

<p>compares complex data structures for equality.</p>

<p>To this function you must send the references to two data structures to be compared,
and the name that the test will take, this is done as shown in the examples
below.</p>

<pre>    $UnitTestObject-&gt; IsDeeply($ParamA, $ParamB, 'Test Name');
</pre><p>Where $ParamA and $ParamB must be references to a structure (scalar, list or hash).</p>

<p>Returns 1 if the data structures are the same, or undef otherwise.</p>

<pre>    my $IsDeeplyResult = $UnitTestObject-&gt;IsDeeply(
        \%ResultHash,           # test data
        \%ExpectedHash,         # expected value
        'Dummy Test Name',
    );
</pre><h2 id="IsNotDeeply">IsNotDeeply()</h2>

<p><a href="#" onclick="toggleCode('method_IsNotDeeply');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_IsNotDeeply">
                                        <pre>

sub IsNotDeeply {
    my ( $Self, $Test, $ShouldBe, $Name ) = @_;

    if ( !$Name ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need Name! E. g. IsNot(\$A, \$B, \'Test Name\')!'
        );
        $Self->_Print( 0, 'ERROR: Need Name! E. g. IsNot(\$A, \$B, \'Test Name\')' );
        return;
    }

    my $Diff = DataIsDifferent(
        Data1 => $Test,
        Data2 => $ShouldBe,
    );

    if ( !defined $Test && !defined $ShouldBe ) {
        $Self->_Print( 0, "$Name (is 'undef')" );
        return;
    }
    elsif ( !defined $Test && defined $ShouldBe ) {
        $Self->_Print( 1, "$Name (is 'undef')" );
        return 1;
    }
    elsif ( defined $Test && !defined $ShouldBe ) {
        $Self->_Print( 1, "$Name (differs from expected value)" );
        return 1;
    }

    if ($Diff) {
        $Self->_Print( 1, "$Name (The structures are not equal.)" );
        return 1;
    }
    else {

        #        $Self->_Print( 0, "$Name (matches the expected value)" );
        my $TestDump = $Kernel::OM->Get('Kernel::System::Main')->Dump($Test);
        $Self->_Print( 0, "$Name (The structures are equal: '$TestDump')" );

        return;
    }
}
</pre></div>

<p>compares two data structures for inequality.</p>

<p>It has the same interface as <a href="#IsDeeply">IsDeeply()</a>, but tests
for inequality instead.</p>

<h1 id="TERMS_AND_CONDITIONS">TERMS AND CONDITIONS <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<p>This software is part of the OTRS project (<a href="http://otrs.org/">http://otrs.org/</a>).</p>

<p>This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see <a href="http://www.gnu.org/licenses/agpl.txt">http://www.gnu.org/licenses/agpl.txt</a>.</p>


</div><div class="footer">generated by <a href="http://search.cpan.org/perldoc?Pod%3A%3AProjectDocs">Pod::ProjectDocs</a></div></body>
</html>
