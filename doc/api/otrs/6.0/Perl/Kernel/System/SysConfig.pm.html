<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<!-- otrs.github.io -->
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../../../../../../documentation.css">
<script src="https://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../../../../../documentation.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script>
$(document).ready(function() {

    // Hint languages to prevent false matches (php for example).
    hljs.configure({
        languages: ['perl', 'javascript', 'xml', 'html', 'css', 'json', 'yaml']
    });

    // programlistings in manuals
    $('pre.programlisting').each(function(i, block) {
        hljs.highlightBlock(block);
    });
    // code snippets in Perl API docs
    $('.pod pre').addClass('perl').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});</script>
<!-- otrs.github.io -->

	<title>Kernel::System::SysConfig</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <script type="text/javascript">

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  </script></head>
<body>
<div class="box">
  <h1 class="t1">OTRS 6.0 API Reference Perl</h1>
  <table>
    <tr>
      <td class="label">Description</td>
      <td class="cell">manuals and libraries</td>
    </tr>
  </table>
</div>
<div class="path">
  <a href="../../index.html">OTRS 6.0 API Reference Perl</a> &gt; Perl Modules &gt;
  Kernel::System::SysConfig
</div>
<div>
<a href="../../src/Kernel/System/SysConfig.pm">Source</a>
</div>
<div class="pod">
<!-- INDEX START -->
<h3 id="TOP">Index</h3>
<ul>
	<li><a href="#NAME">NAME</a></li>
	<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
	<li><a href="#PUBLIC_INTERFACE">PUBLIC INTERFACE</a><br />
<ul>
	<li><a href="#new">new()</a></li>
	<li><a href="#SettingGet">SettingGet()</a></li>
	<li><a href="#SettingUpdate">SettingUpdate()</a></li>
	<li><a href="#SettingLock">SettingLock()</a></li>
	<li><a href="#SettingUnlock">SettingUnlock()</a></li>
	<li><a href="#SettingLockCheck">SettingLockCheck()</a></li>
	<li><a href="#SettingEffectiveValueGet">SettingEffectiveValueGet()</a></li>
	<li><a href="#SettingRender">SettingRender()</a></li>
	<li><a href="#SettingAddItem">SettingAddItem()</a></li>
	<li><a href="#SettingsUpdatedList">SettingsUpdatedList()</a></li>
	<li><a href="#SettingEffectiveValueCheck">SettingEffectiveValueCheck()</a></li>
	<li><a href="#SettingReset">SettingReset()</a></li>
	<li><a href="#ConfigurationTranslatedGet">ConfigurationTranslatedGet()</a></li>
	<li><a href="#SettingNavigationToPath">SettingNavigationToPath()</a></li>
	<li><a href="#ConfigurationTranslatableStrings">ConfigurationTranslatableStrings()</a></li>
	<li><a href="#ConfigurationEntitiesGet">ConfigurationEntitiesGet()</a></li>
	<li><a href="#ConfigurationEntityCheck">ConfigurationEntityCheck()</a></li>
	<li><a href="#ConfigurationXML2DB">ConfigurationXML2DB()</a></li>
	<li><a href="#ConfigurationNavigationTree">ConfigurationNavigationTree()</a></li>
	<li><a href="#ConfigurationListGet">ConfigurationListGet()</a></li>
	<li><a href="#ConfigurationList">ConfigurationList()</a></li>
	<li><a href="#ConfigurationInvalidList">ConfigurationInvalidList()</a></li>
	<li><a href="#ConfigurationDeploy">ConfigurationDeploy()</a></li>
	<li><a href="#ConfigurationDeployList">ConfigurationDeployList()</a></li>
	<li><a href="#ConfigurationDeploySync_Updates_code">ConfigurationDeploySync()
Updates <code>ZZZAAuto.pm</code> to the latest deployment found in the database.</a></li>
	<li><a href="#ConfigurationDeployCleanup">ConfigurationDeployCleanup()</a></li>
	<li><a href="#ConfigurationDeployGet">ConfigurationDeployGet()</a></li>
	<li><a href="#ConfigurationDeployGetLast">ConfigurationDeployGetLast()</a></li>
	<li><a href="#ConfigurationDeploySettingsListGet">ConfigurationDeploySettingsListGet()</a></li>
	<li><a href="#ConfigurationIsDirtyCheck">ConfigurationIsDirtyCheck()</a></li>
	<li><a href="#ConfigurationDump">ConfigurationDump()</a></li>
	<li><a href="#ConfigurationLoad">ConfigurationLoad()</a></li>
	<li><a href="#ConfigurationDirtySettingsList">ConfigurationDirtySettingsList()</a></li>
	<li><a href="#ConfigurationLockedSettingsList">ConfigurationLockedSettingsList()</a></li>
	<li><a href="#ConfigurationSearch">ConfigurationSearch()</a></li>
	<li><a href="#ConfigurationCategoriesGet">ConfigurationCategoriesGet()</a></li>
	<li><a href="#ForbiddenValueTypesGet">ForbiddenValueTypesGet()</a></li>
	<li><a href="#ValueAttributeList">ValueAttributeList()</a></li>
	<li><a href="#ConfigItemGet">ConfigItemGet()</a></li>
</ul>
</li>
	<li><a href="#PRIVATE_INTERFACE">PRIVATE INTERFACE</a><br />
<ul>
	<li><a href="#FileWriteAtomic">_FileWriteAtomic()</a></li>
	<li><a href="#ConfigurationTranslatableStrings-2">_ConfigurationTranslatableStrings()</a></li>
	<li><a href="#DBCleanUp">_DBCleanUp();</a></li>
	<li><a href="#NavigationTree">_NavigationTree();</a></li>
	<li><a href="#ConfigurationEntitiesGet-2">_ConfigurationEntitiesGet();</a></li>
	<li><a href="#EffectiveValues2PerlFile">_EffectiveValues2PerlFile()</a></li>
	<li><a href="#SettingEffectiveValueCheck-2">_SettingEffectiveValueCheck()</a></li>
	<li><a href="#GetSettingsToDeploy">_GetSettingsToDeploy()</a></li>
	<li><a href="#HandleSettingsToDeploy">_HandleSettingsToDeploy()</a></li>
	<li><a href="#ConfigurationTranslatedGet-2">_ConfigurationTranslatedGet()</a></li>
	<li><a href="#ValueTypesList">_ValueTypesList()</a></li>
</ul>
</li>
	<li><a href="#TERMS_AND_CONDITIONS">TERMS AND CONDITIONS</a></li>
</ul>
<hr />
<!-- INDEX END -->

<h1 id="NAME">NAME <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<p>Kernel::System::SysConfig - Functions to manage system configuration settings.</p>

<h1 id="DESCRIPTION">DESCRIPTION <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<p>All functions to manage system configuration settings.</p>

<h1 id="PUBLIC_INTERFACE">PUBLIC INTERFACE <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<h2 id="new">new()</h2>

<p><a href="#" onclick="toggleCode('method_new');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_new">
                                        <pre>

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    $Self->{ConfigObject} = $Kernel::OM->Get('Kernel::Config');

    # get home directory
    $Self->{Home} = $Self->{ConfigObject}->Get('Home');

    # set utf8 if used
    $Self->{utf8}     = 1;
    $Self->{FileMode} = ':utf8';

    $Self->{ConfigDefaultObject} = Kernel::Config->new( Level => 'Default' );
    $Self->{ConfigObject}        = Kernel::Config->new( Level => 'First' );
    $Self->{ConfigClearObject}   = Kernel::Config->new( Level => 'Clear' );

    # Load base files.
    my $BaseDir = $Self->{Home} . '/Kernel/System/SysConfig/Base/';
    if ( -e $BaseDir ) {
        my $MainObject = $Kernel::OM->Get('Kernel::System::Main');
        my @BaseFiles  = $MainObject->DirectoryRead(
            Directory => $BaseDir,
            Filter    => '*.pm',
        );
        BASEFILE:
        for my $BaseFile (@BaseFiles) {
            $BaseFile =~ s{\A.*\/(.+?).pm\z}{$1}xms;
            my $BaseClassName = "Kernel::System::SysConfig::Base::$BaseFile";
            if ( !$MainObject->RequireBaseClass($BaseClassName) ) {
                $Self->FatalDie(
                    Message => "Could not load class $BaseClassName.",
                );
            }
        }
    }

    return $Self;
}
</pre></div>

<p>Don't use the constructor directly, use the ObjectManager instead:</p>

<pre>    my $SysConfigObject = $Kernel::OM-&gt;Get('Kernel::System::SysConfig');
</pre><h2 id="SettingGet">SettingGet()</h2>

<p><a href="#" onclick="toggleCode('method_SettingGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SettingGet">
                                        <pre>

sub SettingGet {
    my ( $Self, %Param ) = @_;

    # Check needed stuff.
    if ( !$Param{Name} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need Name!',
        );
        return;
    }

    $Param{Translate} //= 0;    # don't translate by default

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    # Get default setting.
    my %Setting = $SysConfigDBObject->DefaultSettingGet(
        Name => $Param{Name},
    );

    # setting was not found
    if ( !%Setting ) {

        # do not log an error if parameter NoLog is true
        if ( !$Param{NoLog} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Setting $Param{Name} is invalid!",
            );
        }

        return;
    }

    $Setting{DefaultValue} = $Setting{EffectiveValue};

    # Return default setting if specified (otherwise continue with modified setting).
    if ( $Param{Default} ) {
        return %Setting;
    }

    # Check if modified setting available
    my %ModifiedSetting;
    if ( $Param{ModifiedID} ) {

        # Get settings with given ModifiedID.
        %ModifiedSetting = $SysConfigDBObject->ModifiedSettingGet(
            ModifiedID => $Param{ModifiedID},
            IsGlobal   => 1,
        );

        # prevent using both parameters.
        $Param{Deployed} = undef;
    }
    else {
        # Get latest modified settings.
        %ModifiedSetting = $SysConfigDBObject->ModifiedSettingGet(
            Name     => $Param{Name},
            IsGlobal => 1,
        );
    }

    if ( $Param{Deployed} ) {

        # get the previous deployed state of this setting
        my %SettingDeployed = $SysConfigDBObject->ModifiedSettingVersionGetLast(
            Name => $Setting{Name},
        );

        if ( !IsHashRefWithData( \%SettingDeployed ) ) {

            # if this setting was never deployed before, get the default state

            # Get default version.
            %SettingDeployed = $SysConfigDBObject->DefaultSettingGet(
                DefaultID => $Setting{DefaultID},
            );
        }

        if ( IsHashRefWithData( \%SettingDeployed ) ) {
            %Setting = (
                %Setting,
                %SettingDeployed
            );
        }
    }

    # default
    $Setting{IsModified} = 0;

    if ( IsHashRefWithData( \%ModifiedSetting ) ) {

        my $IsModified = DataIsDifferent(
            Data1 => \$Setting{EffectiveValue},
            Data2 => \$ModifiedSetting{EffectiveValue},
        ) || 0;

        $IsModified ||= $ModifiedSetting{IsValid} != $Setting{IsValid};
        $IsModified ||= $ModifiedSetting{UserModificationActive} != $Setting{UserModificationActive};

        $Setting{IsModified} = $IsModified ? 1 : 0;

        if ( !$Param{Deployed} ) {

            # Update setting attributes.
            ATTRIBUTE:
            for my $Attribute (
                qw(ModifiedID IsValid UserModificationActive EffectiveValue IsDirty
                CreateTime CreateBy ChangeTime ChangeBy
                )
                )
            {
                next ATTRIBUTE if !defined $ModifiedSetting{$Attribute};

                $Setting{$Attribute} = $ModifiedSetting{$Attribute};
            }
        }
    }

    if ( $Param{Translate} ) {

        if (%ModifiedSetting) {
            $Setting{XMLContentParsed}->{Value} = $Self->SettingModifiedXMLContentParsedGet(
                ModifiedSetting => {
                    EffectiveValue => $Setting{EffectiveValue},
                },
                DefaultSetting => {
                    XMLContentParsed => $Setting{XMLContentParsed},
                },
            );
        }

        # Update EffectiveValue with translated strings
        $Setting{EffectiveValue} = $Self->SettingEffectiveValueGet(
            Value     => $Setting{XMLContentParsed}->{Value},
            Translate => 1,
        );

        $Setting{Description} = $Kernel::OM->Get('Kernel::Language')->Translate(
            $Setting{Description},
        );
    }

    # Return updated default.
    return %Setting;
}
</pre></div>

<p>Get SysConfig setting attributes.</p>

<pre>    my %Setting = $SysConfigObject-&gt;SettingGet(
        Name            =&gt; 'Setting::Name',  # Setting name
        Default         =&gt; 1,                # Returns the default setting attributes only
        ModifiedID      =&gt; '123',            # (optional) Get setting value for given ModifiedID.
        Deployed        =&gt; 1,                # (optional) Get deployed setting value. Default 0.
        Translate       =&gt; 1,                # (optional) Translate translatable strings in EffectiveValue. Default 0.
        NoLog           =&gt; 1,                # (optional) Do not log error if a setting does not exist.
    );
</pre><p>Returns:</p>

<pre>    %Setting = (
        DefaultID                =&gt; 123,
        ModifiedID               =&gt; 456,         # optional
        Name                     =&gt; &quot;ProductName&quot;,
        Description              =&gt; &quot;Defines the name of the application ...&quot;,
        Navigation               =&gt; &quot;ASimple::Path::Structure&quot;,
        IsInvisible              =&gt; 1,           # 1 or 0
        IsReadonly               =&gt; 0,           # 1 or 0
        IsRequired               =&gt; 1,           # 1 or 0
        IsModified               =&gt; 1,           # 1 or 0
        IsValid                  =&gt; 1,           # 1 or 0
        HasConfigLevel           =&gt; 200,
        UserModificationPossible =&gt; 0,           # 1 or 0
        UserModificationActive   =&gt; 0,           # 1 or 0
        UserPreferencesGroup     =&gt; 'Advanced',  # optional
        XMLContentRaw            =&gt; &quot;The XML structure as it is on the config file&quot;,
        XMLContentParsed         =&gt; &quot;XML parsed to Perl&quot;,
        XMLFilename              =&gt; &quot;Framework.xml&quot;,
        EffectiveValue           =&gt; &quot;Product 6&quot;,
        IsDirty                  =&gt; 1,           # 1 or 0
        ExclusiveLockGUID        =&gt; 'A32CHARACTERLONGSTRINGFORLOCKING',
        ExclusiveLockUserID      =&gt; 1,
        ExclusiveLockExpiryTime  =&gt; '2016-05-29 11:09:04',
        CreateTime               =&gt; &quot;2016-05-29 11:04:04&quot;,
        CreateBy                 =&gt; 1,
        ChangeTime               =&gt; &quot;2016-05-29 11:04:04&quot;,
        ChangeBy                 =&gt; 1,
        DefaultValue             =&gt; 'Old default value',
    );
</pre><h2 id="SettingUpdate">SettingUpdate()</h2>

<p><a href="#" onclick="toggleCode('method_SettingUpdate');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SettingUpdate">
                                        <pre>

sub SettingUpdate {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(Name ExclusiveLockGUID UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!",
            );

            return;
        }
    }

    my %Result = (
        Success => 1,
    );

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    # Get default setting
    my %Setting = $SysConfigDBObject->DefaultSettingGet(
        Name => $Param{Name},
    );

    # Make sure that required settings can't be disabled.
    if ( $Setting{IsRequired} ) {
        $Param{IsValid} = 1;
    }

    # Return if setting does not exists.
    if ( !%Setting ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Setting $Param{Name} does not exists!",
        );

        %Result = (
            Success => 0,
            Error   => $Kernel::OM->Get('Kernel::Language')->Translate(
                "Setting %s does not exists!",
                $Param{Name},
            ),
        );
        return %Result;
    }

    # Default should be locked.
    my $LockedByUser = $SysConfigDBObject->DefaultSettingIsLockedByUser(
        DefaultID           => $Setting{DefaultID},
        ExclusiveLockUserID => $Param{UserID},
        ExclusiveLockGUID   => $Param{ExclusiveLockGUID},
    );

    if ( !$LockedByUser ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Setting $Param{Name} is not locked to this user!",
        );

        %Result = (
            Success => 0,
            Error   => $Kernel::OM->Get('Kernel::Language')->Translate(
                "Setting %s is not locked to this user!",
                $Param{Name},
            ),
        );
        return %Result;
    }

    # Do not perform EffectiveValueCheck if user wants to disable the setting.
    if ( $Param{IsValid} ) {

        # Effective value must match in structure to the default and individual values should be
        #   valid according to its value types.
        my %EffectiveValueCheck = $Self->SettingEffectiveValueCheck(
            XMLContentParsed => $Setting{XMLContentParsed},
            EffectiveValue   => $Param{EffectiveValue},
            NoValidation     => $Param{NoValidation} //= 0,
            UserID           => $Param{UserID},
        );

        if ( !$EffectiveValueCheck{Success} ) {
            my $Error = $EffectiveValueCheck{Error} || 'Unknown error!';

            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "EffectiveValue is invalid! $Error",
            );

            %Result = (
                Success => 0,
                Error   => $Kernel::OM->Get('Kernel::Language')->Translate(
                    "Setting value is not valid!",
                ),
            );
            return %Result;
        }
    }

    # Get modified setting (if any).
    my %ModifiedSetting = $SysConfigDBObject->ModifiedSettingGet(
        Name     => $Param{Name},
        IsGlobal => 1,
    );

    if ( !defined $Param{EffectiveValue} ) {

        # In the case that we want only to enable/disable setting,
        #    old effective value will be preserved.
        $Param{EffectiveValue} = $ModifiedSetting{EffectiveValue} // $Setting{EffectiveValue};
    }

    my $UserModificationActive = $Setting{UserModificationActive};

    # Add new modified setting (if there wasn't).
    if ( !%ModifiedSetting ) {

        # Check if provided EffectiveValue is same as in Default
        my $IsDifferent = DataIsDifferent(
            Data1 => \$Setting{EffectiveValue},
            Data2 => \$Param{EffectiveValue},
        ) || 0;

        if ( defined $Param{IsValid} ) {
            $IsDifferent ||= $Setting{IsValid} != $Param{IsValid};
        }
        if ($IsDifferent) {

            my $ModifiedID = $SysConfigDBObject->ModifiedSettingAdd(
                DefaultID              => $Setting{DefaultID},
                Name                   => $Setting{Name},
                IsValid                => $Param{IsValid} //= $Setting{IsValid},
                EffectiveValue         => $Param{EffectiveValue},
                UserModificationActive => $UserModificationActive,
                ExclusiveLockGUID      => $Param{ExclusiveLockGUID},
                UserID                 => $Param{UserID},
            );
            if ( !$ModifiedID ) {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message  => "Could not add modified setting!",
                );
                %Result = (
                    Success => 0,
                    Error   => $Kernel::OM->Get('Kernel::Language')->Translate(
                        "Could not add modified setting!",
                    ),
                );
                return %Result;
            }
        }
    }
    else {

        # Check if provided EffectiveValue is same as in last modified EffectiveValue
        my $IsDifferent = DataIsDifferent(
            Data1 => \$ModifiedSetting{EffectiveValue},
            Data2 => \$Param{EffectiveValue},
        ) || 0;

        if ( defined $Param{IsValid} ) {
            $IsDifferent ||= $ModifiedSetting{IsValid} != $Param{IsValid};
        }

        if ($IsDifferent) {

            my %ModifiedSettingVersion = $SysConfigDBObject->ModifiedSettingVersionGetLast(
                Name => $ModifiedSetting{Name},
            );

            my $EffectiveValueModifiedSinceDeployment = 1;
            if ( $ModifiedSettingVersion{ModifiedVersionID} ) {

                my %ModifiedSettingLastDeployed = $SysConfigDBObject->ModifiedSettingVersionGet(
                    ModifiedVersionID => $ModifiedSettingVersion{ModifiedVersionID},
                );

                $EffectiveValueModifiedSinceDeployment = DataIsDifferent(
                    Data1 => \$ModifiedSettingLastDeployed{EffectiveValue},
                    Data2 => \$Param{EffectiveValue},
                ) || 0;

                if ( defined $Param{IsValid} ) {
                    $EffectiveValueModifiedSinceDeployment ||= $ModifiedSettingLastDeployed{IsValid} != $Param{IsValid};
                }

            }
            elsif ( !IsHashRefWithData( \%ModifiedSettingVersion ) ) {
                $EffectiveValueModifiedSinceDeployment = DataIsDifferent(
                    Data1 => \$Setting{EffectiveValue},
                    Data2 => \$Param{EffectiveValue},
                ) || 0;

                if ( defined $Param{IsValid} ) {
                    $EffectiveValueModifiedSinceDeployment ||= $Setting{IsValid} != $Param{IsValid};
                }
            }

            # Update the existing modified setting.
            my $Success = $SysConfigDBObject->ModifiedSettingUpdate(
                ModifiedID             => $ModifiedSetting{ModifiedID},
                DefaultID              => $Setting{DefaultID},
                Name                   => $Setting{Name},
                IsValid                => $Param{IsValid} //= $ModifiedSetting{IsValid},
                EffectiveValue         => $Param{EffectiveValue},
                UserModificationActive => $UserModificationActive,
                ExclusiveLockGUID      => $Param{ExclusiveLockGUID},
                UserID                 => $Param{UserID},
                IsDirty                => $EffectiveValueModifiedSinceDeployment ? 1 : 0,
            );
            if ( !$Success ) {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message  => "Could not update modified setting!",
                );
                %Result = (
                    Success => 0,
                    Error   => $Kernel::OM->Get('Kernel::Language')->Translate(
                        "Could not update modified setting!",
                    ),
                );
                return %Result;
            }
        }
    }

    # Unlock setting so it can be locked again afterwards.
    my $Success = $SysConfigDBObject->DefaultSettingUnlock(
        DefaultID => $Setting{DefaultID},
    );
    if ( !$Success ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Setting could not be unlocked!",
        );
        %Result = (
            Success => 0,
            Error   => $Kernel::OM->Get('Kernel::Language')->Translate(
                "Setting could not be unlocked!",
            ),
        );
        return %Result;
    }

    return %Result;
}
</pre></div>

<p>Update an existing SysConfig Setting.</p>

<pre>    my %Result = $SysConfigObject-&gt;SettingUpdate(
        Name                   =&gt; 'Setting::Name',           # (required) setting name
        IsValid                =&gt; 1,                         # (optional) 1 or 0, modified 0
        EffectiveValue         =&gt; $SettingEffectiveValue,    # (optional)
        UserModificationActive =&gt; 0,                         # (optional) 1 or 0, modified 0
        ExclusiveLockGUID      =&gt; $LockingString,            # the GUID used to locking the setting
        UserID                 =&gt; 1,                         # (required) UserID
        NoValidation           =&gt; 1,                         # (optional) no value type validation.
    );
</pre><p>Returns:</p>

<pre>    %Result = (
        Success =&gt; 1,        # or false in case of an error
        Error   =&gt; undef,    # error message
    );
</pre><h2 id="SettingLock">SettingLock()</h2>

<p><a href="#" onclick="toggleCode('method_SettingLock');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SettingLock">
                                        <pre>

sub SettingLock {
    my ( $Self, %Param ) = @_;

    return $Kernel::OM->Get('Kernel::System::SysConfig::DB')->DefaultSettingLock(%Param);
}
</pre></div>

<p>Lock setting(s) to the particular user.</p>

<pre>    my $ExclusiveLockGUID = $SysConfigObject-&gt;SettingLock(
        DefaultID =&gt; 1,                     # the ID of the setting that needs to be locked
                                            #    or
        Name      =&gt; 'SettingName',         # the Name of the setting that needs to be locked
                                            #    or
        LockAll   =&gt; 1,                     # system locks all settings
        Force     =&gt; 1,                     # (optional) Force locking (do not check if it's already locked by another user). Default: 0.
        UserID    =&gt; 1,
    );
</pre><p>Returns:</p>

<pre>    $ExclusiveLockGUID = 'azzHab72wIlAXDrxHexsI5aENsESxAO7';     # Setting locked

    or

    $ExclusiveLockGUID = undef;     # Not locked
</pre><h2 id="SettingUnlock">SettingUnlock()</h2>

<p><a href="#" onclick="toggleCode('method_SettingUnlock');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SettingUnlock">
                                        <pre>

sub SettingUnlock {
    my ( $Self, %Param ) = @_;

    return $Kernel::OM->Get('Kernel::System::SysConfig::DB')->DefaultSettingUnlock(%Param);
}
</pre></div>

<p>Unlock particular or all Setting(s).</p>

<pre>    my $Success = $SysConfigObject-&gt;SettingUnlock(
        DefaultID =&gt; 1,                     # the ID of the setting that needs to be unlocked
                                            #   or
        Name      =&gt; 'SettingName',         # the name of the setting that needs to be locked
                                            #   or
        UnlockAll =&gt; 1,                     # unlock all settings
    );
</pre><p>Returns:</p>

<pre>    $Success = 1;
</pre><h2 id="SettingLockCheck">SettingLockCheck()</h2>

<p><a href="#" onclick="toggleCode('method_SettingLockCheck');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SettingLockCheck">
                                        <pre>

sub SettingLockCheck {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(DefaultID ExclusiveLockGUID ExclusiveLockUserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!",
            );
            return;
        }
    }

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    my %Result = (
        Locked => 0,
    );

    my $LockedByUser = $SysConfigDBObject->DefaultSettingIsLockedByUser(
        DefaultID           => $Param{DefaultID},
        ExclusiveLockUserID => $Param{ExclusiveLockUserID},
        ExclusiveLockGUID   => $Param{ExclusiveLockGUID},
    );

    if ($LockedByUser) {

        # setting locked to the provided user
        $Result{Locked} = 2;
    }
    else {
        # check if setting is locked to another user
        my $UserID = $SysConfigDBObject->DefaultSettingIsLocked(
            DefaultID     => $Param{DefaultID},
            GetLockUserID => 1,
        );

        if ($UserID) {

            # get user data
            $Result{Locked} = 1;

            my %User = $Kernel::OM->Get('Kernel::System::User')->GetUserData(
                UserID => $UserID,
            );

            $Result{User} = \%User;
        }
    }

    return %Result;
}
</pre></div>

<p>Check setting lock status.</p>

<pre>    my %Result = $SysConfigObject-&gt;SettingLockCheck(
        DefaultID           =&gt; 1,                     # the ID of the setting that needs to be checked
        ExclusiveLockGUID   =&gt; 1,                     # lock GUID
        ExclusiveLockUserID =&gt; 1,                     # UserID
    );
</pre><p>Returns:</p>

<pre>    %Result = (
        Locked =&gt; 1,                        # lock status;
                                            # 0 - unlocked
                                            # 1 - locked to another user
                                            # 2 - locked to provided user
        User   =&gt; {                         # User data, provided only if Locked = 1
            UserLogin =&gt; ...,
            UserFirstname =&gt; ...,
            UserLastname =&gt; ...,
            ...
        },
    );
</pre><h2 id="SettingEffectiveValueGet">SettingEffectiveValueGet()</h2>

<p><a href="#" onclick="toggleCode('method_SettingEffectiveValueGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SettingEffectiveValueGet">
                                        <pre>

sub SettingEffectiveValueGet {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(Value)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!",
            );
            return;
        }
    }

    my %ForbiddenValueTypes = %{ $Self->{ForbiddenValueTypes} || {} };

    if ( !%ForbiddenValueTypes ) {
        %ForbiddenValueTypes = $Self->ForbiddenValueTypesGet();
        $Self->{ForbiddenValueTypes} = \%ForbiddenValueTypes;
    }

    $Param{Translate} //= 0;

    my $Result;

    my %Objects;
    if ( $Param{Objects} ) {
        %Objects = %{ $Param{Objects} };
    }

    # Make sure structure is correct.
    return $Result if !IsArrayRefWithData( $Param{Value} );
    return $Result if !IsHashRefWithData( $Param{Value}->[0] );

    my %Attributes;

    if ( $Param{Value}->[0]->{Item} ) {

        # Make sure structure is correct.
        return $Result if !IsArrayRefWithData( $Param{Value}->[0]->{Item} );
        return $Result if !IsHashRefWithData( $Param{Value}->[0]->{Item}->[0] );

        # Set default ValueType.
        my $ValueType = "String";

        if ( $Param{Value}->[0]->{Item}->[0]->{ValueType} ) {
            $ValueType = $Param{Value}->[0]->{Item}->[0]->{ValueType};
        }

        if ( !$Objects{$ValueType} ) {

            # Make sure value type backend is available and syntactically correct.
            my $Loaded = $Kernel::OM->Get('Kernel::System::Main')->Require(
                "Kernel::System::SysConfig::ValueType::$ValueType",
            );

            return $Result if !$Loaded;

            $Objects{$ValueType} = $Kernel::OM->Get(
                "Kernel::System::SysConfig::ValueType::$ValueType",
            );
        }

        # Create a local clone of the value to prevent any modification.
        my $Value = $Kernel::OM->Get('Kernel::System::Storable')->Clone(
            Data => $Param{Value}->[0]->{Item},
        );

        $Result = $Objects{$ValueType}->EffectiveValueGet(
            Value     => $Value,
            Translate => $Param{Translate},
        );
    }
    elsif ( $Param{Value}->[0]->{Hash} ) {

        # Make sure structure is correct.
        return {} if !IsArrayRefWithData( $Param{Value}->[0]->{Hash} );
        return {} if !IsHashRefWithData( $Param{Value}->[0]->{Hash}->[0] );
        return {} if !IsArrayRefWithData( $Param{Value}->[0]->{Hash}->[0]->{Item} );

        # Check for additional attributes in the DefaultItem.
        if (
            $Param{Value}->[0]->{Hash}->[0]->{DefaultItem}
            && ref $Param{Value}->[0]->{Hash}->[0]->{DefaultItem} eq 'ARRAY'
            && scalar $Param{Value}->[0]->{Hash}->[0]->{DefaultItem}
            && ref $Param{Value}->[0]->{Hash}->[0]->{DefaultItem}->[0] eq 'HASH'
            )
        {
            %Attributes = ();

            my @ValueAttributeList = $Self->ValueAttributeList();

            ATTRIBUTE:
            for my $Attribute ( sort keys %{ $Param{Value}->[0]->{Hash}->[0]->{DefaultItem}->[0] } ) {
                if (
                    ( grep { $_ eq $Attribute } qw (Array Hash) )
                    && $Param{Value}->[0]->{Hash}->[0]->{DefaultItem}->[0]->{$Attribute}->[0]->{DefaultItem}
                    )
                {
                    $Attributes{DefaultItem}
                        = $Param{Value}->[0]->{Hash}->[0]->{DefaultItem}->[0]->{$Attribute}->[0]->{DefaultItem};
                }
                next ATTRIBUTE if grep { $Attribute eq $_ } ( qw (Array Hash), @ValueAttributeList );

                if (
                    $Param{Value}->[0]->{Hash}->[0]->{DefaultItem}->[0]->{Item}
                    && $Param{Value}->[0]->{Hash}->[0]->{DefaultItem}->[0]->{ValueType}
                    )
                {
                    my $DefaultItemValueType = $Param{Value}->[0]->{Hash}->[0]->{DefaultItem}->[0]->{ValueType};
                    if ( $ForbiddenValueTypes{$DefaultItemValueType} ) {
                        my $SubValueType
                            = $Param{Value}->[0]->{Hash}->[0]->{DefaultItem}->[0]->{Item}->[0]->{ValueType};

                        if ( !grep { $_ eq $SubValueType } @{ $ForbiddenValueTypes{$DefaultItemValueType} } ) {
                            next ATTRIBUTE;
                        }
                    }
                }

                $Attributes{$Attribute} = $Param{Value}->[0]->{Hash}->[0]->{DefaultItem}->[0]->{$Attribute};
            }
        }

        ITEM:
        for my $Item ( @{ $Param{Value}->[0]->{Hash}->[0]->{Item} } ) {

            next ITEM if !IsHashRefWithData($Item);
            next ITEM if !defined $Item->{Key};

            if ( $Item->{Hash} || $Item->{Array} ) {

                my $ItemKey = $Item->{Hash} ? 'Hash' : 'Array';

                ATTRIBUTE:
                for my $Attribute ( sort keys %Attributes ) {
                    next ATTRIBUTE if defined $Item->{$Attribute};    # skip redefined values

                    $Item->{$ItemKey}->[0]->{$Attribute} = $Attributes{$Attribute};
                }

                my $Value = $Self->SettingEffectiveValueGet(
                    Value     => [$Item],
                    Objects   => \%Objects,
                    Translate => $Param{Translate},
                );

                $Result->{ $Item->{Key} } = $Value;
            }
            elsif ( $Attributes{ValueType} || $Item->{ValueType} ) {

                # Create a local clone of the item to prevent any modification.
                my $Clone = $Kernel::OM->Get('Kernel::System::Storable')->Clone(
                    Data => $Item,
                );

                ATTRIBUTE:
                for my $Attribute ( sort keys %Attributes ) {
                    next ATTRIBUTE if defined $Clone->{$Attribute};    # skip redefined values

                    $Clone->{$Attribute} = $Attributes{$Attribute};
                }

                my $Value = $Self->SettingEffectiveValueGet(
                    Value => [
                        {
                            Item => [$Clone],
                        },
                    ],
                    Objects   => \%Objects,
                    Translate => $Param{Translate},
                );

                $Result->{ $Item->{Key} } = $Value;
            }
            else {

                $Item->{Content} //= '';

                # Remove empty space at start and the end (with new lines).
                $Item->{Content} =~ s{^\n\s*(.*?)\n\s*$}{$1}gsmx;

                $Result->{ $Item->{Key} } = $Item->{Content};
            }
        }
    }
    elsif ( $Param{Value}->[0]->{Array} ) {

        # Make sure structure is correct
        return [] if !IsArrayRefWithData( $Param{Value}->[0]->{Array} );
        return [] if !IsHashRefWithData( $Param{Value}->[0]->{Array}->[0] );
        return [] if !IsArrayRefWithData( $Param{Value}->[0]->{Array}->[0]->{Item} );

        # Check for additional attributes in the DefaultItem.
        if (
            $Param{Value}->[0]->{Array}->[0]->{DefaultItem}
            && ref $Param{Value}->[0]->{Array}->[0]->{DefaultItem} eq 'ARRAY'
            && scalar $Param{Value}->[0]->{Array}->[0]->{DefaultItem}
            && ref $Param{Value}->[0]->{Array}->[0]->{DefaultItem}->[0] eq 'HASH'
            )
        {
            %Attributes = ();

            ATTRIBUTE:
            for my $Attribute ( sort keys %{ $Param{Value}->[0]->{Array}->[0]->{DefaultItem}->[0] } ) {
                if (
                    ( grep { $_ eq $Attribute } qw (Array Hash) )
                    && $Param{Value}->[0]->{Array}->[0]->{DefaultItem}->[0]->{$Attribute}->[0]->{DefaultItem}
                    )
                {
                    $Attributes{DefaultItem}
                        = $Param{Value}->[0]->{Array}->[0]->{DefaultItem}->[0]->{$Attribute}->[0]->{DefaultItem};
                }
                next ATTRIBUTE if grep { $Attribute eq $_ } qw (Array Hash Content SelectedID);

                $Attributes{$Attribute} = $Param{Value}->[0]->{Array}->[0]->{DefaultItem}->[0]->{$Attribute};
            }
        }

        my @Items;

        ITEM:
        for my $Item ( @{ $Param{Value}->[0]->{Array}->[0]->{Item} } ) {
            next ITEM if !IsHashRefWithData($Item);

            if ( $Item->{Hash} || $Item->{Array} ) {
                my $ItemKey = $Item->{Hash} ? 'Hash' : 'Array';

                ATTRIBUTE:
                for my $Attribute ( sort keys %Attributes ) {
                    next ATTRIBUTE if defined $Item->{$Attribute};    # skip redefined values

                    $Item->{$ItemKey}->[0]->{$Attribute} = $Attributes{$Attribute};
                }

                my $Value = $Self->SettingEffectiveValueGet(
                    Value     => [$Item],
                    Objects   => \%Objects,
                    Translate => $Param{Translate},
                );

                push @Items, $Value;
            }
            elsif ( $Attributes{ValueType} ) {

                # Create a local clone of the item to prevent any modification.
                my $Clone = $Kernel::OM->Get('Kernel::System::Storable')->Clone(
                    Data => $Item,
                );

                ATTRIBUTE:
                for my $Attribute ( sort keys %Attributes ) {
                    next ATTRIBUTE if defined $Clone->{$Attribute};    # skip redefined values

                    $Clone->{$Attribute} = $Attributes{$Attribute};
                }

                my $Value = $Self->SettingEffectiveValueGet(
                    Value => [
                        {
                            Item => [$Clone],
                        },
                    ],
                    Objects   => \%Objects,
                    Translate => $Param{Translate},
                );

                push @Items, $Value;
            }
            else {
                $Item->{Content} //= '';

                # Remove empty space at start and the end (with new lines).
                $Item->{Content} =~ s{^\n\s*(.*?)\n\s*$}{$1}gsmx;

                push @Items, $Item->{Content};
            }
        }
        $Result = \@Items;
    }

    return $Result;
}
</pre></div>

<p>Calculate effective value for a given parsed XML structure.</p>

<pre>    my $Result = $SysConfigObject-&gt;SettingEffectiveValueGet(
        Translate =&gt; 1,                      # (optional) Translate translatable strings. Default 0.
        Value  =&gt; [                          # (required) parsed XML structure
          {
            'Item' =&gt; [
                {
                    'ValueType' =&gt; 'String',
                    'Content' =&gt; '3600',
                    'ValueRegex' =&gt; ''
                },
            ],
          },
        Objects =&gt; {
            Select =&gt; { ... },
            PerlModule =&gt; { ... },
            ...
        }
        ];
    );
</pre><p>Returns:</p>

<pre>    $Result = '3600';
</pre><h2 id="SettingRender">SettingRender()</h2>

<p><a href="#" onclick="toggleCode('method_SettingRender');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SettingRender">
                                        <pre>

sub SettingRender {
    my ( $Self, %Param ) = @_;

    return $Kernel::OM->Get('Kernel::Output::HTML::SysConfig')->SettingRender(%Param);
}
</pre></div>

<p>Wrapper for Kernel::Output::HTML::SysConfig::SettingRender() - Returns the specific HTML for the setting.</p>

<pre>    my $HTMLStr = $SysConfigObject-&gt;SettingRender(
        Setting   =&gt; {
            Name             =&gt; 'Setting Name',
            XMLContentParsed =&gt; $XMLParsedToPerl,
            EffectiveValue   =&gt; &quot;Product 6&quot;,        # or a complex structure
            DefaultValue     =&gt; &quot;Product 5&quot;,        # or a complex structure
            IsAjax           =&gt; 1,                  # (optional) is ajax request. Default 0.
            # ...
        },
        RW =&gt; 1,                                    # (optional) Allow editing. Default 0.
    );
</pre><p>Returns:</p>

<pre>    $HTMLStr = '&lt;div class=&quot;Setting&quot;&gt;&lt;div class &quot;Field&quot;...&lt;/div&gt;&lt;/div&gt;'        # or false in case of an error
</pre><h2 id="SettingAddItem">SettingAddItem()</h2>

<p><a href="#" onclick="toggleCode('method_SettingAddItem');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SettingAddItem">
                                        <pre>

sub SettingAddItem {
    my ( $Self, %Param ) = @_;

    return $Kernel::OM->Get('Kernel::Output::HTML::SysConfig')->SettingAddItem(%Param);
}
</pre></div>

<p>Wrapper for Kernel::Output::HTML::SysConfig::SettingAddItem() - Returns response that is sent when user adds new array/hash item.</p>

<pre>    my %Result = $SysConfigObject-&gt;SettingAddItem(
        SettingStructure  =&gt; [],         # (required) array that contains structure
                                         #  where a new item should be inserted (can be empty)
        Setting           =&gt; {           # (required) Setting hash (from SettingGet())
            'DefaultID' =&gt; '8905',
            'DefaultValue' =&gt; [ 'Item 1', 'Item 2' ],
            'Description' =&gt; 'Simple array item(Min 1, Max 3).',
            'Name' =&gt; 'TestArray',
            ...
        },
        Key               =&gt; 'HashKey',  # (optional) hash key
        IDSuffix          =&gt; '_Array3,   # (optional) suffix that will be added to all input/select fields
                                         #    (it is used in the JS on Update, during EffectiveValue calculation)
        Value             =&gt; [           # (optional) Perl structure
            {
                'Array' =&gt; [
                    'Item' =&gt; [
                        {
                        'Content' =&gt; 'Item 1',
                        },
                        ...
                    ],
                ],
            },
        ],
        AddSettingContent =&gt; 0,          # (optional) if enabled, result will be inside of div with class &quot;SettingContent&quot;
    );
</pre><p>Returns:</p>

<pre>    %Result = (
        'Item' =&gt; '&lt;div class=\'SettingContent\'&gt;
&lt;input type=\'text\' id=\'TestArray_Array4\'
        value=\'Default value\' name=\'TestArray\' class=\' Entry\'/&gt;&lt;/div&gt;',
    );

    or

    %Result = (
        'Error' =&gt; 'Error description',
    );
</pre><h2 id="SettingsUpdatedList">SettingsUpdatedList()</h2>

<p><a href="#" onclick="toggleCode('method_SettingsUpdatedList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SettingsUpdatedList">
                                        <pre>

sub SettingsUpdatedList {
    my ( $Self, %Param ) = @_;

    # Check needed stuff.
    for my $Needed (qw(Settings UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!",
            );
            return;
        }
    }

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    my @Result;

    SETTING:
    for my $Setting ( @{ $Param{Settings} } ) {
        next SETTING if !IsHashRefWithData($Setting);

        my %SettingData = $Self->SettingGet(
            Name => $Setting->{SettingName},
        );

        my $LockedUserID = $SysConfigDBObject->DefaultSettingIsLocked(
            Name          => $Setting->{SettingName},
            GetLockUserID => 1,
        );

        my $IsLockedByAnotherUser = $LockedUserID ? 1 : 0;

        # Skip if setting was locked by current user during AJAX call.
        next SETTING if $LockedUserID == $Param{UserID};

        my $Updated = $SettingData{ChangeTime} ne $Setting->{ChangeTime};
        $Updated ||= $IsLockedByAnotherUser != $Setting->{IsLockedByAnotherUser};

        $Setting->{IsLockedByAnotherUser} = $IsLockedByAnotherUser;

        next SETTING if !$Updated;

        push @Result, $Setting;
    }

    return @Result;
}
</pre></div>

<p>Checks which settings has been updated from provided Setting list and returns updated values.</p>

<pre>    my @List = $SysConfigObject-&gt;SettingsUpdatedList(
        Settings =&gt; [                                               # (required) List of settings that needs to be checked
            {
                SettingName           =&gt; 'SettingName',
                ChangeTime            =&gt; '2017-01-13 11:23:07',
                IsLockedByAnotherUser =&gt; 0,
            },
            ...
        ],
        UserID =&gt; 1,                                                # (required) Current user id
    );
</pre><p>Returns:</p>

<pre>    @List = [
        {
            ChangeTime            =&gt; '2017-01-07 11:29:38',
            IsLockedByAnotherUser =&gt; 1,
            IsModified            =&gt; 1,
            SettingName           =&gt; 'SettingName',
        },
        ...
    ];
</pre><h2 id="SettingEffectiveValueCheck">SettingEffectiveValueCheck()</h2>

<p><a href="#" onclick="toggleCode('method_SettingEffectiveValueCheck');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SettingEffectiveValueCheck">
                                        <pre>

sub SettingEffectiveValueCheck {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(XMLContentParsed UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!"
            );
            return;
        }
    }

    $Param{EffectiveValue} //= '';
    $Param{NoValidation}   //= 0;

    my %Result = (
        Success => 0,
    );

    my %Parameters = %{ $Param{Parameters} || {} };
    my $Value = $Param{XMLContentParsed}->{Value};

    if ( $Value->[0]->{Item} || $Value->[0]->{ValueType} ) {

        # get ValueType from parent or use default
        my $ValueType = $Parameters{ValueType} || 'String';

        # ValueType is defined explicitly(override parent definition)
        if (
            $Value->[0]->{Item}
            && $Value->[0]->{Item}->[0]->{ValueType}
            )
        {
            $ValueType = $Value->[0]->{Item}->[0]->{ValueType};
        }

        my %ForbiddenValueTypes = %{ $Self->{ForbiddenValueTypes} || {} };

        if ( !%ForbiddenValueTypes ) {
            %ForbiddenValueTypes = $Self->ForbiddenValueTypesGet();
            $Self->{ForbiddenValueTypes} = \%ForbiddenValueTypes;
        }

        my @SkipValueTypes;

        for my $Item ( sort keys %ForbiddenValueTypes ) {
            if ( !grep { $_ eq $ForbiddenValueTypes{$Item} } @SkipValueTypes ) {
                push @SkipValueTypes, @{ $ForbiddenValueTypes{$Item} };
            }
        }

        if (
            $Param{NoValidation}
            || grep { $_ eq $ValueType } @SkipValueTypes
            )
        {
            $Result{Success}        = 1;
            $Result{EffectiveValue} = $Param{EffectiveValue};
            return %Result;
        }

        my $Loaded = $Kernel::OM->Get('Kernel::System::Main')->Require(
            "Kernel::System::SysConfig::ValueType::$ValueType",
        );

        if ( !$Loaded ) {
            $Result{Error} = "Kernel::System::SysConfig::ValueType::$ValueType";
            return %Result;
        }

        my $BackendObject = $Kernel::OM->Get(
            "Kernel::System::SysConfig::ValueType::$ValueType",
        );

        %Result = $BackendObject->SettingEffectiveValueCheck(%Param);
        $Param{EffectiveValue} = $Result{EffectiveValue} if $Result{Success};
    }
    elsif ( $Value->[0]->{Hash} ) {

        if ( ref $Param{EffectiveValue} ne 'HASH' ) {
            $Result{Error} = 'Its not a hash!';
            return %Result;
        }

        PARAMETER:
        for my $Parameter ( sort keys %{ $Value->[0]->{Hash}->[0] } ) {

            next PARAMETER if !grep { $_ eq $Parameter } qw(MinItems MaxItems);

            $Parameters{$Parameter} = $Value->[0]->{Hash}->[0]->{$Parameter} || '';
        }

        if ( $Parameters{MinItems} && $Parameters{MinItems} > keys %{ $Param{EffectiveValue} } ) {
            $Result{Error} = "Number of items in hash is less than MinItems($Parameters{MinItems})!";
            return %Result;
        }

        if ( $Parameters{MaxItems} && $Parameters{MaxItems} < keys %{ $Param{EffectiveValue} } ) {
            $Result{Error} = "Number of items in hash is more than MaxItems($Parameters{MaxItems})!";
            return %Result;
        }

        my @Items = ();

        if (
            scalar @{ $Value->[0]->{Hash} }
            && $Value->[0]->{Hash}->[0]->{Item}
            && ref $Value->[0]->{Hash}->[0]->{Item} eq 'ARRAY'
            )
        {
            @Items = @{ $Value->[0]->{Hash}->[0]->{Item} };
        }

        my $DefaultItem;

        KEY:
        for my $Key ( sort keys %{ $Param{EffectiveValue} } ) {
            $DefaultItem = $Value->[0]->{Hash}->[0]->{DefaultItem};

            if ( $Value->[0]->{Hash}->[0]->{Item} ) {
                my @ItemWithSameKey = grep { $Key eq ( $Value->[0]->{Hash}->[0]->{Item}->[$_]->{Key} || '' ) }
                    0 .. scalar @{ $Value->[0]->{Hash}->[0]->{Item} };
                if ( scalar @ItemWithSameKey ) {
                    $DefaultItem = [
                        $Value->[0]->{Hash}->[0]->{Item}->[ $ItemWithSameKey[0] ],
                    ];
                }

                my $StructureType;
                if ( $DefaultItem->[0]->{Array} ) {
                    $StructureType = 'Array';
                }
                elsif ( $DefaultItem->[0]->{Hash} ) {
                    $StructureType = 'Hash';
                }

                # check if default item is defined in this sub-structure
                if (
                    $StructureType
                    && !$DefaultItem->[0]->{$StructureType}->[0]->{DefaultItem}
                    && $Value->[0]->{Hash}->[0]->{DefaultItem}
                    && $Value->[0]->{Hash}->[0]->{DefaultItem}->[0]->{$StructureType}
                    && $Value->[0]->{Hash}->[0]->{DefaultItem}->[0]->{$StructureType}->[0]->{DefaultItem}
                    )
                {
                    # Default Item is not defined here, but it's defined in previous call.
                    $DefaultItem->[0]->{$StructureType}->[0]->{DefaultItem} =
                        $Value->[0]->{Hash}->[0]->{DefaultItem}->[0]->{$StructureType}->[0]->{DefaultItem};
                }
            }

            my $Ref = ref $Param{EffectiveValue}->{$Key};

            if ($Ref) {

                if ( IsArrayRefWithData($DefaultItem) ) {

                    my $KeyNeeded;

                    if ( $Ref eq 'HASH' ) {
                        $KeyNeeded = 'Hash';
                    }
                    elsif ( $Ref eq 'ARRAY' ) {
                        $KeyNeeded = 'Array';
                    }
                    else {
                        $Result{Error} = "Wrong format!";
                        last KEY;
                    }

                    if ( $DefaultItem->[0]->{Item} ) {

                        # So far everything is OK, we need to check deeper (recursive).
                        my %SubResult = $Self->_SettingEffectiveValueCheck(
                            XMLContentParsed => {
                                Value => $DefaultItem,
                            },
                            EffectiveValue => $Param{EffectiveValue}->{$Key},
                            NoValidation   => $Param{NoValidation},
                            UserID         => $Param{UserID},
                        );
                        $Param{EffectiveValue}->{$Key} = $SubResult{EffectiveValue} if $SubResult{Success};

                        if ( $SubResult{Error} ) {
                            %Result = %SubResult;
                            last KEY;
                        }
                    }
                    elsif ( !defined $DefaultItem->[0]->{$KeyNeeded} ) {
                        my $ExpectedText = '';

                        if ( $DefaultItem->[0]->{Array} ) {
                            $ExpectedText = "an array reference!";
                        }
                        elsif ( $DefaultItem->[0]->{Hash} ) {
                            $ExpectedText = "a hash reference!";
                        }
                        else {
                            $ExpectedText = "a scalar!";
                        }

                        $Result{Error} = "Item with key $Key must be $ExpectedText";
                        last KEY;
                    }
                    else {

                        # So far everything is OK, we need to check deeper (recursive).
                        my %SubResult = $Self->_SettingEffectiveValueCheck(
                            XMLContentParsed => {
                                Value => $DefaultItem,
                            },
                            EffectiveValue => $Param{EffectiveValue}->{$Key},
                            NoValidation   => $Param{NoValidation},
                            UserID         => $Param{UserID},
                        );
                        $Param{EffectiveValue}->{$Key} = $SubResult{EffectiveValue} if $SubResult{Success};

                        if ( $SubResult{Error} ) {
                            %Result = %SubResult;
                            last KEY;
                        }
                    }
                }
                else {
                    # Hash is empty in the Defaults, value should be scalar.
                    $Result{Error} = "Item with key $Key must be a scalar!";
                    last KEY;
                }
            }
            else {

                # scalar value
                if ( IsArrayRefWithData($DefaultItem) ) {
                    if ( $DefaultItem->[0]->{Item} || $DefaultItem->[0]->{Content} ) {

                        # So far everything is OK, we need to check deeper (recursive).
                        my %SubResult = $Self->_SettingEffectiveValueCheck(
                            XMLContentParsed => {
                                Value => [
                                    {
                                        Item => $DefaultItem,
                                    },
                                ],
                            },
                            EffectiveValue => $Param{EffectiveValue}->{$Key},
                            NoValidation   => $Param{NoValidation},
                            UserID         => $Param{UserID},
                        );

                        if ( $SubResult{Error} ) {
                            %Result = %SubResult;
                            last KEY;
                        }
                        else {
                            $Param{EffectiveValue}->{$Key} = $SubResult{EffectiveValue};
                        }

                    }
                    elsif ( $DefaultItem->[0]->{Hash} ) {
                        $Result{Error} = "Item with key $Key must be a hash reference!";
                        last KEY;
                    }
                    elsif ( $DefaultItem->[0]->{Array} ) {
                        $Result{Error} = "Item with key $Key must be an array reference!";
                        last KEY;
                    }
                }
            }
        }

        # Check which Value type is default
        my $DefaultValueTypeDefined = 'String';
        if (
            $Value->[0]->{Hash}->[0]->{DefaultItem}
            && $Value->[0]->{Hash}->[0]->{DefaultItem}->[0]->{ValueType}
            )
        {
            $DefaultValueTypeDefined = $Value->[0]->{Hash}->[0]->{DefaultItem}->[0]->{ValueType};
        }

        # Get persistent keys(items with value type different then value type defined in the DefaultItem)
        my @PersistentKeys;
        for my $Item ( @{ $Value->[0]->{Hash}->[0]->{Item} } ) {
            my $ValueType = $DefaultValueTypeDefined;

            if ( $Item->{ValueType} ) {
                $ValueType = $Item->{ValueType};
            }
            elsif (
                $Item->{Item}
                && $Item->{Item}->[0]->{ValueType}
                )
            {
                $ValueType = $Item->{Item}->[0]->{ValueType};
            }

            if ( $ValueType ne $DefaultValueTypeDefined && $Item->{Key} ) {
                push @PersistentKeys, $Item->{Key};
            }
        }

        # Validate if all persistent keys are present
        PERSISTENT_KEY:
        for my $Key (@PersistentKeys) {
            if ( !defined $Param{EffectiveValue}->{$Key} ) {
                $Result{Error} = $Kernel::OM->Get('Kernel::Language')->Translate( "Missing key %s!", $Key );
                last PERSISTENT_KEY;
            }
        }

        if ( $Result{Error} ) {
            return %Result;
        }

        $Result{Success} = 1;
    }
    elsif ( $Value->[0]->{Array} ) {

        if ( ref $Param{EffectiveValue} ne 'ARRAY' ) {
            $Result{Error} = 'Its not an array!';
            return %Result;
        }

        PARAMETER:
        for my $Parameter ( sort keys %{ $Value->[0]->{Array}->[0] } ) {
            next PARAMETER if !grep { $_ eq $Parameter } qw(MinItems MaxItems);

            $Parameters{$Parameter} = $Value->[0]->{Array}->[0]->{$Parameter} || '';
        }

        if ( $Parameters{MinItems} && $Parameters{MinItems} > scalar @{ $Param{EffectiveValue} } ) {
            $Result{Error} = "Number of items in array is less than MinItems($Parameters{MinItems})!";
            return %Result;
        }

        if ( $Parameters{MaxItems} && $Parameters{MaxItems} < scalar @{ $Param{EffectiveValue} } ) {
            $Result{Error} = "Number of items in array is more than MaxItems($Parameters{MaxItems})!";
            return %Result;
        }

        my @Items = ();
        if (
            scalar @{ $Value->[0]->{Array} }
            && $Value->[0]->{Array}->[0]->{Item}
            && ref $Value->[0]->{Array}->[0]->{Item} eq 'ARRAY'
            )
        {
            @Items = @{ $Value->[0]->{Array}->[0]->{Item} };
        }

        my $DefaultItem;

        INDEX:
        for my $Index ( 0 .. scalar @{ $Param{EffectiveValue} } - 1 ) {

            $DefaultItem = $Value->[0]->{Array}->[0]->{DefaultItem};

            my $Ref = ref $Param{EffectiveValue}->[$Index];
            if ($Ref) {
                if ($DefaultItem) {
                    my $KeyNeeded;

                    if ( $Ref eq 'HASH' ) {
                        $KeyNeeded = 'Hash';
                    }
                    elsif ( $Ref eq 'ARRAY' ) {
                        $KeyNeeded = 'Array';
                    }
                    else {
                        $Result{Error} = "Wrong format!";
                        last INDEX;
                    }

                    if ( $DefaultItem->[0]->{Item} ) {

                        # So far everything is OK, we need to check deeper (recursive).
                        my %SubResult = $Self->_SettingEffectiveValueCheck(
                            XMLContentParsed => {
                                Value => [
                                    {
                                        Item => $DefaultItem,
                                    },
                                ],
                            },
                            EffectiveValue => $Param{EffectiveValue}->[$Index],
                            NoValidation   => $Param{NoValidation},
                            UserID         => $Param{UserID},
                        );
                        $Param{EffectiveValue}->[$Index] = $SubResult{EffectiveValue} if $SubResult{Success};

                        if ( $SubResult{Error} ) {
                            %Result = %SubResult;
                            last INDEX;
                        }
                    }
                    elsif ( !defined $DefaultItem->[0]->{$KeyNeeded} ) {
                        my $ExpectedText = '';

                        if ( $DefaultItem->[0]->{Array} ) {
                            $ExpectedText = "an array reference!";
                        }
                        elsif ( $DefaultItem->[0]->{Hash} ) {
                            $ExpectedText = "a hash reference!";
                        }
                        elsif ( $DefaultItem->[0]->{Content} ) {
                            $ExpectedText = "a scalar!";
                        }

                        $Result{Error} = "Item with index $Index must be $ExpectedText";
                        last INDEX;
                    }
                    else {

                        # So far everything is OK, we need to check deeper (recursive).
                        my %SubResult = $Self->_SettingEffectiveValueCheck(
                            XMLContentParsed => {
                                Value => $DefaultItem,
                            },
                            EffectiveValue => $Param{EffectiveValue}->[$Index],
                            NoValidation   => $Param{NoValidation},
                            UserID         => $Param{UserID},
                        );
                        $Param{EffectiveValue}->[$Index] = $SubResult{EffectiveValue} if $SubResult{Success};

                        if ( $SubResult{Error} ) {
                            %Result = %SubResult;
                            last INDEX;
                        }
                    }
                }
                else {

                    # Array is empty in the Defaults, value should be scalar.
                    $Result{Error} = "Item with index $Index must be a scalar!";
                    last INDEX;
                }
            }
            else {

                # scalar
                if ($DefaultItem) {

                    if ( $DefaultItem->[0]->{Item} || $DefaultItem->[0]->{ValueType} ) {

                        # Item with ValueType

                        # So far everything is OK, we need to check deeper (recursive).
                        my %SubResult = $Self->_SettingEffectiveValueCheck(
                            XMLContentParsed => {
                                Value => [
                                    {
                                        Item => $DefaultItem,
                                    },
                                ],
                            },
                            EffectiveValue => $Param{EffectiveValue}->[$Index],
                            NoValidation   => $Param{NoValidation},
                            UserID         => $Param{UserID},
                        );
                        $Param{EffectiveValue}->[$Index] = $SubResult{EffectiveValue} if $SubResult{Success};

                        if ( $SubResult{Error} ) {
                            %Result = %SubResult;
                            last INDEX;
                        }
                    }
                    elsif ( $DefaultItem->[0]->{Hash} ) {
                        $Result{Error} = "Item with index $Index must be a hash reference!";
                        last INDEX;
                    }
                    elsif ( $DefaultItem->[0]->{Array} ) {
                        $Result{Error} = "Item with index $Index must be an array reference!";
                        last INDEX;
                    }
                }
            }
        }
        if ( $Result{Error} ) {
            return %Result;
        }

        $Result{Success} = 1;
    }

    if ( $Result{Success} ) {
        $Result{EffectiveValue} = $Param{EffectiveValue};
    }

    return %Result;
}
</pre></div>

<p>Check if provided EffectiveValue matches structure defined in DefaultSetting. Also returns EffectiveValue that might be changed.</p>

<pre>    my %Result = $SysConfigObject-&gt;SettingEffectiveValueCheck(
        EffectiveValue =&gt; 'open',     # (optional)
        XMLContentParsed =&gt; {         # (required)
            Value =&gt; [
                {
                    'Item' =&gt; [
                        {
                            'Content' =&gt; &quot;Scalar value&quot;,
                        },
                    ],
                },
            ],
        },
        NoValidation          =&gt; 1,    # (optional) no value type validation.
        UserID                =&gt; 1,    # (required) UserID
    );
</pre><p>Returns:</p>

<pre>    %Result = (
        EffectiveValue =&gt; 'closed',    # Note that resulting effective value can be different
        Success        =&gt; 1,
        Error          =&gt; undef,
    );
</pre><h2 id="SettingReset">SettingReset()</h2>

<p><a href="#" onclick="toggleCode('method_SettingReset');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SettingReset">
                                        <pre>

sub SettingReset {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(Name ExclusiveLockGUID UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!",
            );
            return;
        }
    }

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    # Check if the setting exists.
    my %DefaultSetting = $SysConfigDBObject->DefaultSettingGet(
        Name => $Param{Name},
    );

    return if !%DefaultSetting;

    # Default should be locked.
    my $LockedByUser = $SysConfigDBObject->DefaultSettingIsLockedByUser(
        DefaultID           => $DefaultSetting{DefaultID},
        ExclusiveLockUserID => $Param{UserID},
        ExclusiveLockGUID   => $Param{ExclusiveLockGUID},
    );

    if ( !$LockedByUser ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Setting $Param{Name} is not locked to this user!",
        );
        return;
    }

    my %ModifiedSetting = $SysConfigDBObject->ModifiedSettingGet(
        Name     => $Param{Name},
        IsGlobal => 1,
    );

    # Setting already had default value.
    return 1 if !%ModifiedSetting;

    my %SettingDeployed = $Self->SettingGet(
        Name     => $Param{Name},
        Deployed => 1,
    );

    my $IsModified = DataIsDifferent(
        Data1 => \$SettingDeployed{EffectiveValue},
        Data2 => \$DefaultSetting{EffectiveValue},
    ) || 0;

    $IsModified ||= $ModifiedSetting{IsValid} != $DefaultSetting{IsValid};
    $IsModified ||= $ModifiedSetting{UserModificationActive} != $DefaultSetting{UserModificationActive};
    $ModifiedSetting{IsDirty} = $IsModified ? 1 : 0;

    # Copy values from default.
    for my $Field (qw(IsValid UserModificationActive EffectiveValue)) {
        $ModifiedSetting{$Field} = $DefaultSetting{$Field};
    }

    # Set reset flag.
    $ModifiedSetting{ResetToDefault} = 1;

    # Delete modified setting.
    my $ResetResult = $SysConfigDBObject->ModifiedSettingUpdate(
        %ModifiedSetting,
        ExclusiveLockGUID => $Param{ExclusiveLockGUID},
        UserID            => $Param{UserID},
    );

    if ( !$ResetResult ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "System was unable to update Modified setting: $Param{Name}!",
        );
    }

    return $ResetResult;
}
</pre></div>

<p>Reset the modified value to the default value.</p>

<pre>    my $Result = $SysConfigObject-&gt;SettingReset(
        Name                  =&gt; 'Setting Name',                # (required) Setting name
        TargetUserID          =&gt; 2,                             # (optional) UserID for settings in AgentPreferences
                                                                # or
        ExclusiveLockGUID     =&gt; $LockingString,                # (optional) the GUID used to locking the setting
        UserID                =&gt; 1,                             # (required) UserID that creates modification
    );
</pre><p>Returns:</p>

<pre>    $Result = 1;        # or false in case of an error
</pre><h2 id="ConfigurationTranslatedGet">ConfigurationTranslatedGet()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationTranslatedGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationTranslatedGet">
                                        <pre>

sub ConfigurationTranslatedGet {
    my ( $Self, %Param ) = @_;

    my $LanguageObject = $Kernel::OM->Get('Kernel::Language');
    my $CacheObject    = $Kernel::OM->Get('Kernel::System::Cache');

    my $CacheType = 'ConfigurationTranslatedGet';
    my $CacheKey  = "ConfigurationTranslatedGet::$LanguageObject->{UserLanguage}";

    # Return cache.
    my $Cache = $CacheObject->Get(
        Type => $CacheType,
        Key  => $CacheKey,
    );

    return %{$Cache} if ref $Cache eq 'HASH';

    my %Settings = $Self->ConfigurationList();
    my %Result;

    for my $DefaultID ( sort keys %Settings ) {

        my %SettingTranslated = $Self->_ConfigurationTranslatedGet(
            Language => $LanguageObject->{UserLanguage},
            Name     => $Settings{$DefaultID},
        );

        # Append to the result.
        $Result{ $Settings{$DefaultID} } = $SettingTranslated{ $Settings{$DefaultID} };
    }

    $CacheObject->Set(
        Type  => $CacheType,
        Key   => $CacheKey,
        Value => \%Result,
        TTL   => $Self->{CacheTTL} || 24 * 60 * 60,
    );

    return %Result;
}
</pre></div>

<p>Returns a hash with all settings and translated metadata.</p>

<pre>    my %Result = $SysConfigObject-&gt;ConfigurationTranslatedGet();
</pre><p>Returns:</p>

<pre>    %Result = (
       'ACL::CacheTTL' =&gt; {
            'Category' =&gt; 'OTRSFree',
            'IsInvisible' =&gt; '0',
            'Metadata' =&gt; &quot;ACL::CacheTTL--- '3600'
Cache-Zeit in Sekunden f\x{fc}r Datenbank ACL-Backends.&quot;,
        ...
    );
</pre><h2 id="SettingNavigationToPath">SettingNavigationToPath()</h2>

<p><a href="#" onclick="toggleCode('method_SettingNavigationToPath');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SettingNavigationToPath">
                                        <pre>

sub SettingNavigationToPath {
    my ( $Self, %Param ) = @_;

    my @NavigationNames = split( '::', $Param{Navigation} );
    my @Path;

    INDEX:
    for my $Index ( 0 .. $#NavigationNames ) {

        $Path[$Index]->{Name} = $NavigationNames[$Index];

        my @SubArray = @NavigationNames[ 0 .. $Index ];
        $Path[$Index]->{Value} = join '::', @SubArray;
    }

    return @Path;
}
</pre></div>

<p>Returns path structure for given navigation group.</p>

<pre>    my @Path = $SysConfigObject-&gt;SettingNavigationToPath(
        Navigation =&gt; 'Frontend::Agent::ToolBarModule',  # (optional)
    );
</pre><p>Returns:</p>

<pre>    @Path = (
        {
            'Value' =&gt; 'Frontend',
            'Name' =&gt; 'Frontend',
        },
        {
            'Value' =&gt; 'Frontend::Agent',
            'Name' =&gt; 'Agent',
        },
        ...
    );
</pre><h2 id="ConfigurationTranslatableStrings">ConfigurationTranslatableStrings()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationTranslatableStrings');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationTranslatableStrings">
                                        <pre>

sub ConfigurationTranslatableStrings {
    my ( $Self, %Param ) = @_;

    # Reset translation list.
    $Self->{ConfigurationTranslatableStrings} = {};

    # Get all default settings.
    my @SettingsList = $Kernel::OM->Get('Kernel::System::SysConfig::DB')->DefaultSettingListGet();

    SETTING:
    for my $Setting (@SettingsList) {

        next SETTING if !$Setting;
        next SETTING if !defined $Setting->{XMLContentParsed};

        # Get translatable strings.
        $Self->_ConfigurationTranslatableStrings( Data => $Setting->{XMLContentParsed} );

    }

    my @Strings;
    for my $Key ( sort keys %{ $Self->{ConfigurationTranslatableStrings} } ) {
        push @Strings, $Key;
    }
    return @Strings;
}
</pre></div>

<p>Returns a unique list of all translatable strings from the default settings.</p>

<pre>    my @TranslatableStrings = $SysConfigObject-&gt;ConfigurationTranslatableStrings();
</pre><h2 id="ConfigurationEntitiesGet">ConfigurationEntitiesGet()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationEntitiesGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationEntitiesGet">
                                        <pre>

sub ConfigurationEntitiesGet {
    my ( $Self, %Param ) = @_;

    my $CacheObject = $Kernel::OM->Get('Kernel::System::Cache');

    my $CacheType = "SysConfigEntities";
    my $CacheKey  = "UsedEntities";

    my $CacheData = $CacheObject->Get(
        Type => $CacheType,
        Key  => $CacheKey,
    );

    # Return cached data if available.
    return %{$CacheData} if $CacheData;

    my %Result = ();

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    my @EntitySettings = $SysConfigDBObject->DefaultSettingSearch(
        Search => 'ValueEntityType',
        Valid  => 1,
    );

    SETTING:
    for my $SettingName (@EntitySettings) {
        my %Setting = $SysConfigDBObject->DefaultSettingGet(
            Name => $SettingName,
        );

        # Check if there is modified value.
        my %ModifiedSetting = $SysConfigDBObject->ModifiedSettingGet(
            Name => $SettingName,
        );

        if (%ModifiedSetting) {
            my $XMLContentParsed = $Self->SettingModifiedXMLContentParsedGet(
                ModifiedSetting => \%ModifiedSetting,
                DefaultSetting  => \%Setting,
            );

            $Setting{XMLContentParsed}->{Value} = $XMLContentParsed;
        }

        %Result = $Self->_ConfigurationEntitiesGet(
            Value  => $Setting{XMLContentParsed}->{Value},
            Result => \%Result,
            Name   => $Setting{XMLContentParsed}->{Name},
        );
    }

    # Cache the results.
    $CacheObject->Set(
        Type  => $CacheType,
        Key   => $CacheKey,
        Value => \%Result,
        TTL   => 30 * 24 * 60 * 60,
    );

    return %Result;
}
</pre></div>

<p>Get all entities that are referred in any enabled Setting in complete SysConfig.</p>

<pre>    my %Result = $SysConfigObject-&gt;ConfigurationEntitiesGet();
</pre><p>Returns:</p>

<pre>    %Result = (
        'Priority' =&gt; {
            '3 normal' =&gt; [
                'Ticket::Frontend::AgentTicketNote###PriorityDefault',
                'Ticket::Frontend::AgentTicketPhone###Priority',
                ...
            ],
        },
        'Queue' =&gt; {
            'Postmaster' =&gt; [
                'Ticket::Frontend::CustomerTicketMessage###QueueDefault',
            ],
            'Raw' =&gt; [
                'PostmasterDefaultQueue',
            ],
        },
        ...
    );
</pre><h2 id="ConfigurationEntityCheck">ConfigurationEntityCheck()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationEntityCheck');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationEntityCheck">
                                        <pre>

sub ConfigurationEntityCheck {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(EntityType EntityName)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!"
            );
            return;
        }
    }

    my $CacheObject = $Kernel::OM->Get('Kernel::System::Cache');

    my $CacheType = "SysConfigEntities";
    my $CacheKey  = "ConfigurationEntityCheck$Param{EntityType}-$Param{EntityName}";

    my $CacheData = $CacheObject->Get(
        Type => $CacheType,
        Key  => $CacheKey,
    );

    # Return cached data if available.
    return @{$CacheData} if $CacheData;

    my %EntitySettings = $Self->ConfigurationEntitiesGet();

    my @Result = ();

    for my $EntityType ( sort keys %EntitySettings ) {

        # Check conditions.
        if (
            $EntityType eq $Param{EntityType}
            && $EntitySettings{$EntityType}{ $Param{EntityName} }
            )
        {
            @Result = @{ $EntitySettings{$EntityType}->{ $Param{EntityName} } };
        }
    }

    # Cache the results.
    $CacheObject->Set(
        Type  => $CacheType,
        Key   => $CacheKey,
        Value => \@Result,
        TTL   => 30 * 24 * 60 * 60,
    );

    return @Result;
}
</pre></div>

<p>Check if there are any enabled settings that refers to the provided Entity.</p>

<pre>    my @Result = $SysConfigObject-&gt;ConfigurationEntityCheck(
        EntityType  =&gt; 'Priority',
        EntityName  =&gt; '3 normal',
    );
</pre><p>Returns:</p>

<pre>    @Result = (
        'Ticket::Frontend::AgentTicketNote###PriorityDefault',
        'Ticket::Frontend::AgentTicketPhone###Priority',
        'Ticket::Frontend::AgentTicketBulk###PriorityDefault',
        ...
    );
</pre><h2 id="ConfigurationXML2DB">ConfigurationXML2DB()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationXML2DB');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationXML2DB">
                                        <pre>

sub ConfigurationXML2DB {
    my ( $Self, %Param ) = @_;

    if ( !$Param{UserID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Need UserID!"
        );
        return;
    }

    my $Directory = $Param{Directory} || "$Self->{Home}/Kernel/Config/Files/XML/";

    if ( !-e $Directory ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Directory '$Directory' does not exists",
        );

        return;
    }

    my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

    # Load xml config files, ordered by file name
    my @Files = $MainObject->DirectoryRead(
        Directory => $Directory,
        Filter    => "*.xml",
    );

    my $CacheObject        = $Kernel::OM->Get('Kernel::System::Cache');
    my $SysConfigXMLObject = $Kernel::OM->Get('Kernel::System::SysConfig::XML');
    my $SysConfigDBObject  = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    my %SettingsByInit = (
        Framework   => [],
        Application => [],
        Config      => [],
        Changes     => [],
    );

    my %Data;
    FILE:
    for my $File (@Files) {

        my $MD5Sum = $MainObject->MD5sum(
            Filename => $File,
        );

        # Cleanup filename for cache type
        my $Filename = $File;
        $Filename =~ s{\/\/}{\/}g;
        $Filename =~ s{\A .+ Kernel/Config/Files/XML/ (.+)\.xml\z}{$1}msx;

        my $CacheKey  = "ConfigurationXML2DB::${Filename}::${MD5Sum}";
        my $CacheType = "SysConfig_ConfigurationXML2DB_$Filename";

        my $Cache = $CacheObject->Get(
            Type => $CacheType,
            Key  => $CacheKey,
        );

        if (
            ref $Cache eq 'HASH'
            && $Cache->{Init}
            && ref $Cache->{Settings} eq 'ARRAY'
            )
        {
            @{ $SettingsByInit{ $Cache->{Init} } }
                = ( @{ $SettingsByInit{ $Cache->{Init} } }, @{ $Cache->{Settings} } );
            next FILE;
        }

        # Delete any cache with different MD5Sum
        $CacheObject->CleanUp(
            Type => $CacheType,
        );

        # Read XML file.
        my $ConfigFile = $MainObject->FileRead(
            Location => $File,
            Mode     => 'utf8',
            Result   => 'SCALAR',
        );
        if ( !ref $ConfigFile || !${$ConfigFile} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Can't open file $File: $!",
            );
            next FILE;
        }

        # Check otrs_config Init attribute.
        $$ConfigFile =~ m{^<otrs_config.*?init="(.*?)"}gsmx;
        my $InitValue = $1;

        # Check if InitValue is Valid.
        if ( !defined $SettingsByInit{$InitValue} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message =>
                    "Invalid otrs_config Init value ($InitValue)! Allowed values: Framework, Application, Config, Changes.",
            );
            next FILE;
        }

        # Extract all Settings from XML file.
        my $SettingList = $SysConfigXMLObject->SettingListGet(
            XMLInput => $$ConfigFile,
        );

        my $XMLFilename = $File;
        $XMLFilename =~ s{$Directory(.*\.xml)\z}{$1}gmsx;
        $XMLFilename =~ s{\A/}{}gmsx;

        my @ParsedSettings;

        for my $SettingName ( sort keys %{$SettingList} ) {

            # Convert XML to perl structure.
            my $Setting = $SysConfigXMLObject->SettingParse(
                SettingXML => $SettingList->{$SettingName},
            );

            push @ParsedSettings, {
                XMLContentParsed => $Setting,
                XMLContentRaw    => $SettingList->{$SettingName},
                XMLFilename      => $XMLFilename,
            };
        }

        @{ $SettingsByInit{$InitValue} } = ( @{ $SettingsByInit{$InitValue} }, @ParsedSettings );

        $CacheObject->Set(
            Key   => $CacheKey,
            Type  => $CacheType,
            Value => {
                Init     => $InitValue,
                Settings => \@ParsedSettings,
            },
            TTL => 60 * 60 * 24 * 20,
        );
    }

    # Combine everything together in the correct order.
    my %Settings;
    for my $Init (qw(Framework Application Config Changes)) {
        SETTING:
        for my $Setting ( @{ $SettingsByInit{$Init} } ) {
            my $Name = $Setting->{XMLContentParsed}->{Name};
            next SETTING if !$Name;

            $Settings{$Name} = $Setting;
        }
    }

    # Find and remove all settings that are in DB, but are not defined in XML files.
    if ( $Param{CleanUp} ) {
        $Self->_DBCleanUp( Settings => \%Settings );
    }

    # Create/Update settings in DB.
    SETTING:
    for my $SettingName ( sort keys %Settings ) {

        # Check if exists in Default.
        my %DefaultSetting = $SysConfigDBObject->DefaultSettingGet(
            Name => $SettingName,
        );

        # Create a local clone of the value to prevent any modification.
        my $Value = $Kernel::OM->Get('Kernel::System::Storable')->Clone(
            Data => $Settings{$SettingName}->{XMLContentParsed}->{Value},
        );

        my $EffectiveValue = $Self->SettingEffectiveValueGet(
            Value => $Value,
        );

        if (%DefaultSetting) {

            # Compare new Setting XML with the old one (skip if there is no difference).
            my $Updated = $Settings{$SettingName}->{XMLContentRaw} eq $DefaultSetting{XMLContentRaw} ? 0 : 1;
            next SETTING if !$Updated;

            # Lock setting to be able to update it.
            my $ExclusiveLockGUID = $SysConfigDBObject->DefaultSettingLock(
                UserID    => $Param{UserID},
                DefaultID => $DefaultSetting{DefaultID},
                Force     => $Param{Force},
            );
            if ( !$ExclusiveLockGUID ) {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message =>
                        "System was unable to lock Default Setting "
                        . "(DefaultID=$DefaultSetting{DefaultID} UserID=$Param{UserID})!",
                );
                next SETTING;
            }

            # Update default setting.
            my $Success = $SysConfigDBObject->DefaultSettingUpdate(
                DefaultID      => $DefaultSetting{DefaultID},
                Name           => $Settings{$SettingName}->{XMLContentParsed}->{Name},
                Description    => $Settings{$SettingName}->{XMLContentParsed}->{Description}->[0]->{Content} || '',
                Navigation     => $Settings{$SettingName}->{XMLContentParsed}->{Navigation}->[0]->{Content} || '',
                IsInvisible    => $Settings{$SettingName}->{XMLContentParsed}->{Invisible} || 0,
                IsReadonly     => $Settings{$SettingName}->{XMLContentParsed}->{ReadOnly} || 0,
                IsRequired     => $Settings{$SettingName}->{XMLContentParsed}->{Required} || 0,
                IsValid        => $Settings{$SettingName}->{XMLContentParsed}->{Valid} || 0,
                HasConfigLevel => $Settings{$SettingName}->{XMLContentParsed}->{ConfigLevel} || 100,
                UserModificationPossible => $Settings{$SettingName}->{XMLContentParsed}->{UserModificationPossible}
                    || 0,
                UserModificationActive => $Settings{$SettingName}->{XMLContentParsed}->{UserModificationActive} || 0,
                UserPreferencesGroup   => $Settings{$SettingName}->{XMLContentParsed}->{UserPreferencesGroup},
                XMLContentRaw          => $Settings{$SettingName}->{XMLContentRaw},
                XMLContentParsed       => $Settings{$SettingName}->{XMLContentParsed},
                XMLFilename            => $Settings{$SettingName}->{XMLFilename},
                EffectiveValue         => $EffectiveValue,
                UserID                 => $Param{UserID},
                ExclusiveLockGUID      => $ExclusiveLockGUID,
            );
            if ( !$Success ) {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message =>
                        "DefaultSettingUpdate failed for Config Item: $SettingName!",
                );
            }

            # Unlock the setting so it can be locked again afterwards.
            $SysConfigDBObject->DefaultSettingUnlock(
                DefaultID => $DefaultSetting{DefaultID},
            );

            my @ModifiedList = $SysConfigDBObject->ModifiedSettingListGet(
                Name => $Settings{$SettingName}->{XMLContentParsed}->{Name},
            );

            for my $ModifiedSetting (@ModifiedList) {

                # So far everything is OK, if the structure or values does
                # not match anymore, modified values must be deleted.
                my %ValueCheckResult = $Self->SettingEffectiveValueCheck(
                    EffectiveValue   => $ModifiedSetting->{EffectiveValue},
                    XMLContentParsed => $Settings{$SettingName}->{XMLContentParsed},
                    UserID           => $Param{UserID},
                );

                if ( !$ValueCheckResult{Success} ) {

                    $SysConfigDBObject->ModifiedSettingDelete(
                        ModifiedID => $ModifiedSetting->{ModifiedID},
                    );

                    $Kernel::OM->Get('Kernel::System::Log')->Log(
                        Priority => 'error',
                        Message  => $ValueCheckResult{Error},
                    );
                }
            }

        }
        else {

            # Create default setting.
            my $DefaultID = $SysConfigDBObject->DefaultSettingAdd(
                Name           => $Settings{$SettingName}->{XMLContentParsed}->{Name},
                Description    => $Settings{$SettingName}->{XMLContentParsed}->{Description}->[0]->{Content} || '',
                Navigation     => $Settings{$SettingName}->{XMLContentParsed}->{Navigation}->[0]->{Content} || '',
                IsInvisible    => $Settings{$SettingName}->{XMLContentParsed}->{Invisible} || 0,
                IsReadonly     => $Settings{$SettingName}->{XMLContentParsed}->{ReadOnly} || 0,
                IsRequired     => $Settings{$SettingName}->{XMLContentParsed}->{Required} || 0,
                IsValid        => $Settings{$SettingName}->{XMLContentParsed}->{Valid} || 0,
                HasConfigLevel => $Settings{$SettingName}->{XMLContentParsed}->{ConfigLevel} || 100,
                UserModificationPossible => $Settings{$SettingName}->{XMLContentParsed}->{UserModificationPossible}
                    || 0,
                UserModificationActive => $Settings{$SettingName}->{XMLContentParsed}->{UserModificationActive} || 0,
                UserPreferencesGroup   => $Settings{$SettingName}->{XMLContentParsed}->{UserPreferencesGroup},
                XMLContentRaw          => $Settings{$SettingName}->{XMLContentRaw},
                XMLContentParsed       => $Settings{$SettingName}->{XMLContentParsed},
                XMLFilename            => $Settings{$SettingName}->{XMLFilename},
                EffectiveValue         => $EffectiveValue,
                UserID                 => $Param{UserID},
            );
            if ( !$DefaultID ) {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message =>
                        "DefaultSettingAdd failed for Config Item: $Settings{$SettingName}->{XMLContentParsed}->{Name}!",
                );
            }
        }
    }

    return 1;
}
</pre></div>

<p>Load Settings defined in XML files to the database.</p>

<pre>    my $Success = $SysConfigObject-&gt;ConfigurationXML2DB(
        UserID    =&gt; 1,                  # UserID
        Directory =&gt; '/some/folder',     # (optional) Provide directory where XML files are stored (default: Kernel/Config/Files/XML).
        Force     =&gt; 1,                  # (optional) Force Setting update, even if it's locked by another user. Default: 0.
        CleanUp   =&gt; 1,                  # (optional) Remove all settings that are not present in XML files. Default: 0.
    );
</pre><p>Returns:</p>

<pre>    $Success = 1;       # or false in case of an error.
</pre><h2 id="ConfigurationNavigationTree">ConfigurationNavigationTree()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationNavigationTree');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationNavigationTree">
                                        <pre>

sub ConfigurationNavigationTree {
    my ( $Self, %Param ) = @_;

    $Param{RootNavigation} //= '';

    my $CacheType = 'SysConfigNavigation';
    my $CacheKey  = "NavigationTree::$Param{RootNavigation}";
    if ( defined $Param{IsValid} ) {
        if ( $Param{IsValid} ) {
            $CacheKey .= '::Valid';
        }
        else {
            $CacheKey .= '::Invalid';
        }
    }
    if ( defined $Param{Category} && $Param{Category} ) {
        if ( $Param{Category} eq 'All' ) {
            delete $Param{Category};
        }
        else {
            $CacheKey .= "::Category=$Param{Category}";
        }
    }

    my $CacheObject = $Kernel::OM->Get('Kernel::System::Cache');

    my $Cache = $CacheObject->Get(
        Type => $CacheType,
        Key  => $CacheKey,
    );

    return %{$Cache} if ref $Cache eq 'HASH';

    my %CategoryOptions;
    if ( $Param{Category} ) {
        my %Categories = $Self->ConfigurationCategoriesGet();
        if ( $Categories{ $Param{Category} } ) {
            %CategoryOptions = (
                Category      => $Param{Category},
                CategoryFiles => $Categories{ $Param{Category} }->{Files},
            );
        }
    }

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    # Get all default settings
    my @SettingsRaw = $SysConfigDBObject->DefaultSettingListGet(
        %CategoryOptions,
        IsValid => $Param{IsValid},
    );

    my @Settings;

    # Skip invisible settings from the navigation tree
    SETTING:
    for my $Setting (@SettingsRaw) {
        next SETTING if $Setting->{IsInvisible};

        push @Settings, {
            Name       => $Setting->{Name},
            Navigation => $Setting->{Navigation},
        };
    }

    my %Result = ();

    my @RootNavigation;
    if ( $Param{RootNavigation} ) {
        @RootNavigation = split "::", $Param{RootNavigation};
    }

    # Remember ancestors.
    for my $Index ( 1 .. $#RootNavigation ) {
        $RootNavigation[$Index] = $RootNavigation[ $Index - 1 ] . '::' . $RootNavigation[$Index];
    }

    SETTING:
    for my $Setting (@Settings) {
        next SETTING if !$Setting->{Navigation};
        my @Path = split "::", $Setting->{Navigation};

        # Remember ancestors.
        for my $Index ( 1 .. $#Path ) {
            $Path[$Index] = $Path[ $Index - 1 ] . '::' . $Path[$Index];
        }

        # Check if RootNavigation matches current setting.
        for my $Index ( 0 .. $#RootNavigation ) {
            next SETTING if !$Path[$Index];

            if ( $RootNavigation[$Index] ne $Path[$Index] ) {
                next SETTING;
            }
        }

        # Remove root groups from Path.
        for my $Index ( 0 .. $#RootNavigation ) {
            shift @Path;
        }

        %Result = $Self->_NavigationTree(
            Tree  => \%Result,
            Array => \@Path,
        );
    }

    # Cache the results.
    $CacheObject->Set(
        Type  => $CacheType,
        Key   => $CacheKey,
        Value => \%Result,
        TTL   => 30 * 24 * 60 * 60,
    );

    return %Result;
}
</pre></div>

<p>Returns navigation tree in the hash format.</p>

<pre>    my %Result = $SysConfigObject-&gt;ConfigurationNavigationTree(
        RootNavigation         =&gt; 'Parent',     # (optional) If provided only sub groups of the root navigation are returned.
        IsValid                =&gt; 1,            # (optional) By default, display all settings.
        Category               =&gt; 'OTRSFree'    # (optional)
    );
</pre><p>Returns:</p>

<pre>    %Result = (
        'Core' =&gt; {
            'Core::Cache' =&gt; {},
            'Core::CustomerCompany' =&gt; {},
            'Core::CustomerUser' =&gt; {},
            'Core::Daemon' =&gt; {
                'Core::Daemon::ModuleRegistration' =&gt; {},
            },
            ...
        'Crypt' =&gt;{
            ...
        },
        ...
    );
</pre><h2 id="ConfigurationListGet">ConfigurationListGet()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationListGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationListGet">
                                        <pre>

sub ConfigurationListGet {
    my ( $Self, %Param ) = @_;

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    $Param{Translate} //= 0;    # don't translate by default

    my %CategoryOptions;
    if ( $Param{Category} ) {
        my %Categories = $Self->ConfigurationCategoriesGet();
        if ( $Categories{ $Param{Category} } ) {
            %CategoryOptions = (
                Category      => $Param{Category},
                CategoryFiles => $Categories{ $Param{Category} }->{Files},
            );
        }
    }

    # Get all default settings for this navigation group.
    my @ConfigurationList = $SysConfigDBObject->DefaultSettingListGet(
        Navigation               => $Param{Navigation},
        UserModificationPossible => $Param{TargetUserID} ? 1 : undef,
        UserPreferencesGroup => $Param{UserPreferencesGroup} || undef,
        IsInvisible => $Param{Invisible} ? undef : 0,
        IsValid => $Param{IsValid} // undef,
        %CategoryOptions,
    );

    my $StorableObject = $Kernel::OM->Get('Kernel::System::Storable');

    # Update setting values with the modified settings.
    SETTING:
    for my $Setting (@ConfigurationList) {

        # Remember default value.
        $Setting->{DefaultValue} = $Setting->{EffectiveValue};
        if ( ref $Setting->{EffectiveValue} ) {
            $Setting->{DefaultValue} = $StorableObject->Clone(
                Data => $Setting->{EffectiveValue},
            );
        }

        my %ModifiedSetting = $Self->SettingGet(
            Name      => $Setting->{Name},
            Translate => $Param{Translate},
        );

        # Skip if setting is invalid.
        next SETTING if !IsHashRefWithData( \%ModifiedSetting );
        next SETTING if !defined $ModifiedSetting{EffectiveValue};

        # Mark setting as modified.
        my $IsModified = DataIsDifferent(
            Data1 => \$Setting->{EffectiveValue},
            Data2 => \$ModifiedSetting{EffectiveValue},
        ) || 0;

        $IsModified ||= $ModifiedSetting{IsValid} != $Setting->{IsValid};
        $IsModified ||= $ModifiedSetting{UserModificationActive} != $Setting->{UserModificationActive};

        $Setting->{IsModified} = $IsModified ? 1 : 0;

        # Update setting attributes.
        ATTRIBUTE:
        for my $Attribute (
            qw(ModifiedID IsValid UserModificationActive UserPreferencesGroup EffectiveValue IsDirty ChangeTime XMLContentParsed)
            )
        {
            next ATTRIBUTE if !defined $ModifiedSetting{$Attribute};

            $Setting->{$Attribute} = $ModifiedSetting{$Attribute};
        }
    }

    return @ConfigurationList;
}
</pre></div>

<p>Returns list of settings that matches provided parameters.</p>

<pre>    my @List = $SysConfigObject-&gt;ConfigurationListGet(
        Navigation           =&gt; 'SomeNavigationGroup',  # (optional) limit to the settings that have provided navigation
        IsValid              =&gt; 1,                      # (optional) by default returns valid and invalid settings.
        Invisible            =&gt; 0,                      # (optional) Include Invisible settings. By default, not included.
        UserPreferencesGroup =&gt; 'Advanced',             # (optional) filter list by group.
        Translate            =&gt; 0,                      # (optional) Translate translatable string in EffectiveValue. Default 0.
    );
</pre><p>Returns:</p>

<pre>    @List = (
        {
            DefaultID                =&gt; 123,
            ModifiedID               =&gt; 456,     # if modified
            Name                     =&gt; &quot;ProductName&quot;,
            Description              =&gt; &quot;Defines the name of the application ...&quot;,
            Navigation               =&gt; &quot;ASimple::Path::Structure&quot;,
            IsInvisible              =&gt; 1,
            IsReadonly               =&gt; 0,
            IsRequired               =&gt; 1,
            IsValid                  =&gt; 1,
            HasConfigLevel           =&gt; 200,
            UserModificationPossible =&gt; 0,          # 1 or 0
            UserModificationActive   =&gt; 0,          # 1 or 0
            UserPreferencesGroup     =&gt; 'Advanced', # optional
            XMLContentRaw            =&gt; &quot;The XML structure as it is on the config file&quot;,
            XMLContentParsed         =&gt; &quot;XML parsed to Perl&quot;,
            EffectiveValue           =&gt; &quot;Product 6&quot;,
            DefaultValue             =&gt; &quot;Product 5&quot;,
            IsModified               =&gt; 1,       # 1 or 0
            IsDirty                  =&gt; 1,       # 1 or 0
            ExclusiveLockGUID        =&gt; 'A32CHARACTERLONGSTRINGFORLOCKING',
            ExclusiveLockUserID      =&gt; 1,
            ExclusiveLockExpiryTime  =&gt; '2016-05-29 11:09:04',
            CreateTime               =&gt; &quot;2016-05-29 11:04:04&quot;,
            ChangeTime               =&gt; &quot;2016-05-29 11:04:04&quot;,
        },
        {
            DefaultID     =&gt; 321,
            Name          =&gt; 'FieldName',
            # ...
            CreateTime    =&gt; '2010-09-11 10:08:00',
            ChangeTime    =&gt; '2011-01-01 01:01:01',
        },
        # ...
    );
</pre><h2 id="ConfigurationList">ConfigurationList()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationList">
                                        <pre>

sub ConfigurationList {
    my ( $Self, %Param ) = @_;

    return $Kernel::OM->Get('Kernel::System::SysConfig::DB')->DefaultSettingList();
}
</pre></div>

<p>Wrapper of Kernel::System::SysConfig::DB::DefaultSettingList() - Get list of all settings.</p>

<pre>    my %Settings = $SysConfigObject-&gt;ConfigurationList();
</pre><p>Returns:</p>

<pre>    %Settings = (
        '123' =&gt; 'SettingName1',
        '124' =&gt; 'SettingName2',
        ...
    );
</pre><h2 id="ConfigurationInvalidList">ConfigurationInvalidList()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationInvalidList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationInvalidList">
                                        <pre>

sub ConfigurationInvalidList {
    my ( $Self, %Param ) = @_;

    my $CacheObject = $Kernel::OM->Get('Kernel::System::Cache');

    my $CacheType = 'SysConfigInvalid';
    my $CacheKey  = 'ConfigurationInvalidList';

    # Return cache.
    my $Cache = $CacheObject->Get(
        Type => $CacheType,
        Key  => $CacheKey,
    );

    return @{$Cache} if ref $Cache eq 'ARRAY';

    my @SettingsEnabled = $Self->ConfigurationListGet(
        IsValid   => 1,
        Translate => 0,
    );

    my @InvalidSettings;

    for my $Setting (@SettingsEnabled) {
        my %SettingDeployed = $Self->SettingGet(
            Name     => $Setting->{Name},
            Deployed => 1,
        );

        my %EffectiveValueCheck = $Self->SettingEffectiveValueCheck(
            EffectiveValue   => $SettingDeployed{EffectiveValue},
            XMLContentParsed => $Setting->{XMLContentParsed},
            UserID           => 1,
        );

        if ( $EffectiveValueCheck{Error} ) {
            push @InvalidSettings, $Setting->{Name};
        }
    }

    $CacheObject->Set(
        Type  => $CacheType,
        Key   => $CacheKey,
        Value => \@InvalidSettings,
        TTL   => 60 * 60,             # 1 hour
    );

    return @InvalidSettings;
}
</pre></div>

<p>Returns list of enabled settings that have invalid effective value.</p>

<pre>    my @List = $SysConfigObject-&gt;ConfigurationInvalidList();
</pre><p>Returns:</p>

<pre>    @List = ( &quot;Setting1&quot;, &quot;Setting5&quot;, ... );
</pre><h2 id="ConfigurationDeploy">ConfigurationDeploy()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationDeploy');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationDeploy">
                                        <pre>

sub ConfigurationDeploy {
    my ( $Self, %Param ) = @_;

    if ( !$Param{UserID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Need UserID!",
        );

        return;
    }
    if ( !IsPositiveInteger( $Param{UserID} ) ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "UserID is invalid!",
        );
        return;
    }

    if ( $Param{AllSettings} ) {
        $Param{NotDirty}      = 0;
        $Param{DirtySettings} = undef;
    }
    elsif ( $Param{NotDirty} ) {
        $Param{AllSettings}   = 0;
        $Param{DirtySettings} = undef;
    }

    my $BasePath = 'Kernel/Config/Files/';

    # Parameter 'FileName' is intentionally not documented in the API as it is only used for testing.
    my $TargetPath = $BasePath . ( $Param{FileName} || "ZZZAAuto.pm" );

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    my @UserDirtySettings = $SysConfigDBObject->ModifiedSettingListGet(
        IsDirty  => 1,
        ChangeBy => $Param{UserID},
    );
    my %UserDirtySettingsLookup = map { $_->{Name} => 1 } @UserDirtySettings;

    # Determine dirty settings to deploy (if not specified get all dirty settings from current user).
    if ( !$Param{DirtySettings} && !$Param{AllSettings} && !$Param{NotDirty} ) {
        @{ $Param{DirtySettings} } = keys %UserDirtySettingsLookup;
    }
    elsif ( $Param{DirtySettings} && !$Param{AllSettings} && !$Param{NotDirty} ) {

        my @DirtySettings;

        SETTING:
        for my $Setting ( @{ $Param{DirtySettings} } ) {
            next SETTING if !$UserDirtySettingsLookup{$Setting};
            push @DirtySettings, $Setting;
        }

        $Param{DirtySettings} = \@DirtySettings;
    }

    my @DirtyDefaultList = $SysConfigDBObject->DefaultSettingListGet(
        IsDirty => 1,
    );

    my $AddNewDeployment;

    # Check if deployment is really needed
    if ( $Param{NotDirty} ) {

        # Check if default settings are to be deployed
        if (@DirtyDefaultList) {
            $AddNewDeployment = 1;
        }
    }
    elsif ( $Param{AllSettings} ) {

        my @DirtyModifiedSettings = $SysConfigDBObject->ModifiedSettingListGet(
            IsDirty => 1,
        );

        # Check if default settings or modified are to be deployed
        if ( @DirtyDefaultList || @DirtyModifiedSettings ) {
            $AddNewDeployment = 1;
        }
    }
    elsif ( $Param{DirtySettings} ) {

        # Check if default settings or user modified settings are to be deployed
        if ( @DirtyDefaultList || IsArrayRefWithData( $Param{DirtySettings} ) ) {
            $AddNewDeployment = 1;
        }
    }

    # In case none of the previous options applied and there is no deployment in the database,
    #   a new deployment is needed.
    my %LastDeployment = $SysConfigDBObject->DeploymentGetLast();
    if ( !%LastDeployment ) {
        $AddNewDeployment = 1;
    }

    my $EffectiveValueStrg = '';

    my @Settings = $Self->_GetSettingsToDeploy(%Param);

    SETTING:
    for my $CurrentSetting (@Settings) {

        my %Setting = $Self->SettingGet(
            Name    => $CurrentSetting->{Name},
            Default => 1,
        );

        %Setting = ( %Setting, %{$CurrentSetting} );

        next SETTING if !$Setting{IsValid};

        my %EffectiveValueCheck = $Self->SettingEffectiveValueCheck(
            XMLContentParsed => $Setting{XMLContentParsed},
            EffectiveValue   => $Setting{EffectiveValue},
            NoValidation     => $Param{NoValidation} //= 0,
            UserID           => $Param{UserID},
        );

        next SETTING if $EffectiveValueCheck{Success};

        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Setting $Setting{Name} Effective value is not correct: $EffectiveValueCheck{Error}",
        );
        return;
    }

    # Combine settings effective values into a perl string
    if ( IsArrayRefWithData( \@Settings ) ) {
        $EffectiveValueStrg = $Self->_EffectiveValues2PerlFile(
            Settings   => \@Settings,
            TargetPath => $TargetPath,
        );
        if ( !defined $EffectiveValueStrg ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Could not combine settings values into a perl hash",
            );

            return;
        }
    }

    # Force new deployment if current DB settings are different from the last deployment.
    if ( !$AddNewDeployment ) {

        # Remove CurrentDeploymentID line for easy compare.
        my $LastDeploymentStrg = $LastDeployment{EffectiveValueStrg};
        $LastDeploymentStrg =~ s{\$Self->\{'CurrentDeploymentID'\} [ ] = [ ] '\d+';\n}{}msx;

        if ( $EffectiveValueStrg ne $LastDeploymentStrg ) {
            $AddNewDeployment = 1;
        }
    }

    if ($AddNewDeployment) {

        # Lock the deployment to be able add it to the DB.
        my $ExclusiveLockGUID = $SysConfigDBObject->DeploymentLock(
            UserID => $Param{UserID},
            Force  => $Param{Force},
        );
        if ( !$ExclusiveLockGUID ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Can not lock the deployment for UserID '$Param{UserID}'!",
            );

            return;
        }

        # Get system time stamp (string formated).
        my $DateTimeObject = $Kernel::OM->Create(
            'Kernel::System::DateTime'
        );
        my $TimeStamp = $DateTimeObject->ToString();

        my $HandleSettingsSuccess = $Self->_HandleSettingsToDeploy(
            %Param,
            DeploymentTimeStamp => $TimeStamp,
        );

        my $DeploymentID;

        if ($HandleSettingsSuccess) {

            # Add a new deployment in the DB.
            $DeploymentID = $SysConfigDBObject->DeploymentAdd(
                Comments            => $Param{Comments},
                EffectiveValueStrg  => \$EffectiveValueStrg,
                ExclusiveLockGUID   => $ExclusiveLockGUID,
                DeploymentTimeStamp => $TimeStamp,
                UserID              => $Param{UserID},
            );
            if ( !$DeploymentID ) {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message  => "Could not create the deployment in the DB!",
                );

            }
        }

        # Unlock the deployment, so new deployments can be added afterwards.
        my $Unlock = $SysConfigDBObject->DeploymentUnlock(
            ExclusiveLockGUID => $ExclusiveLockGUID,
            UserID            => $Param{UserID},
        );
        if ( !$Unlock ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Could not remove deployment lock for UserID '$Param{UserID}'",
            );
        }

        # Make sure to return on errors after we unlock the deployment.
        if ( !$HandleSettingsSuccess || !$DeploymentID ) {
            return;
        }

        my $CacheObject = $Kernel::OM->Get('Kernel::System::Cache');

        # Delete categories cache.
        $CacheObject->Delete(
            Type => 'SysConfig',
            Key  => 'ConfigurationCategoriesGet',
        );

        $CacheObject->CleanUp(
            Type => 'SysConfigInvalid',
        );
    }
    else {
        $EffectiveValueStrg = $LastDeployment{EffectiveValueStrg};
    }

    # Base folder for deployment could be not present.
    if ( !-d $BasePath ) {
        mkdir $BasePath;
    }

    return $Self->_FileWriteAtomic(
        Filename => "$Self->{Home}/$TargetPath",
        Content  => \$EffectiveValueStrg,
    );
}
</pre></div>

<p>Write configuration items from database into a perl module file.</p>

<pre>    my $Success = $SysConfigObject-&gt;ConfigurationDeploy(
        Comments            =&gt; &quot;Some comments&quot;,     # (optional)
        NoValidation        =&gt; 0,                   # (optional) 1 or 0, default 0, skips settings validation
        UserID              =&gt; 123,                 # if ExclusiveLockGUID is used, UserID must match the user that creates the lock
        Force               =&gt; 1,                   # (optional) proceed even if lock is set to another user
        NotDirty            =&gt; 1,                   # (optional) do not use any values from modified dirty settings
        AllSettings         =&gt; 1,                   # (optional) use dirty modified settings from all users
        DirtySettings       =&gt; [                    # (optional) use only this dirty modified settings from the current user
            'SettingOne',
            'SettingTwo',
        ],
    );
</pre><p>Returns:</p>

<pre>    $Success = 1;    # or false in case of an error
</pre><h2 id="ConfigurationDeployList">ConfigurationDeployList()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationDeployList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationDeployList">
                                        <pre>

sub ConfigurationDeployList {
    my ( $Self, %Param ) = @_;

    return $Kernel::OM->Get('Kernel::System::SysConfig::DB')->DeploymentListGet();
}
</pre></div>

<p>Get deployment list with complete data.</p>

<pre>    my @List = $SysConfigObject-&gt;ConfigurationDeployList();
</pre><p>Returns:</p>

<pre>    @List = (
        {
            DeploymentID       =&gt; 123,
            Comments           =&gt; 'Some Comments',
            EffectiveValueStrg =&gt; $SettingEffectiveValues,      # String with the value of all settings,
                                                                #   as seen in the Perl configuration file.
            CreateTime         =&gt; &quot;2016-05-29 11:04:04&quot;,
            CreateBy           =&gt; 123,
        },
        {
            DeploymentID       =&gt; 456,
            Comments           =&gt; 'Some Comments',
            EffectiveValueStrg =&gt; $SettingEffectiveValues2,     # String with the value of all settings,
                                                                #   as seen in the Perl configuration file.
            CreateTime         =&gt; &quot;2016-05-29 12:00:01&quot;,
            CreateBy           =&gt; 123,
        },
        # ...
    );
</pre><h2 id="ConfigurationDeploySync_Updates_code">ConfigurationDeploySync()
Updates <code>ZZZAAuto.pm</code> to the latest deployment found in the database.</h2>

<pre>    my $Success = $SysConfigObject-&gt;ConfigurationDeploySync();
</pre><h2 id="ConfigurationDeployCleanup">ConfigurationDeployCleanup()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationDeployCleanup');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationDeployCleanup">
                                        <pre>

sub ConfigurationDeployCleanup {
    my ( $Self, %Param ) = @_;

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    my @List = $SysConfigDBObject->DeploymentListGet();
    my @ListIDs = map { $_->{DeploymentID} } @List;

    my $RemainingDeploments = $Kernel::OM->Get('Kernel::Config')->Get('SystemConfiguration::MaximumDeployments') // 20;
    @ListIDs = splice( @ListIDs, $RemainingDeploments );

    DEPLOYMENT:
    for my $DeploymentID (@ListIDs) {

        my $Success = $SysConfigDBObject->DeploymentDelete(
            DeploymentID => $DeploymentID,
        );

        if ( !$Success ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'notice',
                Message  => "Was not possible to delete deployment $DeploymentID!",
            );
            next DEPLOYMENT;
        }
    }

    return 1;
}
</pre></div>

<p>Cleanup old deployments from the database.</p>

<pre>    my $Success = $SysConfigObject-&gt;ConfigurationDeployCleanup();
</pre><p>Returns:</p>

<pre>    $Success = 1;       # or false in case of an error
</pre><h2 id="ConfigurationDeployGet">ConfigurationDeployGet()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationDeployGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationDeployGet">
                                        <pre>

sub ConfigurationDeployGet {
    my ( $Self, %Param ) = @_;

    return $Kernel::OM->Get('Kernel::System::SysConfig::DB')->DeploymentGet(%Param);
}
</pre></div>

<p>Wrapper of Kernel::System::SysConfig::DB::DeploymentGet() - Get deployment information.</p>

<pre>    my %Deployment = $SysConfigDBObject-&gt;ConfigurationDeployGet(
        DeploymentID =&gt; 123,
    );
</pre><p>Returns:</p>

<pre>    %Deployment = (
        DeploymentID       =&gt; 123,
        Comments           =&gt; 'Some Comments',
        EffectiveValueStrg =&gt; $SettingEffectiveValues,      # String with the value of all settings,
                                                            #   as seen in the Perl configuration file.
        CreateTime         =&gt; &quot;2016-05-29 11:04:04&quot;,
        CreateBy           =&gt; 123,
    );
</pre><h2 id="ConfigurationDeployGetLast">ConfigurationDeployGetLast()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationDeployGetLast');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationDeployGetLast">
                                        <pre>

sub ConfigurationDeployGetLast {
    my ( $Self, %Param ) = @_;

    return $Kernel::OM->Get('Kernel::System::SysConfig::DB')->DeploymentGetLast();
}
</pre></div>

<p>Wrapper of Kernel::System::SysConfig::DBDeploymentGetLast() - Get last deployment information.</p>

<pre>    my %Deployment = $SysConfigObject-&gt;ConfigurationDeployGetLast();
</pre><p>Returns:</p>

<pre>    %Deployment = (
        DeploymentID       =&gt; 123,
        Comments           =&gt; 'Some Comments',
        EffectiveValueStrg =&gt; $SettingEffectiveValues,      # String with the value of all settings,
                                                            #   as seen in the Perl configuration file.
        CreateTime         =&gt; &quot;2016-05-29 11:04:04&quot;,
        CreateBy           =&gt; 123,
    );
</pre><h2 id="ConfigurationDeploySettingsListGet">ConfigurationDeploySettingsListGet()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationDeploySettingsListGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationDeploySettingsListGet">
                                        <pre>

sub ConfigurationDeploySettingsListGet {
    my ( $Self, %Param ) = @_;

    if ( !$Param{DeploymentID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Need DeploymentID",
        );
        return;
    }

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    # get modified version of this deployment
    my %ModifiedVersionList = $SysConfigDBObject->DeploymentModifiedVersionList(
        DeploymentID => $Param{DeploymentID},
    );

    my @ModifiedVersions = sort keys %ModifiedVersionList;

    my @Settings;
    for my $ModifiedVersionID ( sort @ModifiedVersions ) {

        my %Versions;

        # Get the modified version.
        my %ModifiedSettingVersion = $SysConfigDBObject->ModifiedSettingVersionGet(
            ModifiedVersionID => $ModifiedVersionID,
        );

        # Get default version.
        my %DefaultSetting = $SysConfigDBObject->DefaultSettingVersionGet(
            DefaultVersionID => $ModifiedSettingVersion{DefaultVersionID},
        );

        # Update default setting attributes.
        for my $Attribute (
            qw(ModifiedID IsValid EffectiveValue IsDirty CreateTime ChangeTime)
            )
        {
            $DefaultSetting{$Attribute} = $ModifiedSettingVersion{$Attribute};
        }

        $DefaultSetting{ModifiedVersionID} = $ModifiedVersionID;

        push @Settings, \%DefaultSetting;
    }

    return @Settings;
}
</pre></div>

<p>Gets full modified settings information contained on a given deployment.</p>

<pre>    my @List = $SysConfigObject-&gt;ConfigurationDeploySettingsListGet(
        DeploymentID =&gt; 123,
    );
</pre><p>Returns:</p>

<pre>    @List = (
        {
            DefaultID                =&gt; 123,
            ModifiedID               =&gt; 456,
            ModifiedVersionID        =&gt; 789,
            Name                     =&gt; &quot;ProductName&quot;,
            Description              =&gt; &quot;Defines the name of the application ...&quot;,
            Navigation               =&gt; &quot;ASimple::Path::Structure&quot;,
            IsInvisible              =&gt; 1,
            IsReadonly               =&gt; 0,
            IsRequired               =&gt; 1,
            IsValid                  =&gt; 1,
            HasConfigLevel           =&gt; 200,
            UserModificationPossible =&gt; 0,       # 1 or 0
            XMLContentRaw            =&gt; &quot;The XML structure as it is on the config file&quot;,
            XMLContentParsed         =&gt; &quot;XML parsed to Perl&quot;,
            EffectiveValue           =&gt; &quot;Product 6&quot;,
            DefaultValue             =&gt; &quot;Product 5&quot;,
            IsModified               =&gt; 1,       # 1 or 0
            IsDirty                  =&gt; 1,       # 1 or 0
            ExclusiveLockGUID        =&gt; 'A32CHARACTERLONGSTRINGFORLOCKING',
            ExclusiveLockUserID      =&gt; 1,
            ExclusiveLockExpiryTime  =&gt; '2016-05-29 11:09:04',
            CreateTime               =&gt; &quot;2016-05-29 11:04:04&quot;,
            ChangeTime               =&gt; &quot;2016-05-29 11:04:04&quot;,
        },
        {
            DefaultID         =&gt; 321,
            ModifiedID        =&gt; 654,
            ModifiedVersionID =&gt; 987,
             Name             =&gt; 'FieldName',
            # ...
            CreateTime =&gt; '2010-09-11 10:08:00',
            ChangeTime =&gt; '2011-01-01 01:01:01',
        },
        # ...
    );
</pre><h2 id="ConfigurationIsDirtyCheck">ConfigurationIsDirtyCheck()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationIsDirtyCheck');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationIsDirtyCheck">
                                        <pre>

sub ConfigurationIsDirtyCheck {
    my ( $Self, %Param ) = @_;

    return $Kernel::OM->Get('Kernel::System::SysConfig::DB')->ConfigurationIsDirty(%Param);
}
</pre></div>

<p>Check if there are not deployed changes on system configuration.</p>

<pre>    my $Result = $SysConfigObject-&gt;ConfigurationIsDirtyCheck(
        UserID =&gt; 123,      # optional, the user that changes a modified setting
    );
</pre><p>Returns:</p>

<pre>    $Result = 1;    # or 0 if configuration is not dirty.
</pre><h2 id="ConfigurationDump">ConfigurationDump()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationDump');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationDump">
                                        <pre>

sub ConfigurationDump {
    my ( $Self, %Param ) = @_;

    my %UserList = $Kernel::OM->Get('Kernel::System::User')->UserList(
        Valid => 1,
    );

    my $Result = {};

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    if ( !$Param{SkipDefaultSettings} ) {

        my @SettingsList = $SysConfigDBObject->DefaultSettingListGet();

        SETTING:
        for my $Setting (@SettingsList) {
            if ( $Param{OnlyValues} ) {
                $Result->{Default}->{ $Setting->{Name} } = $Setting->{EffectiveValue};
                next SETTING;
            }
            $Result->{Default}->{ $Setting->{Name} } = $Setting;
        }

    }

    if ( !$Param{SkipModifiedSettings} || !$Param{SkipUserSettings} ) {
        my @SettingsList;

        if ( !$Param{DeploymentID} ) {
            @SettingsList = $SysConfigDBObject->ModifiedSettingListGet();
        }
        else {
            # Get the modified versions involved into the deployment
            my %ModifiedVersionList = $SysConfigDBObject->DeploymentModifiedVersionList(
                DeploymentID => $Param{DeploymentID},
            );

            return if !%ModifiedVersionList;

            my @ModifiedVersions = sort keys %ModifiedVersionList;

            MODIFIEDVERSIONID:
            for my $ModifiedVersionID (@ModifiedVersions) {

                my %ModifiedSettingVersion = $SysConfigDBObject->ModifiedSettingVersionGet(
                    ModifiedVersionID => $ModifiedVersionID,
                );
                next MODIFIEDVERSIONID if !%ModifiedSettingVersion;

                push @SettingsList, \%ModifiedSettingVersion;
            }
        }

        SETTING:
        for my $Setting (@SettingsList) {
            next SETTING if $Setting->{TargetUserID};
            next SETTING if $Param{SkipModifiedSettings} && !$Setting->{TargetUserID};

            if ( $Param{OnlyValues} ) {
                $Result->{'Modified'}->{ $Setting->{Name} } = $Setting->{EffectiveValue};
                next SETTING;
            }
            $Result->{'Modified'}->{ $Setting->{Name} } = $Setting;
        }
    }

    my $YAMLString = $Kernel::OM->Get('Kernel::System::YAML')->Dump(
        Data => $Result,
    );

    return $YAMLString;
}
</pre></div>

<p>Creates a YAML file with the system configuration settings.</p>

<pre>    my $ConfigurationDumpYAML = $SysConfigObject-&gt;ConfigurationDump(
        OnlyValues           =&gt; 0,  # optional, default 0, dumps only the setting effective value instead of the whole setting attributes.
        SkipDefaultSettings  =&gt; 0,  # optional, default 0, do not include default settings
        SkipModifiedSettings =&gt; 0,  # optional, default 0, do not include modified settings
        SkipUserSettings     =&gt; 0,  # optional, default 0, do not include user settings
        DeploymentID         =&gt; 123, # optional, if it is provided the modified settings are retrieved from versions
    );
</pre><p>Returns:</p>

<pre>    my $ConfigurationDumpYAML = '---
Default:
  Setting1:
    DefaultID: 23766
    Name: Setting1
    # ...
  Setting2:
  # ...
Modified:
  Setting1
    DefaultID: 23776
    ModifiedID: 1250
    Name: Setting1
    # ...
  # ...
JDoe:
  Setting2
    DefaultID: 23777
    ModifiedID: 1251
    Name: Setting2
    # ...
  # ...
# ...
</pre><p>or</p>

<pre>    my $ConfigurationDumpYAML = $SysConfigObject-&gt;ConfigurationDump(
        OnlyValues =&gt; 1,
    );
</pre><p>Returns:</p>

<pre>    my $ConfigurationDumpYAML = '---
Default:
  Setting1: Test
  Setting2: Test
  # ...
Modified:
  Setting1: TestUpdate
  # ...
JDoe:
  Setting2: TestUser
  # ...
# ...
';
</pre><h2 id="ConfigurationLoad">ConfigurationLoad()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationLoad');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationLoad">
                                        <pre>

sub ConfigurationLoad {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(ConfigurationYAML UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!",
            );

            return;
        }
    }

    my %ConfigurationRaw
        = %{ $Kernel::OM->Get('Kernel::System::YAML')->Load( Data => $Param{ConfigurationYAML} ) || {} };

    if ( !%ConfigurationRaw ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "ConfigurationYAML is invalid!",
        );

        return;
    }

    my $UserObject = $Kernel::OM->Get('Kernel::System::User');

    # Get the configuration sections to import (skip Default and non existing users).
    my $ValidSections;
    my %Configuration;
    SECTION:
    for my $Section ( sort keys %ConfigurationRaw ) {

        next SECTION if $Section eq 'Default';

        if ( $Section eq 'Modified' ) {
            $Configuration{$Section} = $ConfigurationRaw{$Section};
            next SECTION;
        }
    }

    # Early return if there is nothing to update.
    return 1 if !%Configuration;

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');
    my $Result            = 1;

    SECTION:
    for my $Section ( sort keys %Configuration ) {

        my $UserID      = '';
        my $ScopeString = '(global)';

        SETTINGNAME:
        for my $SettingName ( sort keys %{ $Configuration{$Section} } ) {

            my %CurrentSetting = $Self->SettingGet(
                Name => $SettingName,
            );

            # Set error in case non existing settings (either default or modified);
            if ( !%CurrentSetting ) {
                $Result = '-1';
                next SETTINGNAME;
            }

            my $ExclusiveLockGUID = $SysConfigDBObject->DefaultSettingLock(
                Name   => $SettingName,
                Force  => 1,
                UserID => $UserID || $Param{UserID},
            );

            my %Result = $Self->SettingUpdate(
                Name              => $SettingName,
                IsValid           => $CurrentSetting{IsValid},
                EffectiveValue    => $Configuration{$Section}->{$SettingName}->{EffectiveValue},
                ExclusiveLockGUID => $ExclusiveLockGUID,
                UserID            => $UserID || $Param{UserID},
            );
            if ( !$Result{Success} ) {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message  => "Setting $SettingName $ScopeString was not correctly updated!",
                );

                $Result = '-1';
            }
        }
    }

    return $Result;
}
</pre></div>

<p>Takes a YAML file with settings definition and try to import it into the system.</p>

<pre>    my $Success = $SysConfigObject-&gt;ConfigurationLoad(
        ConfigurationYAML   =&gt; $YAMLString,     # a YAML string in the format of L&lt;ConfigurationDump()&gt;
        UserID              =&gt; 123,
    );
</pre><h2 id="ConfigurationDirtySettingsList">ConfigurationDirtySettingsList()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationDirtySettingsList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationDirtySettingsList">
                                        <pre>

sub ConfigurationDirtySettingsList {
    my ( $Self, %Param ) = @_;

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    my @DefaultSettingsList = $SysConfigDBObject->DefaultSettingListGet(
        IsDirty => 1,
    );
    @DefaultSettingsList = map { $_->{Name} } @DefaultSettingsList;

    my @ModifiedSettingsList = $SysConfigDBObject->ModifiedSettingListGet(
        IsDirty  => 1,
        IsGlobal => 1,
        ChangeBy => $Param{ChangeBy} || undef,
    );
    @ModifiedSettingsList = map { $_->{Name} } @ModifiedSettingsList;

    # Combine Default and Modified dirty settings.
    my @ListNames = ( @DefaultSettingsList, @ModifiedSettingsList );
    my %Names = map { $_ => 1 } @ListNames;
    @ListNames = sort keys %Names;

    return @ListNames;
}
</pre></div>

<p>Returns a list of setting names that are dirty.</p>

<pre>    my @Result = $SysConfigObject-&gt;ConfigurationDirtySettingsList(
        ChangeBy =&gt; 123,
    );
</pre><p>Returns:</p>

<pre>    $Result = ['SettingA', 'SettingB', 'SettingC'];
</pre><h2 id="ConfigurationLockedSettingsList">ConfigurationLockedSettingsList()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationLockedSettingsList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationLockedSettingsList">
                                        <pre>

sub ConfigurationLockedSettingsList {
    my ( $Self, %Param ) = @_;

    my @DefaultSettingsList = $Kernel::OM->Get('Kernel::System::SysConfig::DB')->DefaultSettingListGet(
        Locked => 1,
    );

    return if !IsArrayRefWithData( \@DefaultSettingsList );

    if ( $Param{ExclusiveLockUserID} ) {
        @DefaultSettingsList
            = map { $_->{Name} } grep { $_->{ExclusiveLockUserID} eq $Param{ExclusiveLockUserID} } @DefaultSettingsList;
    }
    else {
        @DefaultSettingsList = map { $_->{Name} } @DefaultSettingsList;
    }

    return @DefaultSettingsList;
}
</pre></div>

<p>Returns a list of setting names that are locked in general or by user.</p>

<pre>    my @Result = $SysConfigObject-&gt;ConfigurationLockedSettingsList(
        ExclusiveLockUserID       =&gt; 2, # Optional, ID of the user for which the default setting is locked
    );
</pre><p>Returns:</p>

<pre>    $Result = ['SettingA', 'SettingB', 'SettingC'];
</pre><h2 id="ConfigurationSearch">ConfigurationSearch()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationSearch');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationSearch">
                                        <pre>

sub ConfigurationSearch {
    my ( $Self, %Param ) = @_;

    if ( !$Param{Search} && !$Param{Category} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Search or Category is needed",
        );
        return;
    }

    $Param{Search}   ||= '';
    $Param{Category} ||= '';

    my $Search = lc $Param{Search};

    my %Settings = $Self->ConfigurationTranslatedGet();

    my %Result;

    SETTING:
    for my $SettingName ( sort keys %Settings ) {

        # check category
        if (
            $Param{Category}                    &&
            $Param{Category} ne 'All'           &&
            $Settings{$SettingName}->{Category} &&
            $Settings{$SettingName}->{Category} ne $Param{Category}
            )
        {
            next SETTING;
        }

        # check invisible
        if (
            !$Param{IncludeInvisible}
            && $Settings{$SettingName}->{IsInvisible}
            )
        {
            next SETTING;
        }

        if ( !$Param{Search} ) {
            $Result{$SettingName} = 1;
            next SETTING;
        }

        $Param{Search} =~ s{ +}{ }g;
        my @SearchTerms = split ' ', $Param{Search};

        SEARCHTERM:
        for my $SearchTerm (@SearchTerms) {

            # do not search with the x and/or g modifier as it would produce wrong search results!
            if ( $Settings{$SettingName}->{Metadata} =~ m{\Q$SearchTerm\E}msi ) {

                next SEARCHTERM if $Result{$SettingName};

                $Result{$SettingName} = 1;
            }
        }
    }

    return ( sort keys %Result );
}
</pre></div>

<p>Returns a list of setting names.</p>

<pre>    my @Result = $SysConfigObject-&gt;ConfigurationSearch(
        Search           =&gt; 'The search string', # (optional)
        Category         =&gt; 'OTRSFree'           # (optional)
        IncludeInvisible =&gt; 1,                   # (optional) Default 0.
    );
</pre><p>Returns:</p>

<pre>    $Result = ['SettingA', 'SettingB', 'SettingC'];
</pre><h2 id="ConfigurationCategoriesGet">ConfigurationCategoriesGet()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigurationCategoriesGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigurationCategoriesGet">
                                        <pre>

sub ConfigurationCategoriesGet {
    my ( $Self, %Param ) = @_;

    my $CacheKey  = 'ConfigurationCategoriesGet';
    my $CacheType = 'SysConfig';

    my $CacheObject = $Kernel::OM->Get('Kernel::System::Cache');

    # Return cache.
    my $Cache = $CacheObject->Get(
        Type => $CacheType,
        Key  => $CacheKey,
    );

    return %{$Cache} if ref $Cache eq 'HASH';

    # Set framework files.
    my %Result = (
        All => {
            DisplayName => 'All Settings',
            Files       => [],
        },
        OTRSFree => {
            DisplayName => 'OTRS Free',
            Files       => [
                'Calendar.xml', 'CloudServices.xml', 'Daemon.xml', 'Framework.xml',
                'GenericInterface.xml', 'ProcessManagement.xml', 'Ticket.xml',
            ],
        },
    );

    my @PackageList = $Kernel::OM->Get('Kernel::System::Package')->RepositoryList();

    my $ConfigObject = $Kernel::OM->Get('Kernel::Config');

    # Get files from installed packages.
    PACKAGE:
    for my $Package (@PackageList) {

        next PACKAGE if !$Package->{Name}->{Content};
        next PACKAGE if !IsArrayRefWithData( $Package->{Filelist} );

        my @XMLFiles;
        FILE:
        for my $File ( @{ $Package->{Filelist} } ) {
            $File->{Location} =~ s/\/\//\//g;
            my $Search = 'Kernel/Config/Files/XML/';

            if ( substr( $File->{Location}, 0, length $Search ) ne $Search ) {
                next FILE;
            }

            my $Filename = $File->{Location};
            $Filename =~ s{\AKernel/Config/Files/XML/(.+\.xml)\z}{$1}msxi;
            push @XMLFiles, $Filename;
        }

        next PACKAGE if !@XMLFiles;

        my $PackageName = $Package->{Name}->{Content};
        my $DisplayName = $ConfigObject->Get("SystemConfiguration::Category::Name::$PackageName") || $PackageName;
        $Result{$PackageName} = {
            DisplayName => $DisplayName,
            Files       => \@XMLFiles,
        };
    }

    $CacheObject->Set(
        Type  => $CacheType,
        Key   => $CacheKey,
        Value => \%Result,
        TTL   => 24 * 3600 * 30,    # 1 month
    );

    return %Result;
}
</pre></div>

<p>Returns a list of categories with their filenames.</p>

<pre>    my %Categories = $SysConfigObject-&gt;ConfigurationCategoriesGet();
</pre><p>Returns:</p>

<pre>    %Categories = (
        All =&gt; {
            DisplayName =&gt; 'All Settings',
            Files =&gt; [],
        },
        OTRSFree =&gt; {
            DisplayName =&gt; 'OTRS Free',
            Files       =&gt; ['Calendar.xml', CloudServices.xml', 'Daemon.xml', 'Framework.xml', 'GenericInterface.xml', 'ProcessManagement.xml', 'Ticket.xml' ],
        },
        # ...
    );
</pre><h2 id="ForbiddenValueTypesGet">ForbiddenValueTypesGet()</h2>

<p><a href="#" onclick="toggleCode('method_ForbiddenValueTypesGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ForbiddenValueTypesGet">
                                        <pre>

sub ForbiddenValueTypesGet {
    my ( $Self, %Param ) = @_;

    my $CacheKey  = 'ForbiddenValueTypesGet';
    my $CacheType = 'SysConfig';

    my $CacheObject = $Kernel::OM->Get('Kernel::System::Cache');

    # Return cache.
    my $Cache = $CacheObject->Get(
        Type => $CacheType,
        Key  => $CacheKey,
    );

    return %{$Cache} if ref $Cache eq 'HASH';

    my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

    my @ValueTypes = $Self->_ValueTypesList();

    my %Result;

    for my $ValueType (@ValueTypes) {

        my $Loaded = $MainObject->Require(
            "Kernel::System::SysConfig::ValueType::$ValueType",
        );

        if ($Loaded) {
            my $ValueTypeObject = $Kernel::OM->Get(
                "Kernel::System::SysConfig::ValueType::$ValueType",
            );

            my @ForbiddenValueTypes = $ValueTypeObject->ForbiddenValueTypes();
            if ( scalar @ForbiddenValueTypes ) {
                $Result{$ValueType} = \@ForbiddenValueTypes;
            }
        }
    }

    $CacheObject->Set(
        Type  => $CacheType,
        Key   => $CacheKey,
        Value => \%Result,
        TTL   => 24 * 3600,    # 1 day
    );

    return %Result;
}
</pre></div>

<p>Returns a hash of forbidden value types.</p>

<pre>    my %ForbiddenValueTypes = $SysConfigObject-&gt;ForbiddenValueTypesGet();
</pre><p>Returns:</p>

<pre>    %ForbiddenValueType = (
        String =&gt; [],
        Select =&gt; ['Option'],
        ...
    );
</pre><h2 id="ValueAttributeList">ValueAttributeList()</h2>

<p><a href="#" onclick="toggleCode('method_ValueAttributeList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ValueAttributeList">
                                        <pre>

sub ValueAttributeList {

    my ( $Self, %Param ) = @_;

    my $CacheKey  = 'ValueAttributeList';
    my $CacheType = 'SysConfig';

    my $CacheObject = $Kernel::OM->Get('Kernel::System::Cache');

    # Return cache.
    my $Cache = $CacheObject->Get(
        Type => $CacheType,
        Key  => $CacheKey,
    );

    return @{$Cache} if ref $Cache eq 'ARRAY';

    my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

    my @ValueTypes = $Self->_ValueTypesList();

    my @Result;

    for my $ValueType (@ValueTypes) {

        my $Loaded = $MainObject->Require(
            "Kernel::System::SysConfig::ValueType::$ValueType",
        );

        if ($Loaded) {
            my $ValueTypeObject = $Kernel::OM->Get(
                "Kernel::System::SysConfig::ValueType::$ValueType",
            );

            my $ValueAttribute = $ValueTypeObject->ValueAttributeGet();
            if ( !grep { $_ eq $ValueAttribute } @Result ) {
                push @Result, $ValueAttribute;
            }
        }
    }

    $CacheObject->Set(
        Type  => $CacheType,
        Key   => $CacheKey,
        Value => \@Result,
        TTL   => 24 * 3600,    # 1 day
    );

    return @Result;
}
</pre></div>

<p>Returns a hash of forbidden value types.</p>

<pre>    my @ValueAttributeList = $SysConfigObject-&gt;ValueAttributeList();
</pre><p>Returns:</p>

<pre>    @ValueAttributeList = (
        &quot;Content&quot;,
        &quot;SelectedID&quot;,
    );
</pre><h2 id="ConfigItemGet">ConfigItemGet()</h2>

<p><a href="#" onclick="toggleCode('method_ConfigItemGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ConfigItemGet">
                                        <pre>

sub ConfigItemGet {
    my ( $Self, %Param ) = @_;

    return $Self->SettingGet(%Param);
}
</pre></div>

<p>(Deprecated and should be removed in further versions of OTRS) Get SysConfig setting attributes.</p>

<pre>    my %Setting = $SysConfigObject-&gt;ConfigItemGet(
        Name            =&gt; 'Setting::Name',  # Setting name
        Default         =&gt; 1,                # Returns the default setting attributes only
        ModifiedID      =&gt; '123',            # (optional) Get setting value for given ModifiedID.
        Deployed        =&gt; 1,                # (optional) Get deployed setting value. Default 0.
        Translate       =&gt; 1,                # (optional) Translate translatable strings in EffectiveValue. Default 0.
        NoLog           =&gt; 1,                # (optional) Do not log error if a setting does not exist.
    );
</pre><p>Returns:</p>

<pre>    %Setting = (
        DefaultID                =&gt; 123,
        ModifiedID               =&gt; 456,         # optional
        Name                     =&gt; &quot;ProductName&quot;,
        Description              =&gt; &quot;Defines the name of the application ...&quot;,
        Navigation               =&gt; &quot;ASimple::Path::Structure&quot;,
        IsInvisible              =&gt; 1,           # 1 or 0
        IsReadonly               =&gt; 0,           # 1 or 0
        IsRequired               =&gt; 1,           # 1 or 0
        IsModified               =&gt; 1,           # 1 or 0
        IsValid                  =&gt; 1,           # 1 or 0
        HasConfigLevel           =&gt; 200,
        UserModificationPossible =&gt; 0,           # 1 or 0
        UserModificationActive   =&gt; 0,           # 1 or 0
        UserPreferencesGroup     =&gt; 'Advanced',  # optional
        XMLContentRaw            =&gt; &quot;The XML structure as it is on the config file&quot;,
        XMLContentParsed         =&gt; &quot;XML parsed to Perl&quot;,
        XMLFilename              =&gt; &quot;Framework.xml&quot;,
        EffectiveValue           =&gt; &quot;Product 6&quot;,
        IsDirty                  =&gt; 1,           # 1 or 0
        ExclusiveLockGUID        =&gt; 'A32CHARACTERLONGSTRINGFORLOCKING',
        ExclusiveLockUserID      =&gt; 1,
        ExclusiveLockExpiryTime  =&gt; '2016-05-29 11:09:04',
        CreateTime               =&gt; &quot;2016-05-29 11:04:04&quot;,
        CreateBy                 =&gt; 1,
        ChangeTime               =&gt; &quot;2016-05-29 11:04:04&quot;,
        ChangeBy                 =&gt; 1,
        DefaultValue             =&gt; 'Old default value',
    );
</pre><h1 id="PRIVATE_INTERFACE">PRIVATE INTERFACE <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<h2 id="FileWriteAtomic">_FileWriteAtomic()</h2>

<p><a href="#" onclick="toggleCode('method__FileWriteAtomic');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method__FileWriteAtomic">
                                        <pre>

sub _FileWriteAtomic {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(Filename Content)) {
        if ( !defined $Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!"
            );
            return;
        }
    }

    my $TempFilename = $Param{Filename} . '.' . $$;
    my $FH;

    ## no critic
    if ( !open( $FH, ">$Self->{FileMode}", $TempFilename ) ) {
        ## use critic

        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Can't open file $TempFilename: $!",
        );
        return;
    }

    print $FH ${ $Param{Content} };
    close $FH;

    if ( !rename $TempFilename, $Param{Filename} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Could not rename $TempFilename to $Param{Filename}: $!"
        );
        return;
    }

    return 1;
}
</pre></div>

<p>Writes a file in an atomic operation. This is achieved by creating
a temporary file, filling and renaming it. This avoids inconsistent states
when the file is updated.</p>

<pre>    my $Success = $SysConfigObject-&gt;_FileWriteAtomic(
        Filename =&gt; &quot;$Self-&gt;{Home}/Kernel/Config/Files/ZZZAAuto.pm&quot;,
        Content  =&gt; \$NewContent,
    );
</pre><h2 id="ConfigurationTranslatableStrings-2">_ConfigurationTranslatableStrings()</h2>

<p><a href="#" onclick="toggleCode('method__ConfigurationTranslatableStrings');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method__ConfigurationTranslatableStrings">
                                        <pre>

sub _ConfigurationTranslatableStrings {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(Data)) {
        if ( !defined $Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!"
            );
            return;
        }
    }

    # Start recursion if its an array.
    if ( ref $Param{Data} eq 'ARRAY' ) {

        KEY:
        for my $Key ( @{ $Param{Data} } ) {
            next KEY if !$Key;
            $Self->_ConfigurationTranslatableStrings( Data => $Key );
        }
        return;
    }

    # Start recursion if its a Hash.
    if ( ref $Param{Data} eq 'HASH' ) {
        for my $Key ( sort keys %{ $Param{Data} } ) {
            if (
                ref $Param{Data}->{$Key} eq ''
                && $Param{Data}->{Translatable}
                && $Param{Data}->{Content}
                )
            {
                return if !$Param{Data}->{Content};
                return if $Param{Data}->{Content} =~ /^\d+$/;
                $Self->{ConfigurationTranslatableStrings}->{ $Param{Data}->{Content} } = 1;
            }
            $Self->_ConfigurationTranslatableStrings( Data => $Param{Data}->{$Key} );
        }
    }
    return;
}
</pre></div>

<p>Gathers strings marked as translatable from a setting XML parsed content and saves it on
ConfigurationTranslatableStrings global variable.</p>

<pre>    $SysConfigObject-&gt;_ConfigurationTranslatableStrings(
        Data =&gt; $Data,      # could be SCALAR, ARRAY or HASH
    );
</pre><h2 id="DBCleanUp">_DBCleanUp();</h2>

<p><a href="#" onclick="toggleCode('method__DBCleanUp');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method__DBCleanUp">
                                        <pre>

sub _DBCleanUp {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(Settings)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!"
            );
            return;
        }
    }
    if ( !IsHashRefWithData( $Param{Settings} ) ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Settings must be an HashRef!"
        );
        return;
    }

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    my @SettingsDB = $SysConfigDBObject->DefaultSettingListGet();

    my ( $DefaultUpdated, $ModifiedUpdated );

    for my $SettingDB (@SettingsDB) {

        # Cleanup database if the setting is not present in the XML files.
        if ( !$Param{Settings}->{ $SettingDB->{Name} } ) {

            # Get all modified settings.
            my @ModifiedSettings = $SysConfigDBObject->ModifiedSettingListGet(
                Name => $SettingDB->{Name},
            );

            for my $ModifiedSetting (@ModifiedSettings) {

                # Delete from modified table.
                my $SuccessDeleteModified = $SysConfigDBObject->ModifiedSettingDelete(
                    ModifiedID => $ModifiedSetting->{ModifiedID},
                );
                if ( !$SuccessDeleteModified ) {
                    $Kernel::OM->Get('Kernel::System::Log')->Log(
                        Priority => 'error',
                        Message  => "System couldn't delete $SettingDB->{Name} from DB (sysconfig_modified)!"
                    );
                }
            }

            my @ModifiedSettingVersions = $SysConfigDBObject->ModifiedSettingVersionListGet(
                Name => $SettingDB->{Name},
            );

            for my $ModifiedSettingVersion (@ModifiedSettingVersions) {

                # Delete from modified table.
                my $SuccessDeleteModifiedVersion = $SysConfigDBObject->ModifiedSettingVersionDelete(
                    ModifiedVersionID => $ModifiedSettingVersion->{ModifiedVersionID},
                );
                if ( !$SuccessDeleteModifiedVersion ) {
                    $Kernel::OM->Get('Kernel::System::Log')->Log(
                        Priority => 'error',
                        Message  => "System couldn't delete $SettingDB->{Name} from DB (sysconfig_modified_version)!"
                    );
                }
            }

            # Delete from default table.
            my $SuccessDefaultSetting = $SysConfigDBObject->DefaultSettingDelete(
                Name => $SettingDB->{Name},
            );
            if ( !$SuccessDefaultSetting ) {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message  => "System couldn't delete $SettingDB->{Name} from DB (sysconfig_default)!"
                );
            }
        }
    }

    return 1;
}
</pre></div>

<p>Removes all settings defined in the database (including default and modified) that are not included
in the settings parameter</p>

<pre>    my $Success = $SysConfigObject-&gt;_DBCleanUp(
        Settings =&gt; {
            'ACL::CacheTTL' =&gt; {
                XMLContentParsed =&gt; '
                    &lt;Setting Name=&quot;SettingName&quot; Required=&quot;1&quot; Valid=&quot;1&quot;&gt;
                        &lt;Description Translatable=&quot;1&quot;&gt;Test.&lt;/Description&gt;
                        # ...
                    &lt;/Setting&gt;',
                XMLContentRaw =&gt; {
                    Description =&gt; [
                        {
                            Content      =&gt; 'Test.',
                            Translatable =&gt; '1',
                        },
                    ],
                    Name  =&gt; 'Test',
                    # ...
                },
            # ...
        };
    );
</pre><p>Returns:</p>

<pre>    $Success = 1;       # or false in case of a failure
</pre><h2 id="NavigationTree">_NavigationTree();</h2>

<p><a href="#" onclick="toggleCode('method__NavigationTree');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method__NavigationTree">
                                        <pre>

sub _NavigationTree {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(Tree Array)) {
        if ( !defined $Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!",
            );
            return;
        }
    }

    my %Result = %{ $Param{Tree} };

    return %Result if !IsArrayRefWithData( $Param{Array} );

    # Check if first item exists.
    if ( !defined $Result{ $Param{Array}->[0] } ) {
        $Result{ $Param{Array}->[0] } = {};
    }

    # Check if it's deeper tree.
    if ( scalar @{ $Param{Array} } > 1 ) {
        my @SubArray = splice( @{ $Param{Array} }, 1 );
        my %Hash = $Self->_NavigationTree(
            Tree  => $Result{ $Param{Array}->[0] },
            Array => \@SubArray,
        );

        if (%Hash) {
            $Result{ $Param{Array}->[0] } = \%Hash;
        }
    }

    return %Result;
}
</pre></div>

<p>Returns navigation as a tree (in a hash).</p>

<pre>    my %Result = $SysConfigObject-&gt;_NavigationTree(
        'Array' =&gt; [                            # Array of setting navigation items
            'Core',
            'Core::CustomerUser',
            'Frontend',
        ],
        'Tree' =&gt; {                             # Result from previous recursive call
            'Core' =&gt; {
                'Core::CustomerUser' =&gt; {},
            },
        },
    );
</pre><p>Returns:</p>

<pre>    %Result = (
        'Core' =&gt; {
            'Core::CustomerUser' =&gt; {},
        },
        'Frontend' =&gt; {},
    );
</pre><h2 id="ConfigurationEntitiesGet-2">_ConfigurationEntitiesGet();</h2>

<p><a href="#" onclick="toggleCode('method__ConfigurationEntitiesGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method__ConfigurationEntitiesGet">
                                        <pre>

sub _ConfigurationEntitiesGet {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(Value Result Name)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!",
            );
            return;
        }
    }

    my %Result = %{ $Param{Result} || {} };
    my $ValueEntityType = $Param{ValueEntityType} || '';

    if ( ref $Param{Value} eq 'ARRAY' ) {
        for my $Item ( @{ $Param{Value} } ) {
            %Result = $Self->_ConfigurationEntitiesGet(
                %Param,
                Value  => $Item,
                Result => \%Result,
            );
        }
    }
    elsif ( ref $Param{Value} eq 'HASH' ) {
        if ( $Param{Value}->{ValueEntityType} ) {
            $ValueEntityType = $Param{Value}->{ValueEntityType};
        }

        if ( $Param{Value}->{Content} ) {

            # If there is no hash item, create new.
            if ( !defined $Result{$ValueEntityType} ) {
                $Result{$ValueEntityType} = {};
            }

            # Extract value (without white space).
            $Param{Value}->{Content} =~ m{^\s*(.*?)\s*$}gsmx;
            my $Value = $1 // '';

            # If there is no array, create
            if ( !IsArrayRefWithData( $Result{$ValueEntityType}->{$Value} ) ) {
                $Result{$ValueEntityType}->{$Value} = [];
            }

            # Check if current config is not in the array.
            if ( !grep { $_ eq $Param{Name} } @{ $Result{$ValueEntityType}->{$Value} } ) {
                push @{ $Result{$ValueEntityType}->{$Value} }, $Param{Name};
            }
        }
        else {
            for my $Key (qw(Item Hash Array)) {
                if ( defined $Param{Value}->{$Key} ) {

                    # Contains children
                    %Result = $Self->_ConfigurationEntitiesGet(
                        %Param,
                        ValueEntityType => $ValueEntityType,
                        Value           => $Param{Value}->{$Key},
                        Result          => \%Result,
                    );
                }
            }
        }
    }

    return %Result;
}
</pre></div>

<p>Returns hash of used entities for provided Setting value.</p>

<pre>    my %Result = $SysConfigObject-&gt;_ConfigurationEntitiesGet(
        'Name'   =&gt; 'Ticket::Frontend::AgentTicketPriority###Entity',   # setting name
        'Result' =&gt; {},                                                 # result from previous recursive call
        'Value'  =&gt; [                                                   # setting Value
            {
                'Item' =&gt; [
                    {
                        'Content'         =&gt; '3 medium',
                        'ValueEntityType' =&gt; 'Priority',
                        'ValueRegex'      =&gt; '',
                        'ValueType'       =&gt; 'Entity',
                    },
                ],
            },
        ],
    );
</pre><p>Returns:</p>

<pre>    %Result = {
        'Priority' =&gt; {
            '3 medium' =&gt; [
                'Ticket::Frontend::AgentTicketPriority###Entity',
            ],
        },
    };
</pre><h2 id="EffectiveValues2PerlFile">_EffectiveValues2PerlFile()</h2>

<p><a href="#" onclick="toggleCode('method__EffectiveValues2PerlFile');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method__EffectiveValues2PerlFile">
                                        <pre>

sub _EffectiveValues2PerlFile {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(Settings TargetPath)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!",
            );

            return;
        }
    }
    if ( !IsArrayRefWithData( $Param{Settings} ) ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Settings parameter is invalid!",
        );

        return;
    }

    my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

    my $PerlHashStrg;

    # Convert all settings from DB format to perl file.
    for my $Setting ( @{ $Param{Settings} } ) {

        my $Name = $Setting->{Name};
        $Name =~ s/\\/\\\\/g;
        $Name =~ s/'/\'/g;
        $Name =~ s/###/'}->{'/g;

        if ( $Setting->{IsValid} ) {

            my $EffectiveValue = $MainObject->Dump( $Setting->{EffectiveValue} );
            $EffectiveValue =~ s/\$VAR1 =//;

            $PerlHashStrg .= "\$Self->{'$Name'} = $EffectiveValue";
        }
        elsif ( eval( '$Self->{ConfigDefaultObject}->{\'' . $Name . '\'}' ) ) {
            $PerlHashStrg .= "delete \$Self->{'$Name'};\n";
        }
    }

    chomp $PerlHashStrg;

    # Convert TartgetPath to Package.
    my $TargetPath = $Param{TargetPath};
    $TargetPath =~ s{(.*)\.(?:.*)}{$1}msx;
    $TargetPath =~ s{ / }{::}msxg;

    # Write default config file.
    my $FileStrg = <<"EOF";
# OTRS config file (automatically generated)
# VERSION:2.0
package $TargetPath;
use strict;
use warnings;
no warnings 'redefine';
EOF

    if ( $Self->{utf8} ) {
        $FileStrg .= "use utf8;\n";
    }

    $FileStrg .= <<"EOF";
sub Load {
    my (\$File, \$Self) = \@_;
$PerlHashStrg
}
</pre></div>

<p>Converts effective values from settings into a combined perl hash ready to write into a file.</p>

<pre>    my $FileString = $SysConfigObject-&gt;_EffectiveValues2PerlFile(
        Settings  =&gt; [
            {
                Name           =&gt; 'SettingName',
                IsValid        =&gt; 1,
                EffectiveValue =&gt; $ValueStructure,
            },
            {
                Name           =&gt; 'AnotherSettingName',
                IsValid        =&gt; 0,
                EffectiveValue =&gt; $AnotherValueStructure,
            },
            # ...
        ],
        TargetPath =&gt; 'Kernel/Config/Files/ZZZAAuto.pm',
    );
</pre><h2 id="SettingEffectiveValueCheck-2">_SettingEffectiveValueCheck()</h2>

<p><a href="#" onclick="toggleCode('method__SettingEffectiveValueCheck');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method__SettingEffectiveValueCheck">
                                        <pre>

sub _SettingEffectiveValueCheck {
    my ( $Self, %Param ) = @_;

    # Check needed stuff.
    for my $Needed (qw(XMLContentParsed UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!",
            );
            return;
        }
    }

    # So far everything is OK, we need to check deeper (recursive).
    my $StorableObject = $Kernel::OM->Get('Kernel::System::Storable');

    my $Default = $StorableObject->Clone(
        Data => $Param{XMLContentParsed},
    );

    my $EffectiveValue = $Param{EffectiveValue};

    if ( ref $Param{EffectiveValue} ) {
        $EffectiveValue = $StorableObject->Clone(
            Data => $Param{EffectiveValue},
        );
    }

    return $Self->SettingEffectiveValueCheck(
        XMLContentParsed => $Default,
        EffectiveValue   => $EffectiveValue,
        NoValidation     => $Param{NoValidation},
        UserID           => $Param{UserID},
    );
}
</pre></div>

<p>Recursive helper for SettingEffectiveValueCheck().</p>

<pre>    my %Result = $SysConfigObject-&gt;_SettingEffectiveValueCheck(
        EffectiveValue =&gt; 'open',                           # (optional) The EffectiveValue to be checked,
                                                            #   (could be also a complex structure).
        XMLContentParsed =&gt; {                               # (required) The XMLContentParsed value from Default Setting.
            Value =&gt; [
                {
                    'Item' =&gt; [
                        {
                            'Content' =&gt; &quot;Scalar value&quot;,
                        },
                    ],
                },
            ],
        },
        NoValidation    =&gt; $Param{NoValidation},            # (optional), skip validation
        UserID          =&gt; 1,                               # (required) UserID
    );
</pre><p>Returns:</p>

<pre>    %Result = (
        EffectiveValue =&gt; 'closed',    # Note that EffectiveValue can be changed.
        Success        =&gt; 1,           # or false in case of fail
        Error          =&gt; undef,       # or error string
    );
</pre><h2 id="GetSettingsToDeploy">_GetSettingsToDeploy()</h2>

<p><a href="#" onclick="toggleCode('method__GetSettingsToDeploy');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method__GetSettingsToDeploy">
                                        <pre>

sub _GetSettingsToDeploy {
    my ( $Self, %Param ) = @_;

    if ( !$Param{NotDirty} && !$Param{DirtySettings} ) {
        $Param{AllSettings} = 1;
    }

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    my @DefaultSettingsList = $SysConfigDBObject->DefaultSettingListGet();

    # Create a lookup table for the default settings (for easy adding modified).
    my %SettingsLookup = map { $_->{Name} => $_ } @DefaultSettingsList;

    my @ModifiedSettingsList;

    # Use if - else statement, as the gathering of the settings could be expensive.
    if ( $Param{NotDirty} ) {
        @ModifiedSettingsList = $SysConfigDBObject->ModifiedSettingVersionListGetLast();
    }
    else {
        @ModifiedSettingsList = $SysConfigDBObject->ModifiedSettingListGet(
            IsGlobal => 1
        );
    }

    if ( $Param{AllSettings} || $Param{NotDirty} ) {

        # Create a lookup table for the modified settings (for easy merging with defaults).
        my %ModifiedSettingsLookup = map { $_->{Name} => $_ } @ModifiedSettingsList;

        # Merge modified into defaults.
        %SettingsLookup = ( %SettingsLookup, %ModifiedSettingsLookup );

        my @Settings = map { $SettingsLookup{$_} } ( sort keys %SettingsLookup );

        return @Settings;
    }

    my %DirtySettingsLookup = map { $_ => 1 } @{ $Param{DirtySettings} };

    SETTING:
    for my $Setting (@ModifiedSettingsList) {

        my $SettingName = $Setting->{Name};

        # Skip invalid settings (all modified needs to have a default).
        next SETTING if !$SettingsLookup{$SettingName};

        # Remember modified.
        my %ModifiedSetting = %{$Setting};

        # If setting is not in the given list, then do not use current value but last deployed.
        if ( $Setting->{IsDirty} && !$DirtySettingsLookup{$SettingName} ) {
            %ModifiedSetting = $SysConfigDBObject->ModifiedSettingVersionGetLast(
                Name => $Setting->{Name},
            );

            # If there is not previous version then skip to keep the default intact.
            next SETTING if !%ModifiedSetting;
        }

        $SettingsLookup{$SettingName} = \%ModifiedSetting;
    }

    my @Settings = map { $SettingsLookup{$_} } ( sort keys %SettingsLookup );

    return @Settings;
}
</pre></div>

<p>Returns the correct list of settings for a deployment taking the settings from different sources:</p>

<pre>    NotDirty:      fetch default settings plus already deployed modified settings.
    AllSettings:   fetch default settings plus all modified settings already deployed or not.
    DirtySettings: fetch default settings plus already deployed settings plus all not deployed settings in the list.

    my @SettingList = $SysConfigObject-&gt;_GetSettingsToDeploy(
        NotDirty      =&gt; 1,                                         # optional - exclusive (1||0)
        All           =&gt; 1,                                         # optional - exclusive (1||0)
        DirtySettings =&gt; [ 'SettingName1', 'SettingName2' ],        # optional - exclusive
    );

    @SettingList = (
        {
            DefaultID                =&gt; 123,
            Name                     =&gt; &quot;ProductName&quot;,
            Description              =&gt; &quot;Defines the name of the application ...&quot;,
            Navigation               =&gt; &quot;ASimple::Path::Structure&quot;,
            IsInvisible              =&gt; 1,
            IsReadonly               =&gt; 0,
            IsRequired               =&gt; 1,
            IsValid                  =&gt; 1,
            HasConfigLevel           =&gt; 200,
            UserModificationPossible =&gt; 0,          # 1 or 0
            UserModificationActive   =&gt; 0,          # 1 or 0
            UserPreferencesGroup     =&gt; 'Advanced', # optional
            XMLContentRaw            =&gt; &quot;The XML structure as it is on the config file&quot;,
            XMLContentParsed         =&gt; &quot;XML parsed to Perl&quot;,
            EffectiveValue           =&gt; &quot;Product 6&quot;,
            DefaultValue             =&gt; &quot;Product 5&quot;,
            IsModified               =&gt; 1,       # 1 or 0
            IsDirty                  =&gt; 1,       # 1 or 0
            ExclusiveLockGUID        =&gt; 'A32CHARACTERLONGSTRINGFORLOCKING',
            ExclusiveLockUserID      =&gt; 1,
            ExclusiveLockExpiryTime  =&gt; '2016-05-29 11:09:04',
            CreateTime               =&gt; &quot;2016-05-29 11:04:04&quot;,
            ChangeTime               =&gt; &quot;2016-05-29 11:04:04&quot;,
        },
        {
            DefaultID =&gt; 321,
            Name      =&gt; 'FieldName',
            # ...
            CreateTime =&gt; '2010-09-11 10:08:00',
            ChangeTime =&gt; '2011-01-01 01:01:01',
        },
        # ...
    );
</pre><h2 id="HandleSettingsToDeploy">_HandleSettingsToDeploy()</h2>

<p><a href="#" onclick="toggleCode('method__HandleSettingsToDeploy');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method__HandleSettingsToDeploy">
                                        <pre>

sub _HandleSettingsToDeploy {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(UserID DeploymentTimeStamp)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed",
            );
            return;
        }
    }

    if ( !$Param{NotDirty} && !$Param{DirtySettings} ) {
        $Param{AllSettings} = 1;
    }

    my $SysConfigDBObject = $Kernel::OM->Get('Kernel::System::SysConfig::DB');

    # Remove is dirty flag for default settings.
    my $DefaultCleanup = $SysConfigDBObject->DefaultSettingDirtyCleanUp();
    if ( !$DefaultCleanup ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Could not remove IsDirty flag from default settings",
        );
    }

    return 1 if $Param{NotDirty};

    my %DirtySettingsLookup = map { $_ => 1 } @{ $Param{DirtySettings} // [] };

    # Get all dirty modified settings.
    my @DirtyModifiedList = $SysConfigDBObject->ModifiedSettingListGet(
        IsGlobal => 1,
        IsDirty  => 1,
    );

    my %VersionsAdded;
    my @ModifiedDeleted;
    my @ModifiedIDs;
    my $Error;

    # Create a new version for the modified settings.
    SETTING:
    for my $Setting (@DirtyModifiedList) {

        # Skip setting if it is not in the list (and it is not a full deployment)
        next SETTING if !$Param{AllSettings} && !$DirtySettingsLookup{ $Setting->{Name} };

        my %DefaultSettingVersionGetLast = $SysConfigDBObject->DefaultSettingVersionGetLast(
            DefaultID => $Setting->{DefaultID},
        );

        my $ModifiedVersionID = $SysConfigDBObject->ModifiedSettingVersionAdd(
            %{$Setting},
            DefaultVersionID    => $DefaultSettingVersionGetLast{DefaultVersionID},
            DeploymentTimeStamp => $Param{DeploymentTimeStamp},
            UserID              => $Param{UserID},
        );

        if ( !$ModifiedVersionID ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Could not create a modified setting version for $Setting->{Name}! Rolling back.",
            );
            $Error = 1;
            last SETTING;
        }

        $VersionsAdded{ $Setting->{Name} } = $ModifiedVersionID;

        if ( !$Setting->{ResetToDefault} ) {
            push @ModifiedIDs, $Setting->{ModifiedID};
            next SETTING;
        }

        # In case a setting value reset, delete the modified value.
        my $ModifiedDelete = $SysConfigDBObject->ModifiedSettingDelete(
            ModifiedID => $Setting->{ModifiedID},
        );

        if ( !$ModifiedDelete ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message =>
                    "Could not delete the modified setting for $Setting->{Name} on reset action! Rolling back.",
            );
            $Error = 1;
            last SETTING;
        }

        push @ModifiedDeleted, $Setting;
    }

    # In case of an error:
    #   Remove "all" added versions for "all" settings for this deployment.
    #   Restore "all" deleted modified settings.
    if ($Error) {
        for my $SettingName ( sort keys %VersionsAdded ) {
            my $Success = $SysConfigDBObject->ModifiedSettingVersionDelete(
                ModifiedVersionID => $VersionsAdded{$SettingName},
            );
        }

        for my $Setting (@ModifiedDeleted) {
            my $Success = $SysConfigDBObject->ModifiedAdd(
                %{$Setting},
                UserID => $Setting->{ChangeBy},
            );
        }

        return;
    }

    # Do not clean dirty flag if no setting version was created and it is not a full deployment
    return 1 if !$Param{AllSettings} && !@ModifiedIDs;

    my %Options;
    if ( !$Param{AllSettings} ) {
        $Options{ModifiedIDs} = \@ModifiedIDs;
    }

    # Remove is dirty flag for modified settings.
    my $ModifiedCleanup = $SysConfigDBObject->ModifiedSettingDirtyCleanUp(%Options);
    if ( !$ModifiedCleanup ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Could not remove IsDirty flag from modified settings",
        );
    }

    return 1;
}
</pre></div>

<p>Creates modified versions of dirty settings to deploy and removed the dirty flag.</p>

<pre>    NotDirty:      Removes dirty flag just for default settings
    AllSettings:   Create a version for all dirty settings and removed dirty flags for all default and modified settings
    DirtySettings: Create a version and remove dirty fag for the modified settings in the list, remove dirty flag for all default settings

    my $Success = $SysConfigObject-&gt;_GetSettingsToDeploy(
        NotDirty      =&gt; 1,                                         # optional - exclusive (1||0)
        AllSettings   =&gt; 1,                                         # optional - exclusive (1||0)
        DirtySettings =&gt; [ 'SettingName1', 'SettingName2' ],        # optional - exclusive
    );
</pre><p>Returns:</p>

<pre>    $Success = 1;       # or false in case of a failure
</pre><h2 id="ConfigurationTranslatedGet-2">_ConfigurationTranslatedGet()</h2>

<p><a href="#" onclick="toggleCode('method__ConfigurationTranslatedGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method__ConfigurationTranslatedGet">
                                        <pre>

sub _ConfigurationTranslatedGet {
    my ( $Self, %Param ) = @_;

    # Check needed stuff.
    for my $Needed (qw(Language Name)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!",
            );
            return;
        }
    }

    my $CacheObject = $Kernel::OM->Get('Kernel::System::Cache');

    my $CacheType = '_ConfigurationTranslatedGet';
    my $CacheKey  = "_ConfigurationTranslatedGet::$Param{Language}::$Param{Name}";

    # Return cache.
    my $Cache = $CacheObject->Get(
        Type => $CacheType,
        Key  => $CacheKey,
    );

    return %{$Cache} if ref $Cache eq 'HASH';

    my $YAMLObject = $Kernel::OM->Get('Kernel::System::YAML');
    my %Categories = $Self->ConfigurationCategoriesGet();

    my %SettingTranslated = $Self->SettingGet(
        Name      => $Param{Name},
        Translate => 1,
    );

    my $Metadata = $Param{Name};
    $Metadata .= $YAMLObject->Dump(
        Data => $SettingTranslated{EffectiveValue},
    );
    $Metadata .= $SettingTranslated{Description};

    my %Result;
    $Result{ $Param{Name} }->{Metadata} = lc $Metadata;

    # Check setting category.
    my $SettingCategory;

    my $Silent = $Param{Silent} // 1;

    CATEGORY:
    for my $Category ( sort keys %Categories ) {
        if ( grep { $_ eq $SettingTranslated{XMLFilename} } @{ $Categories{$Category}->{Files} } ) {
            $SettingCategory = $Category;
            last CATEGORY;
        }
    }

    if ( !$SettingCategory ) {
        if ( !$Silent ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Category couldn't be determined for $Param{Name}!",
            );
        }
        $SettingCategory = '-Unknown-';
    }
    $Result{ $Param{Name} }->{Category}    = $SettingCategory;
    $Result{ $Param{Name} }->{IsInvisible} = $SettingTranslated{IsInvisible};

    $CacheObject->Set(
        Type  => $CacheType,
        Key   => $CacheKey,
        Value => \%Result,
        TTL   => $Self->{CacheTTL} || 24 * 60 * 60,
    );

    return %Result;
}
</pre></div>

<p>Helper method for ConfigurationTranslatedGet().</p>

<pre>    my %Result = $SysConfigObject-&gt;_ConfigurationTranslatedGet(
        Language =&gt; 'de',               # (required) User language
        Name     =&gt; 'SettingName',      # (required) Setting name
        Silent   =&gt; 1,                  # (optional) Default 1
    );
</pre><p>Returns:</p>

<pre>    %Result = (
       'ACL::CacheTTL' =&gt; {
            'Category' =&gt; 'OTRSFree',
            'IsInvisible' =&gt; '0',
            'Metadata' =&gt; &quot;ACL::CacheTTL--- '3600'
Cache-Zeit in Sekunden f\x{fc}r Datenbank ACL-Backends.&quot;,
    );
</pre><h2 id="ValueTypesList">_ValueTypesList()</h2>

<p><a href="#" onclick="toggleCode('method__ValueTypesList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method__ValueTypesList">
                                        <pre>

sub _ValueTypesList {
    my ( $Self, %Param ) = @_;

    my $CacheKey  = '_ValueTypesList';
    my $CacheType = 'SysConfig';

    my $CacheObject = $Kernel::OM->Get('Kernel::System::Cache');

    # Return cache.
    my $Cache = $CacheObject->Get(
        Type => $CacheType,
        Key  => $CacheKey,
    );

    return @{$Cache} if ref $Cache eq 'ARRAY';

    my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

    my @Files = $MainObject->DirectoryRead(
        Directory => $Self->{Home} . "/Kernel/System/SysConfig/ValueType",
        Filter    => '*.pm',
    );

    my @Result;
    for my $File (@Files) {

        my $ValueType = $File;

        # Remove folder path.
        $ValueType =~ s{^.*/}{}sm;

        # Remove extension
        $ValueType =~ s{\.pm$}{}sm;

        push @Result, $ValueType;
    }

    $CacheObject->Set(
        Type  => $CacheType,
        Key   => $CacheKey,
        Value => \@Result,
        TTL   => 24 * 3600,    # 1 day
    );

    return @Result;
}
</pre></div>

<p>Returns a hash of forbidden value types.</p>

<pre>    my @ValueTypes = $SysConfigObject-&gt;_ValueTypesList();
</pre><p>Returns:</p>

<pre>    @ValueTypes = (
        &quot;Checkbox&quot;,
        &quot;Select&quot;,
        ...
    );
</pre><h1 id="TERMS_AND_CONDITIONS">TERMS AND CONDITIONS <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<p>This software is part of the OTRS project (<a href="http://otrs.org/">http://otrs.org/</a>).</p>

<p>This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see <a href="http://www.gnu.org/licenses/agpl.txt">http://www.gnu.org/licenses/agpl.txt</a>.</p>


</div><div class="footer">generated by <a href="http://search.cpan.org/perldoc?Pod%3A%3AProjectDocs">Pod::ProjectDocs</a></div></body>
</html>
