<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<!-- otrs.github.io -->
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../../../../../../../../documentation.css">
<script src="https://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../../../../../../../documentation.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script>
$(document).ready(function() {

    // Hint languages to prevent false matches (php for example).
    hljs.configure({
        languages: ['perl', 'javascript', 'xml', 'html', 'css', 'json', 'yaml']
    });

    // programlistings in manuals
    $('pre.programlisting').each(function(i, block) {
        hljs.highlightBlock(block);
    });
    // code snippets in Perl API docs
    $('.pod pre').addClass('perl').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});</script>
<!-- otrs.github.io -->

	<title>Kernel::System::SysConfig::Base::Framework</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <script type="text/javascript">

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  </script></head>
<body>
<div class="box">
  <h1 class="t1">OTRS 6.0 API Reference Perl</h1>
  <table>
    <tr>
      <td class="label">Description</td>
      <td class="cell">manuals and libraries</td>
    </tr>
  </table>
</div>
<div class="path">
  <a href="../../../../index.html">OTRS 6.0 API Reference Perl</a> &gt; Perl Modules &gt;
  Kernel::System::SysConfig::Base::Framework
</div>
<div>
<a href="../../../../src/Kernel/System/SysConfig/Base/Framework.pm">Source</a>
</div>
<div class="pod">
<!-- INDEX START -->
<h3 id="TOP">Index</h3>
<ul>
	<li><a href="#NAME">NAME</a></li>
	<li><a href="#PUBLIC_INTERFACE">PUBLIC INTERFACE</a><br />
<ul>
	<li><a href="#SettingModifiedXMLContentParsedGet">SettingModifiedXMLContentParsedGet()</a></li>
</ul>
</li>
	<li><a href="#PRIVATE_INTERFACE">PRIVATE INTERFACE</a><br />
<ul>
	<li><a href="#ModifiedValueCalculate">_ModifiedValueCalculate()</a></li>
</ul>
</li>
	<li><a href="#TERMS_AND_CONDITIONS">TERMS AND CONDITIONS</a></li>
</ul>
<hr />
<!-- INDEX END -->

<h1 id="NAME">NAME <a href="#TOP" class="toplink"><img alt="^" src="../../../../up.gif" /></a></h1>

<p>Kernel::System::SysConfig::Base::Framework - Base class for system configuration.</p>

<h1 id="PUBLIC_INTERFACE">PUBLIC INTERFACE <a href="#TOP" class="toplink"><img alt="^" src="../../../../up.gif" /></a></h1>

<h2 id="SettingModifiedXMLContentParsedGet">SettingModifiedXMLContentParsedGet()</h2>

<p><a href="#" onclick="toggleCode('method_SettingModifiedXMLContentParsedGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SettingModifiedXMLContentParsedGet">
                                        <pre>

sub SettingModifiedXMLContentParsedGet {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(DefaultSetting ModifiedSetting)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!"
            );
            return;
        }
    }

    my $Result = $Param{DefaultSetting}->{XMLContentParsed};

    $Result = $Self->_ModifiedValueCalculate(
        Value          => $Result->{Value},
        EffectiveValue => $Param{ModifiedSetting}->{EffectiveValue},
    );

    return $Result;
}
</pre></div>

<p>Returns perl structure for modified setting.</p>

<pre>    my $Result = $SysConfigObject-&gt;SettingModifiedXMLContentParsedGet(
        ModifiedSetting =&gt; {
            EffectiveValue =&gt; 'Scalar value updated'
        },
        DefaultSetting =&gt; {
            XMLContentParsed =&gt; {
                Value =&gt; [
                    {
                        'Item' =&gt; [
                            {
                                'Content' =&gt; &quot;Scalar value&quot;,
                            },
                        ],
                    },
                ],
            },
        },
    );
</pre><p>Returns:</p>

<pre>    $Result = [
        {
            'Item' =&gt; [
                {
                    'Content' =&gt; &quot;Scalar value updated&quot;,
                },
            ],
        },
    ];
</pre><h1 id="PRIVATE_INTERFACE">PRIVATE INTERFACE <a href="#TOP" class="toplink"><img alt="^" src="../../../../up.gif" /></a></h1>

<h2 id="ModifiedValueCalculate">_ModifiedValueCalculate()</h2>

<p><a href="#" onclick="toggleCode('method__ModifiedValueCalculate');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method__ModifiedValueCalculate">
                                        <pre>

sub _ModifiedValueCalculate {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(Value)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!"
            );
            return;
        }
    }

    my %Objects;
    if ( $Param{Objects} ) {
        %Objects = %{ $Param{Objects} };
    }

    my @SkipParameters = (
        'Hash',
        'Array',
        'Item',
        'Content',
        'Key',
    );

    my $Result;

    my $ValueType;

    # Check if additional parameters are provided.
    if ( IsHashRefWithData( $Param{Parameters} ) && $Param{Value}->[0]->{Item} ) {
        for my $Parameter ( sort keys %{ $Param{Parameters} } ) {
            $Result->[0]->{Item}->[0]->{$Parameter} = $Param{Parameters}->{$Parameter};
        }
    }

    if (
        $Param{Value}->[0]->{Item}
        && $Param{Value}->[0]->{Item}->[0]->{ValueType}
        )
    {
        $ValueType = $Param{Value}->[0]->{Item}->[0]->{ValueType};
    }
    if ( $Param{ValueType} ) {
        $ValueType = $Param{ValueType};
    }

    if ($ValueType) {

        if ( !$Objects{$ValueType} ) {

            # Make sure the ValueType backed is present and is syntactically correct.
            my $Loaded = $Kernel::OM->Get('Kernel::System::Main')->Require(
                "Kernel::System::SysConfig::ValueType::$ValueType",
            );

            return $Result if !$Loaded;

            # Create object instance.
            $Objects{$ValueType} = $Kernel::OM->Get(
                "Kernel::System::SysConfig::ValueType::$ValueType",
            );
        }

        $Result = $Objects{$ValueType}->ModifiedValueGet(%Param);

        # Get all additional parameters (defined as attributes in XML).
        if ( IsHashRefWithData( $Param{Value}->[0]->{Item}->[0] ) ) {
            PARAMETER:
            for my $Parameter ( sort keys %{ $Param{Value}->[0]->{Item}->[0] } ) {
                next PARAMETER if grep { $_ eq $Parameter } @SkipParameters;

                # Skip already defined values.
                next PARAMETER if $Result->[0]->{Item}->[0]->{$Parameter};

                $Result->[0]->{Item}->[0]->{$Parameter} =
                    $Param{Value}->[0]->{Item}->[0]->{$Parameter};
            }
        }
    }
    elsif ( ref $Param{EffectiveValue} eq 'ARRAY' ) {

        # Create basic structure.
        $Result = [
            {
                'Array' => [
                    {
                        'Item' => [],
                    },
                ],
            },
        ];

        my $DefaultItem = $Param{Value}->[0]->{Array}->[0]->{DefaultItem};

        if ( $Param{Value}->[0]->{Array}->[0]->{MinItems} ) {
            $Result->[0]->{Array}->[0]->{MinItems} = $Param{Value}->[0]->{Array}->[0]->{MinItems};
        }

        if ( $Param{Value}->[0]->{Array}->[0]->{MaxItems} ) {
            $Result->[0]->{Array}->[0]->{MaxItems} = $Param{Value}->[0]->{Array}->[0]->{MaxItems};
        }

        my %Attributes;

        if (
            $DefaultItem
            && ref $DefaultItem eq 'ARRAY'
            && scalar @{$DefaultItem}
            && ref $DefaultItem->[0] eq 'HASH'
            )
        {
            # Get additional attributes
            ATTRIBUTE:
            for my $Attribute ( sort keys %{ $DefaultItem->[0] } ) {
                next ATTRIBUTE if grep { $Attribute eq $_ } qw(Hash Array Item Content);

                $Attributes{$Attribute} = $DefaultItem->[0]->{$Attribute};
            }
        }

        for my $Index ( 0 .. scalar @{ $Param{EffectiveValue} } - 1 ) {

            if (
                $DefaultItem
                && $DefaultItem->[0]->{ValueType}
                && $Param{Value}->[0]->{Array}->[0]->{Item}
                )
            {

                # It's Item with defined ValueType.

                my $ItemData = $Kernel::OM->Get('Kernel::System::Storable')->Clone(
                    Data => $DefaultItem,
                );

                my $Value = $Self->_ModifiedValueCalculate(
                    Value => [
                        {
                            Item => $ItemData,
                        },
                    ],
                    EffectiveValue => $Param{EffectiveValue}->[$Index],
                    ValueType      => $Param{Value}->[0]->{Array}->[0]->{ValueType},
                    Objects        => \%Objects,
                );

                push @{ $Result->[0]->{Array}->[0]->{Item} }, $Value->[0];
            }
            elsif (
                $DefaultItem
                && ( $DefaultItem->[0]->{Array} || $DefaultItem->[0]->{Hash} )
                )
            {
                my $StructureType = $DefaultItem->[0]->{Array} ? 'Array' : 'Hash';

                $Param{Value}->[0]->{Array}->[0]->{Item}->[0]->{$StructureType}->[0]->{DefaultItem} =
                    $DefaultItem->[0]->{$StructureType}->[0]->{DefaultItem};

                my $Value = $Self->_ModifiedValueCalculate(
                    Value          => $Param{Value}->[0]->{Array}->[0]->{Item},
                    EffectiveValue => $Param{EffectiveValue}->[$Index],
                    Objects        => \%Objects,
                );

                push @{ $Result->[0]->{Array}->[0]->{Item} }, $Value->[0];
            }
            else {

                if ( IsArrayRefWithData( $Param{EffectiveValue}->[$Index] ) ) {
                    for my $ArrayItem ( @{ $Param{EffectiveValue}->[$Index] } ) {
                        push @{ $Result->[0]->{Array}->[0]->{Item} }, {
                            %Attributes,
                            Content => $ArrayItem,
                        };
                    }
                }
                else {

                    # This is a string value.
                    push @{ $Result->[0]->{Array}->[0]->{Item} }, {
                        %Attributes,
                        Content => $Param{EffectiveValue}->[$Index],
                    };
                }
            }
        }
    }
    elsif ( ref $Param{EffectiveValue} eq 'HASH' ) {

        # Create basic structure.
        $Result = [
            {
                'Hash' => [
                    {
                        'Item' => [],
                    },
                ],
            }
        ];

        if ( $Param{Value}->[0]->{Hash}->[0]->{MinItems} ) {
            $Result->[0]->{Hash}->[0]->{MinItems} = $Param{Value}->[0]->{Hash}->[0]->{MinItems};
        }

        if ( $Param{Value}->[0]->{Hash}->[0]->{MaxItems} ) {
            $Result->[0]->{Hash}->[0]->{MaxItems} = $Param{Value}->[0]->{Hash}->[0]->{MaxItems};
        }

        my $DefaultItem;

        my %Attributes;

        for my $Key ( sort keys %{ $Param{EffectiveValue} } ) {
            %Attributes = ();

            $DefaultItem = $Param{Value}->[0]->{Hash}->[0]->{DefaultItem};

            if ( $Param{Value}->[0]->{Hash}->[0]->{Item} ) {
                my @ItemWithSameKey = grep { $Key eq ( $Param{Value}->[0]->{Hash}->[0]->{Item}->[$_]->{Key} || '' ) }
                    0 .. scalar @{ $Param{Value}->[0]->{Hash}->[0]->{Item} } - 1;
                if ( scalar @ItemWithSameKey ) {

                    if (
                        $DefaultItem
                        && !$Param{Value}->[0]->{Hash}->[0]->{Item}->[ $ItemWithSameKey[0] ]->{ValueType}
                        && $DefaultItem->[0]->{ValueType}
                        )
                    {
                        # update hash
                        for my $DefaultKey (
                            sort keys %{ $Param{Value}->[0]->{Hash}->[0]->{Item}->[ $ItemWithSameKey[0] ] }
                            )
                        {
                            $DefaultItem->[0]->{$DefaultKey}
                                = $Param{Value}->[0]->{Hash}->[0]->{Item}->[ $ItemWithSameKey[0] ]->{$DefaultKey};
                        }
                    }
                    else {
                        $DefaultItem = [
                            $Param{Value}->[0]->{Hash}->[0]->{Item}->[ $ItemWithSameKey[0] ],
                        ];
                    }
                }
            }

            if (
                $DefaultItem
                && ref $DefaultItem eq 'ARRAY'
                && scalar @{$DefaultItem}
                && ref $DefaultItem->[0] eq 'HASH'
                )
            {
                # Get additional attributes
                ATTRIBUTE:
                for my $Attribute ( sort keys %{ $DefaultItem->[0] } ) {
                    next ATTRIBUTE if grep { $Attribute eq $_ } qw(Hash Array Content Key);

                    if ( $Attribute eq 'Item' ) {
                        if (
                            !$DefaultItem->[0]->{Item}->[0]->{ValueType}
                            || $DefaultItem->[0]->{Item}->[0]->{ValueType} ne 'Option'
                            )
                        {
                            next ATTRIBUTE;
                        }
                    }
                    $Attributes{$Attribute} = $DefaultItem->[0]->{$Attribute};
                }
            }

            if (
                $DefaultItem
                && !$DefaultItem->[0]->{Content}
                && $Param{Value}->[0]->{Hash}->[0]->{Item}
                && scalar @{ $Param{Value}->[0]->{Hash}->[0]->{Item} }
                && $Param{Value}->[0]->{Hash}->[0]->{Item}->[0]->{Item}
                )
            {
                # It's Item with defined ValueType.
                my $ItemData = $Kernel::OM->Get('Kernel::System::Storable')->Clone(
                    Data => $DefaultItem,
                );

                ATTRIBUTE:
                for my $Attribute ( sort keys %Attributes ) {
                    next ATTRIBUTE if defined $ItemData->[0]->{$Attribute};

                    $ItemData->[0]->{$Attribute} = $Attributes{$Attribute};
                }

                if (
                    !$ItemData->[0]->{Item}
                    || ( $ItemData->[0]->{Item} && !$ItemData->[0]->{Item}->[0]->{ValueType} )
                    )
                {
                    $ItemData->[0]->{ValueType} //= 'String';
                }

                my $Value = $Self->_ModifiedValueCalculate(
                    Value          => $ItemData,
                    EffectiveValue => $Param{EffectiveValue}->{$Key},
                    ValueType      => $DefaultItem->[0]->{ValueType},
                    Objects        => \%Objects,
                );

                $Value->[0]->{Key} = $Key;

                push @{ $Result->[0]->{Hash}->[0]->{Item} }, $Value->[0];
            }
            elsif (
                $DefaultItem
                && ( $DefaultItem->[0]->{Array} || $DefaultItem->[0]->{Hash} )
                )
            {
                my $StructureType = $DefaultItem->[0]->{Array} ? 'Array' : 'Hash';

                my ($SubValue)
                    = grep { defined $_->{Key} && $_->{Key} eq $Key } @{ $Param{Value}->[0]->{Hash}->[0]->{Item} };

                if (
                    $Param{Value}->[0]->{Hash}->[0]->{DefaultItem}
                    && $Param{Value}->[0]->{Hash}->[0]->{DefaultItem}->[0]->{$StructureType}
                    )
                {
                    $SubValue->{$StructureType}->[0]->{DefaultItem} =
                        $Param{Value}->[0]->{Hash}->[0]->{DefaultItem}->[0]->{$StructureType}->[0]->{DefaultItem};
                }

                my $Value = $Self->_ModifiedValueCalculate(
                    Value          => [$SubValue],
                    EffectiveValue => $Param{EffectiveValue}->{$Key},
                    Objects        => \%Objects,
                );
                $Value->[0]->{Key} = $Key;
                push @{ $Result->[0]->{Hash}->[0]->{Item} }, $Value->[0];
            }
            else {
                # This is a scaler value.

                my $ValueAttribute = "Content";    # by default

                my $ValueType = $Attributes{ValueType};

                if ($ValueType) {
                    if ( !$Objects{$ValueType} ) {

                        # Make sure the ValueType backed is present and is syntactically correct.
                        my $Loaded = $Kernel::OM->Get('Kernel::System::Main')->Require(
                            "Kernel::System::SysConfig::ValueType::$ValueType",
                        );

                        if ($Loaded) {

                            # Create object instance.
                            $Objects{$ValueType} = $Kernel::OM->Get(
                                "Kernel::System::SysConfig::ValueType::$ValueType",
                            );
                        }
                    }

                    $ValueAttribute = $Objects{$ValueType}->ValueAttributeGet();
                }

                push @{ $Result->[0]->{Hash}->[0]->{Item} }, {
                    %Attributes,
                    Key             => $Key,
                    $ValueAttribute => $Param{EffectiveValue}->{$Key},
                };
            }
        }
    }
    else {

        # This is a scaler value.
        $Result = [
            {
                Item => [
                    {
                        Content => $Param{EffectiveValue},
                    },
                ],
            },
        ];

        # Get all additional parameters (defined as attributes in XML).
        if ( IsHashRefWithData( $Param{Value}->[0]->{Item}->[0] ) ) {
            PARAMETER:
            for my $Parameter ( sort keys %{ $Param{Value}->[0]->{Item}->[0] } ) {
                next PARAMETER if grep { $_ eq $Parameter } @SkipParameters;

                $Result->[0]->{Item}->[0]->{$Parameter} =
                    $Param{Value}->[0]->{Item}->[0]->{$Parameter};
            }
        }
    }

    return $Result;
}
</pre></div>

<p>Recursive helper for SettingModifiedXMLContentParsedGet().</p>

<pre>    my $Result = $SysConfigObject-&gt;_ModifiedValueCalculate(
        'EffectiveValue' =&gt; 'Scalar value updated',         # (optional) new effective value
        'Value' =&gt; [                                        # (required) the XMLContentParsed value from Defaults
            {
                'Item' =&gt; [
                    {
                        'Content' =&gt; 'Scalar value',
                    },
                ],
            },
        ],
    );
</pre><p>Returns:</p>

<pre>    $Result =  [
        {
            'Item' =&gt; [
                {
                    'Content' =&gt; 'Scalar value updated'
                },
            ],
        },
    ];
</pre><h1 id="TERMS_AND_CONDITIONS">TERMS AND CONDITIONS <a href="#TOP" class="toplink"><img alt="^" src="../../../../up.gif" /></a></h1>

<p>This software is part of the OTRS project (<a href="http://otrs.org/">http://otrs.org/</a>).</p>

<p>This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see <a href="http://www.gnu.org/licenses/agpl.txt">http://www.gnu.org/licenses/agpl.txt</a>.</p>


</div><div class="footer">generated by <a href="http://search.cpan.org/perldoc?Pod%3A%3AProjectDocs">Pod::ProjectDocs</a></div></body>
</html>
