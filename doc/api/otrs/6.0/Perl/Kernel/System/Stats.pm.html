<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<!-- otrs.github.io -->
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../../../../../../documentation.css">
<script src="https://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../../../../../documentation.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script>
$(document).ready(function() {

    // Hint languages to prevent false matches (php for example).
    hljs.configure({
        languages: ['perl', 'javascript', 'xml', 'html', 'css', 'json', 'yaml']
    });

    // programlistings in manuals
    $('pre.programlisting').each(function(i, block) {
        hljs.highlightBlock(block);
    });
    // code snippets in Perl API docs
    $('.pod pre').addClass('perl').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});</script>
<!-- otrs.github.io -->

	<title>Kernel::System::Stats</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <script type="text/javascript">

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  </script></head>
<body>
<div class="box">
  <h1 class="t1">OTRS 6.0 API Reference Perl</h1>
  <table>
    <tr>
      <td class="label">Description</td>
      <td class="cell">manuals and libraries</td>
    </tr>
  </table>
</div>
<div class="path">
  <a href="../../index.html">OTRS 6.0 API Reference Perl</a> &gt; Perl Modules &gt;
  Kernel::System::Stats
</div>
<div>
<a href="../../src/Kernel/System/Stats.pm">Source</a>
</div>
<div class="pod">
<!-- INDEX START -->
<h3 id="TOP">Index</h3>
<ul>
	<li><a href="#NAME">NAME</a></li>
	<li><a href="#DESCRIPTION">DESCRIPTION</a><br />
<ul>
	<li><a href="#Explanation_for_the_time_zone_parame">Explanation for the time zone parameter</a></li>
</ul>
</li>
	<li><a href="#PUBLIC_INTERFACE">PUBLIC INTERFACE</a><br />
<ul>
	<li><a href="#new">new()</a></li>
	<li><a href="#StatsAdd">StatsAdd()</a></li>
	<li><a href="#StatsGet">StatsGet()</a></li>
	<li><a href="#StatsUpdate">StatsUpdate()</a></li>
	<li><a href="#StatsDelete">StatsDelete()</a></li>
	<li><a href="#StatsListGet">StatsListGet()</a></li>
	<li><a href="#GetStatsList">GetStatsList()</a></li>
	<li><a href="#SumBuild">SumBuild()</a></li>
	<li><a href="#GetStatsObjectAttributes">GetStatsObjectAttributes()</a></li>
	<li><a href="#GetStaticFiles">GetStaticFiles()</a></li>
	<li><a href="#GetDynamicFiles">GetDynamicFiles()</a></li>
	<li><a href="#GetObjectName">GetObjectName()</a></li>
	<li><a href="#GetObjectBehaviours">GetObjectBehaviours()</a></li>
	<li><a href="#ObjectFileCheck">ObjectFileCheck()</a></li>
	<li><a href="#Export">Export()</a></li>
	<li><a href="#Import">Import()</a></li>
	<li><a href="#GetParams">GetParams()</a></li>
	<li><a href="#StatsRun">StatsRun()</a></li>
	<li><a href="#StatsResultCacheCompute">StatsResultCacheCompute()</a></li>
	<li><a href="#StatsResultCacheGet">StatsResultCacheGet()</a></li>
	<li><a href="#StringAndTimestamp2Filename">StringAndTimestamp2Filename()</a></li>
	<li><a href="#StatNumber2StatID">StatNumber2StatID()</a></li>
	<li><a href="#StatsInstall">StatsInstall()</a></li>
	<li><a href="#StatsUninstall">StatsUninstall()</a></li>
	<li><a href="#StatsCleanUp">StatsCleanUp()</a></li>
</ul>
</li>
	<li><a href="#TERMS_AND_CONDITIONS">TERMS AND CONDITIONS</a></li>
</ul>
<hr />
<!-- INDEX END -->

<h1 id="NAME">NAME <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<p>Kernel::System::Stats - stats lib</p>

<h1 id="DESCRIPTION">DESCRIPTION <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<p>All stats functions.</p>

<h2 id="Explanation_for_the_time_zone_parame">Explanation for the time zone parameter</h2>

<p>The time zone parameter is available, if the statistic is a dynamic statistic. The selected periods in the frontend are time zone neutral and for the
search parameters, the selection will be converted to the OTRS time zone, because the times
are stored within this time zone in the database.</p>

<p>This means e.g. if an absolute period of time from 2015-08-01 00:00:00 to 2015-09-10 23:59:59 and a time zone with an offset of +6 hours has been selected,
the period will be converted from the +6 time zone to the OTRS time zone for the search parameter,
so that the right time will be used for searching the database. Given that the OTRS time zone is set to UTC, this
would result in a period of 2015-07-31 18:00:00 to 2015-09-10 17:59:59 UTC.</p>

<p>For a relative time period, e. g. the last 10 full days, and a time zone with an offset of +10 hours, a DateTime object with the +10 time zone will be created
for the current time. For the period end date, this date will be taken and extended to the end of the day. Then, 10 full days will be subtracted from this.
This is the start of the period, which will be extended to 00:00:00. Start and end date will be converted to the time zone of OTRS to search the database.</p>

<p>Example for relative time period 'last 10 full days' with selected time zone offset +10 hours, current date/time within this time zone 2015-09-10 16:00:00, OTRS time zone is UTC:
End date: 2015-09-10 16:00:00 -&gt; extended to 2015-09-10 23:59:59 -&gt; 2015-09-10 13:59:59 OTRS time zone (UTC)
Start date: 2015-09-10 16:00:00 - 10 days -&gt; 2015-08-31 16:00:00 -&gt; extended to 00:00:00: 2015-09-01 00:00:00 -&gt; 2015-08-31 14:00:00 OTRS time zone (UTC)</p>

<h1 id="PUBLIC_INTERFACE">PUBLIC INTERFACE <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<h2 id="new">new()</h2>

<p><a href="#" onclick="toggleCode('method_new');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_new">
                                        <pre>

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # temporary directory
    $Self->{StatsTempDir} = $Kernel::OM->Get('Kernel::Config')->Get('Home') . '/var/stats/';

    return $Self;
}
</pre></div>

<p>Don't use the constructor directly, use the ObjectManager instead:</p>

<pre>    my $StatsObject = $Kernel::OM-&gt;Get('Kernel::System::Stats');
</pre><h2 id="StatsAdd">StatsAdd()</h2>

<p><a href="#" onclick="toggleCode('method_StatsAdd');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_StatsAdd">
                                        <pre>

sub StatsAdd {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => "error",
                Message  => "Need $Needed.",
            );
            return;
        }
    }

    # get needed objects
    my $XMLObject  = $Kernel::OM->Get('Kernel::System::XML');
    my $TimeObject = $Kernel::OM->Get('Kernel::System::Time');

    # get new StatID
    my $StatID = 1;
    my @Keys   = $XMLObject->XMLHashSearch(
        Type => 'Stats',
    );
    if (@Keys) {
        my @SortKeys = sort { $a <=> $b } @Keys;
        $StatID = $SortKeys[-1] + 1;
    }

    # requesting current time stamp
    my $TimeStamp = $TimeObject->SystemTime2TimeStamp(
        SystemTime => $TimeObject->SystemTime(),
    );

    # meta tags
    my $StatNumber = $StatID + $Kernel::OM->Get('Kernel::Config')->Get('Stats::StatsStartNumber');

    my %MetaData = (
        Created => [
            { Content => $TimeStamp },
        ],
        CreatedBy => [
            { Content => $Param{UserID} },
        ],
        Changed => [
            { Content => $TimeStamp },
        ],
        ChangedBy => [
            { Content => $Param{UserID} },
        ],
        Valid => [
            { Content => 1 },
        ],
        StatNumber => [
            { Content => $StatNumber },
        ],
    );

    # start new stats record
    my @XMLHash = (
        { otrs_stats => [ \%MetaData ] },
    );
    my $Success = $XMLObject->XMLHashAdd(
        Type    => 'Stats',
        Key     => $StatID,
        XMLHash => \@XMLHash,
    );
    if ( !$Success ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Can not add a new Stat!',
        );
        return;
    }

    $Kernel::OM->Get('Kernel::System::Cache')->CleanUp(
        Type => 'Stats',
    );

    return $StatID;
}
</pre></div>

<p>add new empty stats</p>

<pre>    my $StatID = $StatsObject-&gt;StatsAdd(
        UserID =&gt; $UserID,
    );
</pre><h2 id="StatsGet">StatsGet()</h2>

<p><a href="#" onclick="toggleCode('method_StatsGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_StatsGet">
                                        <pre>

sub StatsGet {
    my ( $Self, %Param ) = @_;

    # check necessary data
    if ( !$Param{StatID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need StatID!'
        );
    }

    $Param{NoObjectAttributes} = $Param{NoObjectAttributes} ? 1 : 0;

    # get cache object
    my $CacheObject = $Kernel::OM->Get('Kernel::System::Cache');

    my $CacheKey = "StatsGet::StatID::$Param{StatID}::NoObjectAttributes::$Param{NoObjectAttributes}";

    my $Cache = $CacheObject->Get(
        Type => 'Stats',
        Key  => $CacheKey,

        # Don't store complex structure in memory as it will be modified later.
        CacheInMemory => 0,
    );
    return $Cache if ref $Cache eq 'HASH';

    # get hash from storage
    my @XMLHash = $Kernel::OM->Get('Kernel::System::XML')->XMLHashGet(
        Type => 'Stats',
        Key  => $Param{StatID},
    );

    if ( !$XMLHash[0] ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Can't get StatsID $Param{StatID}!",
        );
        return;
    }

    my %Stat;
    my $StatsXML = $XMLHash[0]->{otrs_stats}->[1];

    # process all strings
    $Stat{StatID} = $Param{StatID};
    for my $Key (
        qw(Title Object File Description SumRow SumCol StatNumber
        Cache StatType Valid ObjectModule CreatedBy ChangedBy Created Changed
        ShowAsDashboardWidget
        )
        )
    {
        if ( defined $StatsXML->{$Key}->[1]->{Content} ) {
            $Stat{$Key} = $StatsXML->{$Key}->[1]->{Content};
        }
    }

    # time zone
    if ( defined $StatsXML->{TimeZone}->[1]->{Content} ) {
        $Stat{TimeZone} = $StatsXML->{TimeZone}->[1]->{Content};
    }

    # process all arrays
    KEY:
    for my $Key (qw(Permission Format GraphSize)) {
        next KEY if !$StatsXML->{$Key}->[1]->{Content};

        $Stat{$Key} = ();
        for my $Index ( 1 .. $#{ $StatsXML->{$Key} } ) {
            push @{ $Stat{$Key} }, $StatsXML->{$Key}->[$Index]->{Content};
        }
    }

    if ( $Stat{ObjectModule} ) {
        $Stat{ObjectBehaviours} = $Self->GetObjectBehaviours(
            ObjectModule => $Stat{ObjectModule},
        );
    }

    # get the configuration elements of the dynamic stats
    # %Allowed is used to avoid double selection in different forms
    my %Allowed;
    my %TimeAllowed;
    my $TimeElement = $Kernel::OM->Get('Kernel::Config')->Get('Stats::TimeElement') || 'Time';

    return \%Stat if !$Stat{Object};

    $Stat{ObjectName} = $Self->GetObjectName(
        ObjectModule => $Stat{ObjectModule},
    );

    if ( $Param{NoObjectAttributes} ) {

        $CacheObject->Set(
            Type  => 'Stats',
            Key   => $CacheKey,
            Value => \%Stat,
            TTL   => 24 * 60 * 60,

            # Don't store complex structure in memory as it will be modified later.
            CacheInMemory => 0,
        );

        return \%Stat;
    }

    KEY:
    for my $Key (qw(UseAsXvalue UseAsValueSeries UseAsRestriction)) {

        # @StatAttributesSimplified give you arrays without undef array elements
        my @StatAttributesSimplified;

        # get the attributes of the object
        my @ObjectAttributes = $Self->GetStatsObjectAttributes(
            ObjectModule => $Stat{ObjectModule},
            Use          => $Key,
        );

        next KEY if !@ObjectAttributes;

        ATTRIBUTE:
        for my $Attribute (@ObjectAttributes) {
            my $Element = $Attribute->{Element};
            if ( $Attribute->{Block} eq 'Time' ) {
                if ( $Key eq 'UseAsValueSeries' ) {
                    if ( $Allowed{$Element} && $Allowed{$Element} == 1 ) {
                        $Allowed{$Element}     = 0;
                        $TimeAllowed{$Element} = 1;
                    }
                    else {
                        $Allowed{$Element} = 1;
                    }
                }
                elsif ( $Key eq 'UseAsRestriction' ) {
                    if ( $TimeAllowed{$Element} && $TimeAllowed{$Element} == 1 ) {
                        $Allowed{$Element} = 1;
                    }
                    else {
                        $Allowed{$Element} = 0;
                    }
                }
            }
            next ATTRIBUTE if $Allowed{$Element};

            if ( $StatsXML->{$Key} ) {
                my @StatAttributes = @{ $StatsXML->{$Key} };
                if ( !$StatAttributes[0] ) {
                    shift @StatAttributes;
                }

                REF:
                for my $Ref (@StatAttributes) {
                    if ( !defined $Attribute->{Translation} ) {
                        $Attribute->{Translation} = 1;
                    }

                    next REF
                        if !(
                        $Element
                        && $Ref->{Element}
                        && $Element eq $Ref->{Element}
                        );

                    # if selected elements exit, add the information to the StatAttributes
                    $Attribute->{Selected} = 1;
                    if ( $Ref->{Fixed} ) {
                        $Attribute->{Fixed} = 1;
                    }

                    for my $Index ( 1 .. $#{ $Ref->{SelectedValues} } ) {
                        push @{ $Attribute->{SelectedValues} }, $Ref->{SelectedValues}->[$Index]->{Content};
                    }

                    if ( $Attribute->{Block} eq 'Time' ) {

                        # settings for working with time elements
                        for (
                            qw(TimeStop TimeStart TimeRelativeUnit
                            TimeRelativeCount TimeRelativeUpcomingCount TimeScaleCount
                            )
                            )
                        {
                            if ( defined $Ref->{$_} && ( !$Attribute->{$_} || $Ref->{Fixed} ) ) {
                                $Attribute->{$_} = $Ref->{$_};
                            }
                        }

                        # set a default value for the time relative upcoming count field
                        $Attribute->{TimeRelativeUpcomingCount} //= 0;
                    }

                    $Allowed{$Element} = 1;
                }
            }

            push @StatAttributesSimplified, $Attribute;

        }

        $Stat{$Key} = \@StatAttributesSimplified;
    }

    $CacheObject->Set(
        Type  => 'Stats',
        Key   => $CacheKey,
        Value => \%Stat,
        TTL   => 24 * 60 * 60,

        # Don't store complex structure in memory as it will be modified later.
        CacheInMemory => 0,
    );

    return \%Stat;
}
</pre></div>

<p>get a hash ref of the stats you need</p>

<pre>    my $HashRef = $StatsObject-&gt;StatsGet(
        StatID             =&gt; '123',
        NoObjectAttributes =&gt; 1,       # optional
    );
</pre><h2 id="StatsUpdate">StatsUpdate()</h2>

<p><a href="#" onclick="toggleCode('method_StatsUpdate');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_StatsUpdate">
                                        <pre>

sub StatsUpdate {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => "error",
                Message  => "Need $Needed.",
            );
            return;
        }
    }

    # declaration of the hash
    my %StatXML;

    # check necessary data
    if ( !$Param{StatID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need StatID!'
        );
    }

    # requesting stats reference
    my $StatOld = $Self->StatsGet( StatID => $Param{StatID} );
    if ( !$StatOld ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message =>
                "Can't get stats, perhaps you have an invalid stats id! (StatsID => $Param{StatID})"
        );
        return;
    }

    # declare variable
    my $StatNew = $Param{Hash};

    # a delete function can be the better solution
    for my $Key (qw(UseAsXvalue UseAsValueSeries UseAsRestriction)) {
        for ( @{ $StatOld->{$Key} } ) {
            if ( !$_->{Selected} ) {
                $_ = undef;
            }
        }
    }

    # adopt changes
    for my $Key ( sort keys %{$StatNew} ) {
        $StatOld->{$Key} = $StatNew->{$Key};
    }

    KEY:
    for my $Key ( sort keys %{$StatOld} ) {

        # Don't store the behaviour data
        next KEY if $Key eq 'ObjectBehaviours';

        if ( $Key eq 'UseAsXvalue' || $Key eq 'UseAsValueSeries' || $Key eq 'UseAsRestriction' ) {
            my $Index = 0;
            REF:
            for my $Ref ( @{ $StatOld->{$Key} } ) {
                next REF if !$Ref;

                $Index++;
                $StatXML{$Key}->[$Index]->{Element} = $Ref->{Element};
                $StatXML{$Key}->[$Index]->{Fixed}   = $Ref->{Fixed};
                my $SubIndex = 0;
                for my $Value ( @{ $Ref->{SelectedValues} } ) {
                    $SubIndex++;
                    $StatXML{$Key}->[$Index]->{SelectedValues}->[$SubIndex]->{Content} = $Value;
                }

                # stetting for working with time elements
                for (qw(TimeStop TimeStart TimeRelativeUnit TimeRelativeCount TimeRelativeUpcomingCount TimeScaleCount))
                {
                    if ( defined $Ref->{$_} ) {
                        $StatXML{$Key}->[$Index]->{$_} = $Ref->{$_};
                    }
                }
            }
        }
        elsif ( ref $StatOld->{$Key} eq 'ARRAY' ) {
            for my $Index ( 0 .. $#{ $StatOld->{$Key} } ) {
                $StatXML{$Key}->[$Index]->{Content} = $StatOld->{$Key}->[$Index];
            }
        }
        else {
            if ( defined $StatOld->{$Key} ) {
                $StatXML{$Key}->[1]->{Content} = $StatOld->{$Key};
            }
        }
    }

    # get time object
    my $TimeObject = $Kernel::OM->Get('Kernel::System::Time');

    # meta tags
    my $TimeStamp = $TimeObject->SystemTime2TimeStamp(
        SystemTime => $TimeObject->SystemTime(),
    );
    $StatXML{Changed}->[1]->{Content}   = $TimeStamp;
    $StatXML{ChangedBy}->[1]->{Content} = $Param{UserID};

    # get xml object
    my $XMLObject = $Kernel::OM->Get('Kernel::System::XML');

    # please don't change the functionality of XMLHashDelete and XMLHashAdd
    # into the new function XMLHashUpdate, there is an incompatibility.
    # Perhaps there are intricacies because of the 'Array[0] = undef' definition

    # delete the old record
    my $Success = $XMLObject->XMLHashDelete(
        Type => 'Stats',
        Key  => $Param{StatID},
    );
    if ( !$Success ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Can't delete XMLHash!"
        );
        return;
    }

    # delete cache
    $Self->_DeleteCache( StatID => $Param{StatID} );

    my @Array = (
        {
            otrs_stats => [ \%StatXML ],
        },
    );

    # add the revised record
    $Success = $XMLObject->XMLHashAdd(
        Type    => 'Stats',
        Key     => $Param{StatID},
        XMLHash => \@Array
    );
    if ( !$Success ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Can't add XMLHash!"
        );
        return;
    }

    $Kernel::OM->Get('Kernel::System::Cache')->CleanUp(
        Type => 'Stats',
    );

    return 1;
}
</pre></div>

<p>update a stat</p>

<pre>    $StatsObject-&gt;StatsUpdate(
        StatID =&gt; '123',
        Hash   =&gt; \%Hash,
        UserID =&gt; $UserID,
    );
</pre><h2 id="StatsDelete">StatsDelete()</h2>

<p><a href="#" onclick="toggleCode('method_StatsDelete');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_StatsDelete">
                                        <pre>

sub StatsDelete {
    my ( $Self, %Param ) = @_;

    # check necessary data
    if ( !$Param{StatID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need StatID!'
        );
    }

    # delete the record
    my $Success = $Kernel::OM->Get('Kernel::System::XML')->XMLHashDelete(
        Type => 'Stats',
        Key  => $Param{StatID},
    );

    # error handling
    if ( !$Success ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Can't delete XMLHash!",
        );
        return;
    }

    # delete cache
    $Self->_DeleteCache( StatID => $Param{StatID} );

    # get main object
    my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

    # get list of installed stats files
    my @StatsFileList = $MainObject->DirectoryRead(
        Directory => $Self->{StatsTempDir},
        Filter    => '*.xml.installed',
    );

    # delete the .installed file in temp dir
    FILE:
    for my $File ( sort @StatsFileList ) {

        # read file content
        my $StatsIDRef = $MainObject->FileRead(
            Location => $File,
        );

        next FILE if !$StatsIDRef;
        next FILE if ref $StatsIDRef ne 'SCALAR';
        next FILE if !${$StatsIDRef};

        next FILE if ${$StatsIDRef} ne $Param{StatID};

        # delete .installed file
        $MainObject->FileDelete(
            Location => $File,
        );
    }

    # add log message
    $Kernel::OM->Get('Kernel::System::Log')->Log(
        Priority => 'notice',
        Message  => "Delete stats (StatsID = $Param{StatID})",
    );

    $Kernel::OM->Get('Kernel::System::Cache')->CleanUp(
        Type => 'Stats',
    );

    return 1;
}
</pre></div>

<p>delete a stats</p>

<pre>    $StatsObject-&gt;StatsDelete( StatID =&gt; '123' );
</pre><h2 id="StatsListGet">StatsListGet()</h2>

<p><a href="#" onclick="toggleCode('method_StatsListGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_StatsListGet">
                                        <pre>

sub StatsListGet {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => "error",
                Message  => "Need $Needed.",
            );
            return;
        }
    }

    my @SearchResult;

    # get cache object
    my $CacheObject = $Kernel::OM->Get('Kernel::System::Cache');

    # Only cache the XML search as we need to filter based on user permissions later
    my $CacheKey = 'StatsListGet::XMLSearch';
    my $Cache    = $CacheObject->Get(
        Type => 'Stats',
        Key  => $CacheKey,

        # Don't store complex structure in memory as it will be modified later.
        CacheInMemory => 0,
    );

    # Do we have a cache available?
    if ( ref $Cache eq 'ARRAY' ) {
        @SearchResult = @{$Cache};
    }
    else {

        # get xml object
        my $XMLObject = $Kernel::OM->Get('Kernel::System::XML');

        # No cache. Is there stats data yet?
        if ( !( @SearchResult = $XMLObject->XMLHashSearch( Type => 'Stats' ) ) ) {

            # Import sample stats
            $Self->_AutomaticSampleImport(
                UserID => $Param{UserID},
            );

            # Load stats again
            return if !( @SearchResult = $XMLObject->XMLHashSearch( Type => 'Stats' ) );
        }
        $CacheObject->Set(
            Type  => 'Stats',
            Key   => $CacheKey,
            Value => \@SearchResult,
            TTL   => 24 * 60 * 60,

            # Don't store complex structure in memory as it will be modified later.
            CacheInMemory => 0,
        );

    }

    # get user groups
    my %GroupList = $Kernel::OM->Get('Kernel::System::Group')->PermissionUserGet(
        UserID => $Param{UserID},
        Type   => 'ro',
    );

    my %Result;

    for my $StatID (@SearchResult) {

        my $Stat = $Self->StatsGet(
            StatID             => $StatID,
            NoObjectAttributes => 1,
        );

        my $UserPermission = 0;
        if ( $Param{AccessRw} || $Param{UserID} == 1 ) {

            $UserPermission = 1;
        }
        elsif ( $Stat->{Valid} ) {

            GROUPID:
            for my $GroupID ( @{ $Stat->{Permission} } ) {

                next GROUPID if !$GroupID;
                next GROUPID if !$GroupList{$GroupID};

                $UserPermission = 1;

                last GROUPID;
            }
        }

        if ( $UserPermission == 1 ) {
            $Result{$StatID} = $Stat;
        }
    }

    return \%Result;
}
</pre></div>

<p>fetches all statistics that the current user may see</p>

<pre>    my $StatsRef = $StatsObject-&gt;StatsListGet(
        AccessRw =&gt; 1, # Optional, indicates that user may see all statistics
        UserID   =&gt; $UserID,
    );

    Returns

    {
        6 =&gt; {
            Title =&gt; &quot;Title of stat&quot;,
            ...
        }
    }
</pre><h2 id="GetStatsList">GetStatsList()</h2>

<p><a href="#" onclick="toggleCode('method_GetStatsList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_GetStatsList">
                                        <pre>

sub GetStatsList {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => "error",
                Message  => "Need $Needed.",
            );
            return;
        }
    }

    $Param{OrderBy}   ||= 'ID';
    $Param{Direction} ||= 'ASC';

    my %ResultHash = %{ $Self->StatsListGet(%Param) || {} };

    my @SortArray;

    if ( $Param{OrderBy} eq 'ID' ) {
        @SortArray = sort { $a <=> $b } keys %ResultHash;
    }
    else {
        @SortArray = sort { $ResultHash{$a}->{ $Param{OrderBy} } cmp $ResultHash{$b}->{ $Param{OrderBy} } }
            keys %ResultHash;
    }
    if ( $Param{Direction} eq 'DESC' ) {
        @SortArray = reverse @SortArray;
    }

    return \@SortArray;
}
</pre></div>

<p>lists all stats id's</p>

<pre>    my $ArrayRef = $StatsObject-&gt;GetStatsList(
        AccessRw  =&gt; 1, # Optional, indicates that user may see all statistics
        OrderBy   =&gt; 'ID' || 'Title' || 'Object', # optional
        Direction =&gt; 'ASC' || 'DESC',             # optional
        UserID    =&gt; $UserID,
    );
</pre><h2 id="SumBuild">SumBuild()</h2>

<p><a href="#" onclick="toggleCode('method_SumBuild');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_SumBuild">
                                        <pre>

sub SumBuild {
    my ( $Self, %Param ) = @_;

    my @Data = @{ $Param{Array} };

    # add sum y
    if ( $Param{SumCol} ) {

        push @{ $Data[1] }, 'Sum';

        for my $Index1 ( 2 .. $#Data ) {

            my $Sum = 0;
            INDEX2:
            for my $Index2 ( 1 .. $#{ $Data[$Index1] } ) {

                next INDEX2 if !$Data[$Index1][$Index2];

                # extract the value
                my $Value = $Data[$Index1][$Index2];

                # clean the string
                $Value =~ s{ \A \s+ }{}xms;
                $Value =~ s{ \s+ \z }{}xms;
                $Value =~ s{ , }{.}xms;

                # add value to summary
                if ( $Value =~ m{^-?\d+(\.\d+)?$} ) {
                    $Sum += $Value;
                }
            }

            push @{ $Data[$Index1] }, $Sum;
        }
    }

    # add sum x
    if ( $Param{SumRow} ) {

        my @SumRow = ();
        $SumRow[0] = 'Sum';

        for my $Index1 ( 2 .. $#Data ) {

            INDEX2:
            for my $Index2 ( 1 .. $#{ $Data[$Index1] } ) {

                # make sure we have a value to add
                if ( !defined $Data[$Index1][$Index2] ) {
                    $Data[$Index1][$Index2] = 0;
                }

                # extract the value
                my $Value = $Data[$Index1][$Index2];

                # clean the string
                $Value =~ s{ \A \s+ }{}xms;
                $Value =~ s{ \s+ \z }{}xms;
                $Value =~ s{ , }{.}xms;

                # add value to summary
                if ( $Value =~ m{^-?\d+(\.\d+)?$} ) {
                    $SumRow[$Index2] += $Value;
                }
            }
        }

        push @Data, \@SumRow;
    }
    return \@Data;
}
</pre></div>

<p>build sum in x or/and y axis</p>

<pre>    $StatArray = $StatsObject-&gt;SumBuild(
        Array  =&gt; \@Result,
        SumRow =&gt; 1,
        SumCol =&gt; 0,
    );
</pre><h2 id="GetStatsObjectAttributes">GetStatsObjectAttributes()</h2>

<p><a href="#" onclick="toggleCode('method_GetStatsObjectAttributes');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_GetStatsObjectAttributes">
                                        <pre>

sub GetStatsObjectAttributes {
    my ( $Self, %Param ) = @_;

    # check needed params
    for (qw(ObjectModule Use)) {
        if ( !$Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    # load module
    my $ObjectModule = $Param{ObjectModule};
    return if !$Kernel::OM->Get('Kernel::System::Main')->Require($ObjectModule);
    my $StatObject = $ObjectModule->new( %{$Self} );
    return if !$StatObject;

    # load attributes
    my @ObjectAttributesRaw = $StatObject->GetObjectAttributes();

    # build the objectattribute array
    my @ObjectAttributes;
    for my $HashRef (@ObjectAttributesRaw) {
        if ( $HashRef->{ $Param{Use} } ) {
            delete $HashRef->{UseAsXvalue};
            delete $HashRef->{UseAsValueSeries};
            delete $HashRef->{UseAsRestriction};

            push @ObjectAttributes, $HashRef;
        }
    }

    return @ObjectAttributes;
}
</pre></div>

<p>Get all attributes from the object in dependence of the use</p>

<pre>    my %ObjectAttributes = $StatsObject-&gt;GetStatsObjectAttributes(
        ObjectModule =&gt; 'Ticket',
        Use          =&gt; 'UseAsXvalue' || 'UseAsValueSeries' || 'UseAsRestriction',
    );
</pre><h2 id="GetStaticFiles">GetStaticFiles()</h2>

<p><a href="#" onclick="toggleCode('method_GetStaticFiles');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_GetStaticFiles">
                                        <pre>

sub GetStaticFiles {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => "error",
                Message  => "Need $Needed.",
            );
            return;
        }
    }

    my $Directory = $Kernel::OM->Get('Kernel::Config')->Get('Home');
    if ( $Directory !~ m{^.*\/$}x ) {
        $Directory .= '/';
    }
    $Directory .= 'Kernel/System/Stats/Static/';

    if ( !opendir( DIR, $Directory ) ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Can not open Directory: $Directory",
        );
        return ();
    }

    my %StaticFiles;
    if ( $Param{OnlyUnusedFiles} ) {

        # get all Stats from the db
        my $Result = $Self->GetStatsList(
            UserID => $Param{UserID},
        );

        if ( defined $Result ) {
            for my $StatID ( @{$Result} ) {
                my $Data = $Self->StatsGet(
                    StatID             => $StatID,
                    UserID             => $Param{UserID},
                    NoObjectAttributes => 1,
                );

                # check witch one are static statistics
                if ( $Data->{File} && $Data->{StatType} eq 'static' ) {
                    $StaticFiles{ $Data->{File} } = 1;
                }
            }
        }
    }

    # read files
    my %Filelist;

    DIRECTORY:
    while ( defined( my $Filename = readdir DIR ) ) {
        next DIRECTORY if $Filename eq '.';
        next DIRECTORY if $Filename eq '..';
        if ( $Filename =~ m{^(.*)\.pm$}x ) {
            if ( !defined $StaticFiles{$1} ) {
                $Filelist{$1} = $1;
            }
        }
    }
    closedir(DIR);

    return \%Filelist;
}
</pre></div>

<p>Get all static files</p>

<pre>    my $FileHash = $StatsObject-&gt;GetStaticFiles(
        OnlyUnusedFiles =&gt; 1 | 0, # optional default 0
        UserID =&gt; $UserID,
    );
</pre><h2 id="GetDynamicFiles">GetDynamicFiles()</h2>

<p><a href="#" onclick="toggleCode('method_GetDynamicFiles');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_GetDynamicFiles">
                                        <pre>

sub GetDynamicFiles {
    my $Self = shift;

    # get config object
    my $ConfigObject = $Kernel::OM->Get('Kernel::Config');

    my %Filelist = %{ $ConfigObject->Get('Stats::DynamicObjectRegistration') };
    OBJECT:
    for my $Object ( sort keys %Filelist ) {
        if ( !$Filelist{$Object} ) {
            delete $Filelist{$Object};
            next OBJECT;
        }
        $Filelist{$Object} = $Self->GetObjectName(
            ObjectModule => $Filelist{$Object}{Module},
        );
    }
    return if !%Filelist;

    return \%Filelist;
}
</pre></div>

<p>Get all static objects</p>

<pre>    my $FileHash = $StatsObject-&gt;GetDynamicFiles();
</pre><h2 id="GetObjectName">GetObjectName()</h2>

<p><a href="#" onclick="toggleCode('method_GetObjectName');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_GetObjectName">
                                        <pre>

sub GetObjectName {
    my ( $Self, %Param ) = @_;
    my $Module = $Param{ObjectModule};

    # check if it is cached
    return $Self->{'Cache::ObjectName'}->{$Module} if $Self->{'Cache::ObjectName'}->{$Module};

    # load module, return if module does not exist
    # (this is important when stats are uninstalled, see also bug# 4269)
    return if !$Kernel::OM->Get('Kernel::System::Main')->Require($Module);

    # get name
    my $StatObject = $Module->new( %{$Self} );
    return if !$StatObject;
    my $Name = $StatObject->GetObjectName();

    # cache the result
    $Self->{'Cache::ObjectName'}->{$Module} = $Name;

    return $Name;
}
</pre></div>

<p>Get the name of a dynamic object</p>

<pre>    my $ObjectName = $StatsObject-&gt;GetObjectName(
        ObjectModule =&gt; 'Kernel::System::Stats::Dynamic::TicketList',
    );
</pre><h2 id="GetObjectBehaviours">GetObjectBehaviours()</h2>

<p><a href="#" onclick="toggleCode('method_GetObjectBehaviours');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_GetObjectBehaviours">
                                        <pre>

sub GetObjectBehaviours {
    my ( $Self, %Param ) = @_;
    my $Module = $Param{ObjectModule};

    # check if it is cached
    if ( $Self->{'Cache::ObjectBehaviours'}->{$Module} ) {
        return $Self->{'Cache::ObjectBehaviours'}->{$Module}
    }

    # load module, return if module does not exist
    # (this is important when stats are uninstalled, see also bug# 4269)
    return if !$Kernel::OM->Get('Kernel::System::Main')->Require($Module);

    my $StatObject = $Module->new( %{$Self} );
    return if !$StatObject;

    return if !$StatObject->can('GetObjectBehaviours');
    my %ObjectBehaviours = $StatObject->GetObjectBehaviours();

    # cache the result
    $Self->{'Cache::ObjectBehaviours'}->{$Module} = \%ObjectBehaviours;

    return \%ObjectBehaviours;
}
</pre></div>

<p>get behaviours that a statistic supports</p>

<pre>    my $Behaviours = $StatsObject-&gt;GetObjectBehaviours(
        ObjectModule =&gt; 'Kernel::System::Stats::Dynamic::TicketList',
    );

    returns

    {
        ProvidesDashboardWidget =&gt; 1,
        ...
    }
</pre><h2 id="ObjectFileCheck">ObjectFileCheck()</h2>

<p><a href="#" onclick="toggleCode('method_ObjectFileCheck');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_ObjectFileCheck">
                                        <pre>

sub ObjectFileCheck {
    my ( $Self, %Param ) = @_;

    my $Directory = $Kernel::OM->Get('Kernel::Config')->Get('Home');
    if ( $Directory !~ m{^.*\/$}x ) {
        $Directory .= '/';
    }
    if ( $Param{Type} eq 'static' ) {
        $Directory .= 'Kernel/System/Stats/Static/' . $Param{Name} . '.pm';
    }
    elsif ( $Param{Type} eq 'dynamic' ) {
        $Directory .= 'Kernel/System/Stats/Dynamic/' . $Param{Name} . '.pm';
    }

    return 1 if -r $Directory;
    return;
}
</pre></div>

<p>check readable object file</p>

<pre>    my $ObjectFileCheck = $StatsObject-&gt;ObjectFileCheck(
        Type =&gt; 'static',
        Name =&gt; 'NewTickets',
    );
</pre><h2 id="Export">Export()</h2>

<p><a href="#" onclick="toggleCode('method_Export');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Export">
                                        <pre>

sub Export {
    my ( $Self, %Param ) = @_;

    if ( !$Param{StatID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Export: Need StatID!'
        );
        return;
    }

    # get xml object
    my $XMLObject = $Kernel::OM->Get('Kernel::System::XML');

    my @XMLHash = $XMLObject->XMLHashGet(
        Type => 'Stats',

        #Cache => 0,
        Key => $Param{StatID}
    );
    my $StatsXML = $XMLHash[0]->{otrs_stats}->[1];

    my %File;
    $File{Filename} = $Self->StringAndTimestamp2Filename(
        String => $StatsXML->{Title}->[1]->{Content},
    );
    $File{Filename} .= '.xml';

    # settings for static files
    if (
        $StatsXML->{StatType}->[1]->{Content}
        && $StatsXML->{StatType}->[1]->{Content} eq 'static'
        )
    {
        my $FileLocation = $StatsXML->{ObjectModule}->[1]->{Content};
        $FileLocation =~ s{::}{\/}xg;
        $FileLocation .= '.pm';
        my $File        = $Kernel::OM->Get('Kernel::Config')->Get('Home') . "/$FileLocation";
        my $FileContent = '';

        open my $Filehandle, '<', $File || die "Can't open: $File: $!";    ## no critic

        # set bin mode
        binmode $Filehandle;
        while (<$Filehandle>) {
            $FileContent .= $_;
        }
        close $Filehandle;

        $Kernel::OM->Get('Kernel::System::Encode')->EncodeInput( \$FileContent );
        $StatsXML->{File}->[1]->{File}       = $StatsXML->{File}->[1]->{Content};
        $StatsXML->{File}->[1]->{Content}    = encode_base64( $FileContent, '' );
        $StatsXML->{File}->[1]->{Location}   = $FileLocation;
        $StatsXML->{File}->[1]->{Permission} = '644';
        $StatsXML->{File}->[1]->{Encode}     = 'Base64';
    }

    # delete create and change data
    for my $Key (qw(Changed ChangedBy Created CreatedBy StatID)) {
        delete $StatsXML->{$Key};
    }
    if ( !$Param{ExportStatNumber} ) {
        delete $StatsXML->{StatNumber};
    }

    # wrapper to change ids in used spelling
    # wrap permissions
    PERMISSION:
    for my $ID ( @{ $StatsXML->{Permission} } ) {
        next PERMISSION if !$ID;
        my $Name = $Kernel::OM->Get('Kernel::System::Group')->GroupLookup( GroupID => $ID->{Content} );
        next PERMISSION if !$Name;
        $ID->{Content} = $Name;
    }

    # wrap object dependend ids
    if ( $StatsXML->{Object}->[1]->{Content} ) {

        # load module
        my $ObjectModule = $StatsXML->{ObjectModule}->[1]->{Content};
        return if !$Kernel::OM->Get('Kernel::System::Main')->Require($ObjectModule);
        my $StatObject = $ObjectModule->new( %{$Self} );
        return if !$StatObject;

        # load attributes
        $StatsXML = $StatObject->ExportWrapper(
            %{$StatsXML},
        );
    }

    # convert hash to string
    $File{Content} = $XMLObject->XMLHash2XML(
        {
            otrs_stats => [
                undef,
                $StatsXML,
            ],
        },
    );

    return \%File;
}
</pre></div>

<p>get content from stats for export</p>

<pre>    my $ExportFile = $StatsObject-&gt;Export(
        StatID =&gt; '123',
        ExportStatNumber =&gt; 1 || 0, # optional, only useful move statistics from the test system to the productive system
    );
</pre><h2 id="Import">Import()</h2>

<p><a href="#" onclick="toggleCode('method_Import');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Import">
                                        <pre>

sub Import {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(UserID Content)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => "error",
                Message  => "Need $Needed.",
            );
            return;
        }
    }

    # get xml object
    my $XMLObject = $Kernel::OM->Get('Kernel::System::XML');

    my @XMLHash = $XMLObject->XMLParse2XMLHash( String => $Param{Content} );

    if ( !$XMLHash[0] ) {
        shift @XMLHash;
    }
    my $StatsXML = $XMLHash[0]->{otrs_stats}->[1];

    # Get new StatID
    my @Keys = $XMLObject->XMLHashSearch(
        Type => 'Stats',
    );

    # check if the required elements are available
    for my $Element (
        qw( Description Format Object ObjectModule Permission StatType SumCol SumRow Title Valid)
        )
    {
        if ( !defined $StatsXML->{$Element}->[1]->{Content} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message =>
                    "Can't import Stat, because the required element $Element is not available!"
            );
            return;
        }
    }

    # get config object
    my $ConfigObject = $Kernel::OM->Get('Kernel::Config');

    # if-clause if a stat-xml includes a StatNumber
    my $StatID = 1;
    if ( $StatsXML->{StatNumber} ) {
        my $XMLStatsID = $StatsXML->{StatNumber}->[1]->{Content}
            - $ConfigObject->Get('Stats::StatsStartNumber');
        for my $Key (@Keys) {
            if ( $Key eq $XMLStatsID ) {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message =>
                        "Can't import StatNumber $Key, because this StatNumber is already used!"
                );
                return;
            }
        }
        $StatID = $XMLStatsID;
    }

    # if no stats number available use this function
    else {
        my @SortKeys = sort { $a <=> $b } @Keys;
        if (@SortKeys) {
            $StatID = $SortKeys[-1] + 1;
        }
    }

    # get time object
    my $TimeObject = $Kernel::OM->Get('Kernel::System::Time');

    # get time
    my $TimeStamp = $TimeObject->SystemTime2TimeStamp(
        SystemTime => $TimeObject->SystemTime(),
    );

    # meta tags
    $StatsXML->{Created}->[1]->{Content}    = $TimeStamp;
    $StatsXML->{CreatedBy}->[1]->{Content}  = $Param{UserID};
    $StatsXML->{Changed}->[1]->{Content}    = $TimeStamp;
    $StatsXML->{ChangedBy}->[1]->{Content}  = $Param{UserID};
    $StatsXML->{StatNumber}->[1]->{Content} = $StatID + $ConfigObject->Get('Stats::StatsStartNumber');

    my $DynamicFiles = $Self->GetDynamicFiles();

    # Because some xml-parser insert \n instead of <example><example>
    if ( $StatsXML->{Object}->[1]->{Content} ) {
        $StatsXML->{Object}->[1]->{Content} =~ s{\n}{}x;
    }

    if (
        $StatsXML->{Object}->[1]->{Content}
        && !$DynamicFiles->{ $StatsXML->{Object}->[1]->{Content} }
        )
    {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Object $StatsXML->{Object}->[1]->{Content} doesn't exist!"
        );
        return;
    }

    # static statistic
    if (
        $StatsXML->{StatType}->[1]->{Content}
        && $StatsXML->{StatType}->[1]->{Content} eq 'static'
        )
    {
        my $FileLocation = $StatsXML->{ObjectModule}[1]{Content};
        $FileLocation =~ s{::}{\/}gx;
        $FileLocation = $ConfigObject->Get('Home') . '/' . $FileLocation . '.pm';

        # if no inline file is given in the stats definition
        if ( !$StatsXML->{File}->[1]->{Content} ) {

            # get the file name
            $FileLocation =~ s{ \A .*? ( [^/]+ ) \. pm  \z }{$1}xms;

            # set the file name
            $StatsXML->{File}->[1]->{Content} = $FileLocation;
        }

        # write file if it is included in the stats definition
        ## no critic
        elsif ( open my $Filehandle, '>', $FileLocation ) {
            ## use critic

            print STDERR "Notice: Install $FileLocation ($StatsXML->{File}[1]{Permission})!\n";
            if ( $StatsXML->{File}->[1]->{Encode} && $StatsXML->{File}->[1]->{Encode} eq 'Base64' )
            {
                $StatsXML->{File}->[1]->{Content} = decode_base64( $StatsXML->{File}->[1]->{Content} );
                $Kernel::OM->Get('Kernel::System::Encode')->EncodeOutput(
                    \$StatsXML->{File}->[1]->{Content}
                );
            }

            # set utf8 or bin mode
            if ( $StatsXML->{File}->[1]->{Content} =~ /use\sutf8;/ ) {
                open $Filehandle, '>:utf8', $FileLocation;    ## no critic
            }
            else {
                binmode $Filehandle;
            }
            print $Filehandle $StatsXML->{File}->[1]->{Content};
            close $Filehandle;

            # set permission
            if ( length( $StatsXML->{File}->[1]->{Permission} ) == 3 ) {
                $StatsXML->{File}->[1]->{Permission} = "0$StatsXML->{File}->[1]->{Permission}";
            }
            chmod( oct( $StatsXML->{File}->[1]->{Permission} ), $FileLocation );
            $StatsXML->{File}->[1]->{Content} = $StatsXML->{File}->[1]->{File};

            delete $StatsXML->{File}->[1]->{File};
            delete $StatsXML->{File}->[1]->{Location};
            delete $StatsXML->{File}->[1]->{Permission};
            delete $StatsXML->{File}->[1]->{Encode};
        }
    }

    # wrapper to change used spelling in ids
    # wrap permissions
    my %Groups = $Kernel::OM->Get('Kernel::System::Group')->GroupList( Valid => 1 );

    NAME:
    for my $Name ( @{ $StatsXML->{Permission} } ) {
        next NAME if !$Name;

        my $Flag = 1;
        ID:
        for my $ID ( sort keys %Groups ) {
            if ( $Groups{$ID} eq $Name->{Content} ) {
                $Name->{Content} = $ID;
                $Flag = 0;
                last ID;
            }
        }
        if ($Flag) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Can't find the permission (group) $Name->{Content}!"
            );
            $Name = undef;
        }
    }

    # wrap object dependend ids
    if ( $StatsXML->{Object}->[1]->{Content} ) {

        # load module
        my $ObjectModule = $StatsXML->{ObjectModule}->[1]->{Content};
        return if !$Kernel::OM->Get('Kernel::System::Main')->Require($ObjectModule);
        my $StatObject = $ObjectModule->new( %{$Self} );
        return if !$StatObject;

        # load attributes
        $StatsXML = $StatObject->ImportWrapper( %{$StatsXML} );
    }

    # new
    return if !$XMLObject->XMLHashAdd(
        Type    => 'Stats',
        Key     => $StatID,
        XMLHash => [
            {
                otrs_stats => [
                    undef,
                    $StatsXML,
                ],
            },
        ],
    );

    $Kernel::OM->Get('Kernel::System::Cache')->CleanUp(
        Type => 'Stats',
    );

    return $StatID;
}
</pre></div>

<p>import a stats from xml file</p>

<pre>    my $StatID = $StatsObject-&gt;Import(
        UserID  =&gt; $UserID,
        Content =&gt; $UploadStuff{Content},
    );
</pre><h2 id="GetParams">GetParams()</h2>

<p><a href="#" onclick="toggleCode('method_GetParams');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_GetParams">
                                        <pre>

sub GetParams {
    my ( $Self, %Param ) = @_;

    if ( !$Param{StatID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need StatID!'
        );
        return;
    }

    my $Stat = $Self->StatsGet( StatID => $Param{StatID} );

    # static
    # don't remove this if clause, because is required for otrs.GenerateStats.pl
    my @Params;
    if ( $Stat->{StatType} eq 'static' ) {

        # load static modul
        my $ObjectModule = $Stat->{ObjectModule};
        return if !$Kernel::OM->Get('Kernel::System::Main')->Require($ObjectModule);
        my $StatObject = $ObjectModule->new( %{$Self} );
        return if !$StatObject;

        # get params
        @Params = $StatObject->Param();
    }

    return \@Params;
}
</pre></div>

<pre>    get all edit params from stats for view

    my $Params = $StatsObject-&gt;GetParams( StatID =&gt; '123' );
</pre><h2 id="StatsRun">StatsRun()</h2>

<p><a href="#" onclick="toggleCode('method_StatsRun');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_StatsRun">
                                        <pre>

sub StatsRun {
    my ( $Self, %Param ) = @_;

    # check needed params
    for my $Needed (qw(StatID GetParam UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!"
            );
            return;
        }
    }

    my $Stat = $Self->StatsGet( StatID => $Param{StatID} );
    my %GetParam = %{ $Param{GetParam} };
    my @Result;

    # Perform calculations on the slave DB, if configured.
    local $Kernel::System::DB::UseSlaveDB = 1;

    # get data if it is a static stats
    if ( $Stat->{StatType} eq 'static' ) {

        return if $Param{Preview};    # not supported for static stats

        @Result = $Self->_GenerateStaticStats(
            ObjectModule => $Stat->{ObjectModule},
            GetParam     => $Param{GetParam},
            Title        => $Stat->{Title},
            StatID       => $Stat->{StatID},
            Cache        => $Stat->{Cache},
            UserID       => $Param{UserID},
        );
    }

    # get data if it is a dynaymic stats
    elsif ( $Stat->{StatType} eq 'dynamic' ) {
        @Result = $Self->_GenerateDynamicStats(
            ObjectModule     => $Stat->{ObjectModule},
            Object           => $Stat->{Object},
            UseAsXvalue      => $GetParam{UseAsXvalue},
            UseAsValueSeries => $GetParam{UseAsValueSeries} || [],
            UseAsRestriction => $GetParam{UseAsRestriction} || [],
            Title            => $Stat->{Title},
            StatID           => $Stat->{StatID},
            TimeZone         => $GetParam{TimeZone},
            Cache            => $Stat->{Cache},
            Preview          => $Param{Preview},
            UserID           => $Param{UserID},
        );
    }

    # build sum in row or col
    if ( @Result && ( $Stat->{SumRow} || $Stat->{SumCol} ) && $Stat->{Format} !~ m{^GD::Graph\.*}x ) {
        return $Self->SumBuild(
            Array  => \@Result,
            SumRow => $Stat->{SumRow},
            SumCol => $Stat->{SumCol},
        );
    }

    return \@Result;
}
</pre></div>

<p>run a statistic.</p>

<pre>    my $StatArray = $StatsObject-&gt;StatsRun(
        StatID     =&gt; '123',
        GetParam   =&gt; \%GetParam,
        Preview    =&gt; 1,        # optional, return fake data for preview (only for dynamic stats)
        UserID     =&gt; $UserID,
    );
</pre><h2 id="StatsResultCacheCompute">StatsResultCacheCompute()</h2>

<p><a href="#" onclick="toggleCode('method_StatsResultCacheCompute');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_StatsResultCacheCompute">
                                        <pre>

sub StatsResultCacheCompute {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(StatID UserGetParam UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!"
            );
            return;
        }
    }

    my $Stat = $Self->StatsGet(
        StatID => $Param{StatID},
    );

    my $StatsViewObject = $Kernel::OM->Get('Kernel::Output::HTML::Statistics::View');

    my $StatConfigurationValid = $StatsViewObject->StatsConfigurationValidate(
        Stat   => $Stat,
        Errors => {},
        UserID => $Param{UserID},
    );
    if ( !$StatConfigurationValid ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "This statistic contains configuration errors, skipping.",
        );
        return;
    }

    my %GetParam = eval {
        $StatsViewObject->StatsParamsGet(
            Stat         => $Stat,
            UserGetParam => $Param{UserGetParam},
        );
    };

    if ( $@ || !%GetParam ) {
        my $Errors = ref $@ ? join( "\n", @{$@} ) : $@;
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "The dashboard widget configuration for this user contains errors, skipping: $Errors"
        );
        return;
    }

    # get main object
    my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

    my $DumpString = $MainObject->Dump( \%GetParam );

    my $MD5Sum = $MainObject->MD5sum(
        String => \$DumpString,
    );

    my $CacheKey = "StatsRunCached::$Param{UserID}::$Param{StatID}::$MD5Sum";

    my $Result = $Self->StatsRun(
        StatID   => $Param{StatID},
        GetParam => \%GetParam,
        UserID   => $Param{UserID},
    );

    # Only set/update the cache after computing it, otherwise no cache data
    #   would be available in between.
    return $Kernel::OM->Get('Kernel::System::Cache')->Set(
        Type  => 'StatsRun',
        Key   => $CacheKey,
        Value => $Result,
        TTL   => 24 * 60 * 60,    # cache it for a day, will be overwritten by next function call

        # Don't store complex structure in memory as it will be modified later.
        CacheInMemory => 0,
    );
}
</pre></div>

<p>computes stats results and adds them to the cache.
This can be used to precompute stats data e. g. for dashboard widgets in a cron job.</p>

<pre>    my $StatArray = $StatsObject-&gt;StatsResultCacheCompute(
        StatID       =&gt; '123',
        UserID       =&gt; $UserID,        # target UserID
        UserGetParam =&gt; \%UserGetParam, # user settings of non-fixed fields
    );
</pre><h2 id="StatsResultCacheGet">StatsResultCacheGet()</h2>

<p><a href="#" onclick="toggleCode('method_StatsResultCacheGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_StatsResultCacheGet">
                                        <pre>

sub StatsResultCacheGet {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(StatID UserGetParam UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!"
            );
            return;
        }
    }

    my $Stat = $Self->StatsGet(
        StatID => $Param{StatID},
    );

    my $StatsViewObject = $Kernel::OM->Get('Kernel::Output::HTML::Statistics::View');

    my $StatConfigurationValid = $StatsViewObject->StatsConfigurationValidate(
        Stat   => $Stat,
        Errors => {},
        UserID => $Param{UserID},
    );
    if ( !$StatConfigurationValid ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "This statistic contains configuration errors, skipping.",
        );
        return;
    }

    my %GetParam = eval {
        $StatsViewObject->StatsParamsGet(
            Stat         => $Stat,
            UserGetParam => $Param{UserGetParam},
            UserID       => $Param{UserID},
        );
    };

    if ( $@ || !%GetParam ) {
        my $Errors = ref $@ ? join( "\n", @{$@} ) : $@;
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "The dashboard widget configuration for this user contains errors, skipping: $Errors"
        );
        return;
    }

    # get main object
    my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

    my $DumpString = $MainObject->Dump( \%GetParam );

    my $MD5Sum = $MainObject->MD5sum(
        String => \$DumpString,
    );

    my $CacheKey = "StatsRunCached::$Param{UserID}::$Param{StatID}::$MD5Sum";

    return $Kernel::OM->Get('Kernel::System::Cache')->Get(
        Type => 'StatsRun',
        Key  => $CacheKey,

        # Don't store complex structure in memory as it will be modified later.
        CacheInMemory => 0,
    );
}
</pre></div>

<p>gets cached statistic results. Will never run the statistic.
This can be used to fetch cached stats data e. g. for stats widgets in the dashboard.</p>

<pre>    my $StatArray = $StatsObject-&gt;StatsResultCacheGet(
        StatID       =&gt; '123',
        UserID       =&gt; $UserID,    # target UserID
        UserGetParam =&gt; \%GetParam,
    );
</pre><h2 id="StringAndTimestamp2Filename">StringAndTimestamp2Filename()</h2>

<p><a href="#" onclick="toggleCode('method_StringAndTimestamp2Filename');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_StringAndTimestamp2Filename">
                                        <pre>

sub StringAndTimestamp2Filename {
    my ( $Self, %Param ) = @_;

    if ( !$Param{String} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need String!'
        );
        return;
    }

    my $DateTimeObject = $Kernel::OM->Create('Kernel::System::DateTime');
    if ( defined $Param{TimeZone} ) {
        $DateTimeObject->ToTimeZone( TimeZone => $Param{TimeZone} );
    }

    my $MainObject = $Kernel::OM->Get('Kernel::System::Main');
    $Param{String} = $MainObject->FilenameCleanUp(
        Filename => $Param{String},
        Type     => 'Attachment',
    );

    my $Filename = $Param{String} . '_';
    $Filename .= $DateTimeObject->Format( Format => '%Y-%m-%d_%H:%M' );

    if ( defined $Param{TimeZone} ) {
        my $TimeZone = $MainObject->FilenameCleanUp(
            Filename => $Param{TimeZone},
            Type     => 'Attachment',
        );
        $Filename .= '_TimeZone_' . $TimeZone;
    }

    return $Filename;
}
</pre></div>

<p>builds a filename with a string and a timestamp.
(space will be replaced with _ and - e.g. Title-of-File_2006-12-31_11-59)</p>

<pre>    my $Filename = $StatsObject-&gt;StringAndTimestamp2Filename(
        String   =&gt; 'Title',
        TimeZone =&gt; 'Europe/Berlin',  # optional
    );
</pre><h2 id="StatNumber2StatID">StatNumber2StatID()</h2>

<p><a href="#" onclick="toggleCode('method_StatNumber2StatID');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_StatNumber2StatID">
                                        <pre>

sub StatNumber2StatID {
    my ( $Self, %Param ) = @_;

    if ( !$Param{StatNumber} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need StatNumber!',
        );
        return;
    }

    my @Key = $Kernel::OM->Get('Kernel::System::XML')->XMLHashSearch(
        Type => 'Stats',
        What => [ { "[%]{'otrs_stats'}[%]{'StatNumber'}[%]{'Content'}" => $Param{StatNumber} } ],
    );
    if ( @Key && $#Key < 1 ) {
        return $Key[0];
    }

    $Kernel::OM->Get('Kernel::System::Log')->Log(
        Priority => 'error',
        Message  => 'StatNumber invalid!',
    );
    return;
}
</pre></div>

<p>insert the stat number get the stat id</p>

<pre>    my $StatID = $StatsObject-&gt;StatNumber2StatID(
        StatNumber =&gt; 11212,
    );
</pre><h2 id="StatsInstall">StatsInstall()</h2>

<p><a href="#" onclick="toggleCode('method_StatsInstall');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_StatsInstall">
                                        <pre>

sub StatsInstall {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!"
            );
            return;
        }
    }

    # prepare prefix
    $Param{FilePrefix} = $Param{FilePrefix} ? $Param{FilePrefix} . '-' : '';

    # start AutomaticSampleImport if no stats are installed
    $Self->GetStatsList(
        UserID => $Param{UserID},
    );

    # cleanup stats
    $Self->StatsCleanUp(
        UserID => $Param{UserID},
    );

    # get main object
    my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

    # get list of stats files
    my @StatsFileList = $MainObject->DirectoryRead(
        Directory => $Self->{StatsTempDir},
        Filter    => $Param{FilePrefix} . '*.xml',
    );

    # import the stats
    my $InstalledPostfix = '.installed';
    FILE:
    for my $File ( sort @StatsFileList ) {

        next FILE if !-f $File;
        next FILE if -e $File . $InstalledPostfix;

        # read file content
        my $XMLContentRef = $MainObject->FileRead(
            Location => $File,
        );

        # import stat
        my $StatID = $Self->Import(
            Content => ${$XMLContentRef},
            UserID  => $Param{UserID},
        );

        next FILE if !$StatID;

        # write installed file with stat id
        $MainObject->FileWrite(
            Content  => \$StatID,
            Location => $File . $InstalledPostfix,
        );
    }

    return 1;
}
</pre></div>

<p>installs stats</p>

<pre>    my $Result = $StatsObject-&gt;StatsInstall(
        FilePrefix =&gt; 'FAQ',  # (optional)
        UserID     =&gt; $UserID,
    );
</pre><h2 id="StatsUninstall">StatsUninstall()</h2>

<p><a href="#" onclick="toggleCode('method_StatsUninstall');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_StatsUninstall">
                                        <pre>

sub StatsUninstall {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!"
            );
            return;
        }
    }

    # prepare prefix
    $Param{FilePrefix} = $Param{FilePrefix} ? $Param{FilePrefix} . '-' : '';

    # get main object
    my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

    # get list of installed stats files
    my @StatsFileList = $MainObject->DirectoryRead(
        Directory => $Self->{StatsTempDir},
        Filter    => $Param{FilePrefix} . '*.xml.installed',
    );

    # delete the stats
    for my $File ( sort @StatsFileList ) {

        # read file content
        my $StatsIDRef = $MainObject->FileRead(
            Location => $File,
        );

        # delete stats
        $Self->StatsDelete(
            StatID => ${$StatsIDRef},
            UserID => $Param{UserID},
        );
    }

    # cleanup stats
    $Self->StatsCleanUp(
        UserID => $Param{UserID},
    );

    return 1;
}
</pre></div>

<p>uninstalls stats</p>

<pre>    my $Result = $StatsObject-&gt;StatsUninstall(
        FilePrefix =&gt; 'FAQ',  # (optional)
        UserID     =&gt; $UserID,
    );
</pre><h2 id="StatsCleanUp">StatsCleanUp()</h2>

<p><a href="#" onclick="toggleCode('method_StatsCleanUp');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_StatsCleanUp">
                                        <pre>

sub StatsCleanUp {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(UserID)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!"
            );
            return;
        }
    }

    # get a list of all stats
    my $ListRef = $Self->GetStatsList(
        UserID => $Param{UserID},
    );

    return if !$ListRef;
    return if ref $ListRef ne 'ARRAY';

    # get main object
    my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

    STATSID:
    for my $StatsID ( @{$ListRef} ) {

        # get stats
        my $HashRef = $Self->StatsGet(
            StatID             => $StatsID,
            NoObjectAttributes => 1,
        );

        next STATSID if $HashRef
            && ref $HashRef eq 'HASH'
            && $HashRef->{ObjectModule}
            && $MainObject->Require( $HashRef->{ObjectModule} );

        # delete stats
        $Self->StatsDelete(
            StatID => $StatsID,
            UserID => $Param{UserID},
        );
    }

    return 1;
}
</pre></div>

<p>removed stats with not existing backend file</p>

<pre>    my $Result = $StatsObject-&gt;StatsCleanUp();
</pre><h1 id="TERMS_AND_CONDITIONS">TERMS AND CONDITIONS <a href="#TOP" class="toplink"><img alt="^" src="../../up.gif" /></a></h1>

<p>This software is part of the OTRS project (<a href="http://otrs.org/">http://otrs.org/</a>).</p>

<p>This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see <a href="http://www.gnu.org/licenses/agpl.txt">http://www.gnu.org/licenses/agpl.txt</a>.</p>


</div><div class="footer">generated by <a href="http://search.cpan.org/perldoc?Pod%3A%3AProjectDocs">Pod::ProjectDocs</a></div></body>
</html>
