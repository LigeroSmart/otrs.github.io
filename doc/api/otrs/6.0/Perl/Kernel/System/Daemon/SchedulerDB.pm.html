<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<!-- otrs.github.io -->
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../../../../../../../documentation.css">
<script src="https://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../../../../../../documentation.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script>
$(document).ready(function() {

    // Hint languages to prevent false matches (php for example).
    hljs.configure({
        languages: ['perl', 'javascript', 'xml', 'html', 'css', 'json', 'yaml', 'bash']
    });

    // programlistings in manuals
    $('pre.programlisting').each(function(i, block) {
        hljs.highlightBlock(block);
    });
    // code snippets in Perl API docs
    $('.pod pre').addClass('perl').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});</script>
<!-- otrs.github.io -->

	<title>Kernel::System::Daemon::SchedulerDB</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <script type="text/javascript">

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  </script></head>
<body>
<div class="box">
  <h1 class="t1">OTRS 6.0 API Reference Perl</h1>
  <table>
    <tr>
      <td class="label">Description</td>
      <td class="cell">manuals and libraries</td>
    </tr>
  </table>
</div>
<div class="path">
  <a href="../../../index.html">OTRS 6.0 API Reference Perl</a> &gt; Perl Modules &gt;
  Kernel::System::Daemon::SchedulerDB
</div>
<div>
<a href="../../../src/Kernel/System/Daemon/SchedulerDB.pm">Source</a>
</div>
<div class="pod">
<!-- INDEX START -->
<h3 id="TOP">Index</h3>
<ul>
	<li><a href="#NAME">NAME</a></li>
	<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
	<li><a href="#PUBLIC_INTERFACE">PUBLIC INTERFACE</a><br />
<ul>
	<li><a href="#new">new()</a></li>
	<li><a href="#TaskAdd">TaskAdd()</a></li>
	<li><a href="#TaskGet">TaskGet()</a></li>
	<li><a href="#TaskDelete">TaskDelete()</a></li>
	<li><a href="#TaskList">TaskList()</a></li>
	<li><a href="#TaskListUnlocked">TaskListUnlocked()</a></li>
	<li><a href="#TaskLock">TaskLock()</a></li>
	<li><a href="#TaskCleanup">TaskCleanup()</a></li>
	<li><a href="#TaskSummary">TaskSummary()</a></li>
	<li><a href="#TaskLockUpdate">TaskLockUpdate()</a></li>
	<li><a href="#TaskUnlockExpired">TaskUnlockExpired()</a></li>
	<li><a href="#FutureTaskAdd">FutureTaskAdd()</a></li>
	<li><a href="#FutureTaskGet">FutureTaskGet()</a></li>
	<li><a href="#FutureTaskDelete">FutureTaskDelete()</a></li>
	<li><a href="#FutureTaskList">FutureTaskList()</a></li>
	<li><a href="#FutureTaskToExecute">FutureTaskToExecute()</a></li>
	<li><a href="#FutureTaskSummary">FutureTaskSummary()</a></li>
	<li><a href="#CronTaskToExecute">CronTaskToExecute()</a></li>
	<li><a href="#CronTaskCleanup">CronTaskCleanup()</a></li>
	<li><a href="#CronTaskSummary">CronTaskSummary()</a></li>
	<li><a href="#GenericAgentTaskToExecute">GenericAgentTaskToExecute()</a></li>
	<li><a href="#GenericAgentTaskCleanup">GenericAgentTaskCleanup()</a></li>
	<li><a href="#GenericAgentTaskSummary">GenericAgentTaskSummary()</a></li>
	<li><a href="#RecurrentTaskGet">RecurrentTaskGet()</a></li>
	<li><a href="#RecurrentTaskList">RecurrentTaskList()</a></li>
	<li><a href="#RecurrentTaskDelete">RecurrentTaskDelete()</a></li>
	<li><a href="#RecurrentTaskExecute">RecurrentTaskExecute()</a></li>
	<li><a href="#RecurrentTaskSummary">RecurrentTaskSummary()</a></li>
	<li><a href="#RecurrentTaskWorkerInfoSet">RecurrentTaskWorkerInfoSet()</a></li>
	<li><a href="#RecurrentTaskUnlockExpired">RecurrentTaskUnlockExpired()</a></li>
</ul>
</li>
	<li><a href="#TERMS_AND_CONDITIONS">TERMS AND CONDITIONS</a></li>
</ul>
<hr />
<!-- INDEX END -->

<h1 id="NAME">NAME <a href="#TOP" class="toplink"><img alt="^" src="../../../up.gif" /></a></h1>

<p>Kernel::System::Daemon::SchedulerDB - Scheduler database lib</p>

<h1 id="DESCRIPTION">DESCRIPTION <a href="#TOP" class="toplink"><img alt="^" src="../../../up.gif" /></a></h1>

<p>Includes all scheduler related database functions.</p>

<h1 id="PUBLIC_INTERFACE">PUBLIC INTERFACE <a href="#TOP" class="toplink"><img alt="^" src="../../../up.gif" /></a></h1>

<h2 id="new">new()</h2>

<p><a href="#" onclick="toggleCode('method_new');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_new">
                                        <pre>

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    return $Self;
}
</pre></div>

<p>create a scheduler database object. Do not use it directly, instead use:</p>

<pre>    my $SchedulerDBObject = $Kernel::OM-&gt;Get('Kernel::System::Daemon::SchedulerDB');
</pre><h2 id="TaskAdd">TaskAdd()</h2>

<p><a href="#" onclick="toggleCode('method_TaskAdd');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_TaskAdd">
                                        <pre>

sub TaskAdd {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Key (qw(Type Data)) {
        if ( !$Param{$Key} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Key!",
            );

            return;
        }
    }

    if ( $Param{MaximumParallelInstances} && $Param{MaximumParallelInstances} =~ m{\A \d+ \z}msx ) {

        # get the list of all worker tasks for the specified task type
        my @List = $Self->TaskList(
            Type => $Param{Type},
        );

        my @FilteredList = @List;

        if ( $Param{Name} ) {

            # remove all tasks that does not match specified task name
            @FilteredList = grep { $_->{Name} eq $Param{Name} } @List;
        }

        # compare the number of task with the maximum parallel limit
        return -1 if scalar @FilteredList >= $Param{MaximumParallelInstances}
    }

    # set default of attempts parameter
    $Param{Attempts} ||= 1;

    # serialize data as string
    my $Data = $Kernel::OM->Get('Kernel::System::Storable')->Serialize(
        Data => $Param{Data},
    );

    # encode task data
    $Kernel::OM->Get('Kernel::System::Encode')->EncodeOutput($Data);
    $Data = encode_base64($Data);

    # get needed objects
    my $DBObject   = $Kernel::OM->Get('Kernel::System::DB');
    my $TimeObject = $Kernel::OM->Get('Kernel::System::Time');

    my $Identifier;
    TRY:
    for my $Try ( 1 .. 10 ) {

        # calculate a task identifier
        $Identifier = $TimeObject->SystemTime() . int rand 1000000;

        # insert the task (initially locked with lock_key = 1 so it will not be taken by any worker
        #   at this moment)
        last TRY if $DBObject->Do(
            SQL => '
                INSERT INTO scheduler_task
                    (ident, name, task_type, task_data, attempts, lock_key, create_time)
                VALUES
                    (?, ?, ?, ?, ?, 1, current_timestamp)',
            Bind => [
                \$Identifier,
                \$Param{Name},
                \$Param{Type},
                \$Data,
                \$Param{Attempts},
            ],
        );
    }

    # get task id
    $DBObject->Prepare(
        SQL  => 'SELECT id FROM scheduler_task WHERE ident = ?',
        Bind => [ \$Identifier ],
    );

    # fetch the task id
    my $TaskID;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        $TaskID = $Row[0];
    }

    # unlock the task, for now on the task can be taken by any worker
    $DBObject->Do(
        SQL => '
            UPDATE scheduler_task
            SET lock_key = 0
            WHERE lock_key = 1 AND id = ?',
        Bind => [
            \$TaskID,
        ],
    );

    # delete task list cache
    $Kernel::OM->Get('Kernel::System::Cache')->Delete(
        Type => 'SchedulerDB',
        Key  => 'TaskListUnlocked',
    );

    return $TaskID;
}
</pre></div>

<p>add a new task to scheduler task list</p>

<pre>    my $TaskID = $SchedulerDBObject-&gt;TaskAdd(
        Type                     =&gt; 'GenericInterface',     # e. g. GenericInterface, Test
        Name                     =&gt; 'any name',             # optional
        Attempts                 =&gt; 5,                      # optional (default 1)
        MaximumParallelInstances =&gt; 2,                      # optional (default 0), number of tasks
                                                            #   with the same type (and name if
                                                            #   provided) that can exists at the same
                                                            #   time, value of 0 means unlimited
        Data =&gt; {                                           # data payload
            ...
        },
    );
</pre><p>Returns:</p>

<pre>    my $TaskID = 123;  # false in case of an error or -1 in case of reach MaximumParallelInstances
</pre><h2 id="TaskGet">TaskGet()</h2>

<p><a href="#" onclick="toggleCode('method_TaskGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_TaskGet">
                                        <pre>

sub TaskGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{TaskID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need TaskID!',
        );
        return;
    }

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # get task from database
    return if !$DBObject->Prepare(
        SQL => '
            SELECT name, task_type, task_data, attempts, lock_key, lock_time, lock_update_time,
                create_time
            FROM scheduler_task
            WHERE id = ?',
        Bind => [ \$Param{TaskID} ],
    );

    # get storable object
    my $StorableObject = $Kernel::OM->Get('Kernel::System::Storable');

    my %Task;
    while ( my @Data = $DBObject->FetchrowArray() ) {

        # decode task data
        my $DecodedData = decode_base64( $Data[2] );

        # deserialize data
        my $DataParam = $StorableObject->Deserialize( Data => $DecodedData );

        if ( !$DataParam ) {

            # error log
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => 'Task data is not in a correct storable format! TaskID: ' . $Param{TaskID},
            );

            # remove damaged task
            $Self->TaskDelete(
                TaskID => $Param{TaskID},
            );

            return;
        }

        %Task = (
            TaskID         => $Param{TaskID},
            Name           => $Data[0],
            Type           => $Data[1],
            Data           => $DataParam || {},
            Attempts       => $Data[3],
            LockKey        => $Data[4] // 0,
            LockTime       => $Data[5] // '',
            LockUpdateTime => $Data[6] // '',
            CreateTime     => $Data[7],
        );
    }

    return %Task;
}
</pre></div>

<p>get scheduler task</p>

<pre>    my %Task = $SchedulerDBObject-&gt;TaskGet(
        TaskID =&gt; 123,
    );
</pre><p>Returns:</p>

<pre>    %Task = (
        TaskID         =&gt; 123,
        Name           =&gt; 'any name',
        Type           =&gt; 'GenericInterface',
        Data           =&gt; $DataRef,
        Attempts       =&gt; 10,
        LockKey        =&gt; 'XYZ',
        LockTime       =&gt; '2011-02-08 15:08:01',
        LockUpdateTime =&gt; '2011-02-08 15:08:01',
        CreateTime     =&gt; '2011-02-08 15:08:00',
    );
</pre><h2 id="TaskDelete">TaskDelete()</h2>

<p><a href="#" onclick="toggleCode('method_TaskDelete');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_TaskDelete">
                                        <pre>

sub TaskDelete {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{TaskID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need TaskID!',
        );
        return;
    }

    # delete task from the list
    $Kernel::OM->Get('Kernel::System::DB')->Do(
        SQL  => 'DELETE FROM scheduler_task WHERE id = ?',
        Bind => [ \$Param{TaskID} ],
    );

    # delete task list cache
    $Kernel::OM->Get('Kernel::System::Cache')->Delete(
        Type => 'SchedulerDB',
        Key  => 'TaskListUnlocked',
    );

    return 1;
}
</pre></div>

<p>delete a task from scheduler task list</p>

<pre>    my $Success = $SchedulerDBObject-&gt;TaskDelete(
        TaskID =&gt; 123,
    );
</pre><h2 id="TaskList">TaskList()</h2>

<p><a href="#" onclick="toggleCode('method_TaskList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_TaskList">
                                        <pre>

sub TaskList {
    my ( $Self, %Param ) = @_;

    my $SQL = 'SELECT id, name, task_type FROM scheduler_task';
    my @Bind;

    # add type
    if ( $Param{Type} ) {
        $SQL .= ' WHERE task_type = ?';
        @Bind = ( \$Param{Type} );
    }

    $SQL .= ' ORDER BY id ASC';

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # ask the database
    return if !$DBObject->Prepare(
        SQL  => $SQL,
        Bind => \@Bind,
    );

    # fetch the result
    my @List;
    while ( my @Row = $DBObject->FetchrowArray() ) {

        push @List, {
            TaskID => $Row[0],
            Name   => $Row[1],
            Type   => $Row[2],
        };
    }

    return @List;
}
</pre></div>

<p>get the list of scheduler tasks</p>

<pre>    my @List = $SchedulerDBObject-&gt;TaskList(
        Type =&gt; 'some type',  # optional
    );
</pre><p>Returns:</p>

<pre>    @List = (
        {
            TaskID =&gt; 123,
            Name   =&gt; 'any name',
            Type   =&gt; 'GenericInterface',
        },
        {
            TaskID =&gt; 456,
            Name   =&gt; 'any other name',
            Type   =&gt; 'GenericInterface',
        },
        # ...
    );
</pre><h2 id="TaskListUnlocked">TaskListUnlocked()</h2>

<p><a href="#" onclick="toggleCode('method_TaskListUnlocked');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_TaskListUnlocked">
                                        <pre>

sub TaskListUnlocked {
    my ( $Self, %Param ) = @_;

    # get cache object
    my $CacheObject = $Kernel::OM->Get('Kernel::System::Cache');

    # read cache
    my $Cache = $CacheObject->Get(
        Type           => 'SchedulerDB',
        Key            => 'TaskListUnlocked',
        CacheInMemory  => 0,
        CacheInBackend => 1,
    );
    return @{$Cache} if $Cache;

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # ask the database
    return if !$DBObject->Prepare(
        SQL => 'SELECT id FROM scheduler_task WHERE lock_key = 0 ORDER BY id ASC',
    );

    # fetch the result
    my @List;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        push @List, $Row[0]
    }

    # set cache
    $CacheObject->Set(
        Type           => 'SchedulerDB',
        Key            => 'TaskListUnlocked',
        TTL            => 10,
        Value          => \@List,
        CacheInMemory  => 0,
        CacheInBackend => 1,
    );

    return @List;
}
</pre></div>

<p>get a list of unlocked tasks</p>

<pre>    my @TaskList = $SchedulerDBObject-&gt;TaskListUnlocked();
</pre><p>Returns:</p>

<pre>    @TaskList = ( 456, 789, 395 );
</pre><h2 id="TaskLock">TaskLock()</h2>

<p><a href="#" onclick="toggleCode('method_TaskLock');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_TaskLock">
                                        <pre>

sub TaskLock {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Key (qw(TaskID NodeID PID)) {
        if ( !$Param{$Key} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Key!",
            );

            return;
        }
    }

    # create the lock key
    my $LockKeyNodeID = sprintf "%03d", $Param{NodeID};
    my $LockKeyPID    = sprintf "%08d", $Param{PID};
    my $LockKey       = '1' . $LockKeyNodeID . $LockKeyPID;

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # get locked task
    return if !$DBObject->Prepare(
        SQL  => 'SELECT lock_key FROM scheduler_task WHERE id = ?',
        Bind => [ \$Param{TaskID} ],
    );

    # fetch the result
    my $LockKeyFromDBBefore = '';
    while ( my @Data = $DBObject->FetchrowArray() ) {
        $LockKeyFromDBBefore = $Data[0] || '';
    }

    return 1 if $LockKeyFromDBBefore eq $LockKey;

    # lock the task in database
    return if !$DBObject->Do(
        SQL => '
            UPDATE scheduler_task
            SET lock_key = ?, lock_time = current_timestamp, lock_update_time = current_timestamp
            WHERE lock_key = 0 AND id = ?',
        Bind => [
            \$LockKey,
            \$Param{TaskID},
        ],
    );

    # get locked task
    return if !$DBObject->Prepare(
        SQL  => 'SELECT lock_key, attempts FROM scheduler_task WHERE id = ?',
        Bind => [ \$Param{TaskID} ],
    );

    # fetch the result
    my $LockKeyFromDB = '';
    my $Attempts      = 0;
    while ( my @Data = $DBObject->FetchrowArray() ) {
        $LockKeyFromDB = $Data[0];
        $Attempts      = $Data[1];
    }

    return if $LockKeyFromDB ne $LockKey;

    # remove task if attempts is 0
    if ( !$Attempts ) {
        $Self->TaskDelete(
            TaskID => $Param{TaskID},
        );

        return;
    }
    else {

        $Attempts--;

        # decrement number of attempts
        $DBObject->Do(
            SQL => '
                UPDATE scheduler_task
                SET attempts = ?
                WHERE lock_key = ? AND id = ?',
            Bind => [
                \$Attempts,
                \$LockKey,
                \$Param{TaskID},
            ],
        );
    }

    # delete list cache
    $Kernel::OM->Get('Kernel::System::Cache')->Delete(
        Type => 'SchedulerDB',
        Key  => 'TaskListUnlocked',
    );

    return 1;
}
</pre></div>

<p>locks task to a specific PID</p>

<pre>    my $Success = $SchedulerDBObject-&gt;TaskLock(
        TaskID =&gt; 123,
        NodeID =&gt; 1,    # the id on the node in a cluster environment
        PID    =&gt; 456,  # the process ID of the worker that is locking the task
    );
</pre><h2 id="TaskCleanup">TaskCleanup()</h2>

<p><a href="#" onclick="toggleCode('method_TaskCleanup');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_TaskCleanup">
                                        <pre>

sub TaskCleanup {
    my ( $Self, %Param ) = @_;

    my @List = $Self->TaskList();

    # get time object
    my $TimeObject = $Kernel::OM->Get('Kernel::System::Time');

    TASKITEM:
    for my $TaskItem (@List) {

        my %Task = $Self->TaskGet(
            TaskID => $TaskItem->{TaskID},
        );

        # skip if task does not have a lock key
        next TASKITEM if !$Task{LockKey};

        # skip if the lock key is invalid
        next TASKITEM if $Task{LockKey} < 1;

        # get system time
        my $SystemTime = $TimeObject->SystemTime();

        # get expiration time. 7 days ago system time
        my $ExpiredTime = $SystemTime - ( 60 * 60 * 24 * 7 );

        my $LockTime = $TimeObject->TimeStamp2SystemTime(
            String => $Task{LockTime},
        );

        # skip if task is not expired
        next TASKITEM if $LockTime > $ExpiredTime;

        my $Success = $Self->TaskDelete(
            TaskID => $Task{TaskID},
        );

        if ( !$Success ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Could not delete task $Task{Name}-$Task{Type} ($Task{TaskID})\n",
            );
        }
    }

    return 1;
}
</pre></div>

<p>deletes obsolete worker tasks</p>

<pre>    my $Success = $SchedulerDBObject-&gt;TaskCleanup();
</pre><h2 id="TaskSummary">TaskSummary()</h2>

<p><a href="#" onclick="toggleCode('method_TaskSummary');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_TaskSummary">
                                        <pre>

sub TaskSummary {
    my ( $Self, %Param ) = @_;

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # ask the database
    return () if !$DBObject->Prepare(
        SQL => '
            SELECT id, name, task_type, lock_key, lock_time, create_time
            FROM scheduler_task
            ORDER BY id ASC',
    );

    # fetch the result
    my @List;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        push @List, {
            Name       => $Row[1],
            Type       => $Row[2],
            LockKey    => $Row[3] // 0,
            LockTime   => $Row[4] // '',
            CreateTime => $Row[5],
        };
    }

    my @HandledTasks;
    my @UnhandledTasks;

    # get time object
    my $TimeObject = $Kernel::OM->Get('Kernel::System::Time');

    my $SystemTime = $TimeObject->SystemTime();

    TASK:
    for my $Task (@List) {

        # check if the task is unlocked or lock key is not valid (unhandled tasks)
        if ( $Task->{LockKey} < 1 ) {
            push @UnhandledTasks, {
                Name       => $Task->{Name},
                Type       => $Task->{Type},
                CreateTime => $Task->{CreateTime},
            };
        }
        else {

            # extract the NodeID and ProcessID from the lock key
            my ( $NodeID, $ProcessID ) = $Task->{LockKey} =~ m{\A 1 (\d{3}) (\d{8}) \z}msx;

            # calculate duration from lock time
            my $CurrentDuration;
            if ( defined $Task->{LockTime} ) {
                my $LockSystemTime = $TimeObject->TimeStamp2SystemTime(
                    String => $Task->{LockTime},
                );
                $CurrentDuration = $Self->_Seconds2String( $SystemTime - $LockSystemTime );
            }

            push @HandledTasks, {
                Name            => $Task->{Name},
                Type            => $Task->{Type},
                NodeID          => $NodeID,
                ProcessID       => $ProcessID,
                LockTime        => $Task->{LockTime},
                CreateTime      => $Task->{CreateTime},
                CurrentDuration => $CurrentDuration
            };
        }
    }

    return (
        {
            Header => 'Unhandled Worker Tasks:',
            Column => [
                {
                    Name        => 'Name',
                    DisplayName => 'Name',
                    Size        => 40,
                },
                {
                    Name        => 'Type',
                    DisplayName => 'Type',
                    Size        => 20,
                },
                {
                    Name        => 'CreateTime',
                    DisplayName => 'Create Time',
                    Size        => 20,
                },
            ],
            Data           => \@UnhandledTasks,
            NoDataMesssage => 'There are currently no tasks waiting to be executed',
        },
        {
            Header => 'Handled Worker Tasks:',
            Column => [
                {
                    Name        => 'Name',
                    DisplayName => 'Name',
                    Size        => 40,
                },
                {
                    Name        => 'Type',
                    DisplayName => 'Type',
                    Size        => 20,
                },
                {
                    Name        => 'NodeID',
                    DisplayName => 'NID',
                    Size        => 4,
                },
                {
                    Name        => 'ProcessID',
                    DisplayName => 'PID',
                    Size        => 9,
                },
                {
                    Name        => 'CurrentDuration',
                    DisplayName => 'Duration',
                    Size        => 20,
                },
            ],
            Data           => \@HandledTasks,
            NoDataMesssage => 'There are currently no tasks been executing',
        },
    );
}
</pre></div>

<p>get a summary of the tasks from the worker task table divided into handled and unhandled</p>

<pre>    my @Summary = $SchedulerDBObject-&gt;TaskSummary();
</pre><h2 id="TaskLockUpdate">TaskLockUpdate()</h2>

<p><a href="#" onclick="toggleCode('method_TaskLockUpdate');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_TaskLockUpdate">
                                        <pre>

sub TaskLockUpdate {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !IsArrayRefWithData( $Param{TaskIDs} ) ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "TaskIDs is missing or invalid!",
        );

        return;
    }

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    my $TaskIDs = join ',', map { $DBObject->Quote( $_, 'Integer' ) } @{ $Param{TaskIDs} };

    return 1 if !$TaskIDs;

    # set lock update time in database
    return if !$DBObject->Do(
        SQL => "
            UPDATE scheduler_task
            SET lock_update_time = current_timestamp
            WHERE id IN ( $TaskIDs )",
    );

    return 1;
}
</pre></div>

<p>sets the task lock update time as current time for the specified tasks</p>

<pre>    my $Success = $SchedulerDBObject-&gt;TaskLockUpdate(
        TaskIDs =&gt; [123, 456],
    );
</pre><h2 id="TaskUnlockExpired">TaskUnlockExpired()</h2>

<p><a href="#" onclick="toggleCode('method_TaskUnlockExpired');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_TaskUnlockExpired">
                                        <pre>

sub TaskUnlockExpired {
    my ( $Self, %Param ) = @_;

    # get needed objects
    my $DBObject   = $Kernel::OM->Get('Kernel::System::DB');
    my $TimeObject = $Kernel::OM->Get('Kernel::System::Time');

    # ask the database (get all worker tasks with a lock key different than 0)
    return if !$DBObject->Prepare(
        SQL => '
            SELECT id, name, lock_update_time
            FROM scheduler_task
            WHERE lock_key <> 0
                AND lock_key <> 1
            ORDER BY id ASC',
    );

    # fetch the result
    my @List;
    ROW:
    while ( my @Row = $DBObject->FetchrowArray() ) {

        # convert lock update time stamp to a system time
        my $LockUpdateTime = 0;

        if ( $Row[2] ) {
            $LockUpdateTime = $TimeObject->TimeStamp2SystemTime(
                String => $Row[2],
            );
        }
        else {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Lock Update Time missing for task $Row[1]! ($Row[0])",
            );
        }

        # get current system time
        my $SystemTime = $TimeObject->SystemTime();

        # skip task if it has been locked update time is in within the last 5 minutes
        next ROW if $SystemTime - $LockUpdateTime < ( 60 * 5 );

        push @List, {
            TaskID   => $Row[0],
            Name     => $Row[1],
            LockTime => $Row[2],
        };
    }

    # stop if there are no tasks to unlock
    return 1 if !@List;

    for my $Task (@List) {

        # unlock all the task that has been locked for more than 1 minute
        return if !$Kernel::OM->Get('Kernel::System::DB')->Do(
            SQL => '
                UPDATE scheduler_task
                SET lock_key = 0, lock_time = NULL, lock_update_time = NULL
                WHERE id = ?',
            Bind => [ \$Task->{TaskID}, ],
        );
    }

    return 1;
}
</pre></div>

<p>remove lock status for working tasks that has not been updated its lock update time for more than 5 minutes</p>

<pre>    my $Success = $SchedulerDBObject-&gt;TaskUnlockExpired();
</pre><h2 id="FutureTaskAdd">FutureTaskAdd()</h2>

<p><a href="#" onclick="toggleCode('method_FutureTaskAdd');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_FutureTaskAdd">
                                        <pre>

sub FutureTaskAdd {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Key (qw(ExecutionTime Type Data)) {
        if ( !$Param{$Key} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Key!",
            );

            return;
        }
    }

    # check valid ExecutionTime
    my $SystemTime = $Kernel::OM->Get('Kernel::System::Time')->TimeStamp2SystemTime(
        String => $Param{ExecutionTime},
    );

    if ( !$SystemTime ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "ExecutionTime is invalid!",
        );

        return;
    }

    if ( $Param{MaximumParallelInstances} && $Param{MaximumParallelInstances} =~ m{\A \d+ \z}msx ) {

        # get the list of all future tasks for the specified task type
        my @List = $Self->FutureTaskList(
            Type => $Param{Type},
        );

        my @FilteredList = @List;
        if ( $Param{Name} && @List ) {

            # remove all tasks that does not match specified task name
            @FilteredList = grep { ( $_->{Name} || '' ) eq $Param{Name} } @List;
        }

        # compare the number of task with the maximum parallel limit
        return -1 if scalar @FilteredList >= $Param{MaximumParallelInstances}
    }

    # set default of attempts parameter
    $Param{Attempts} ||= 1;

    # serialize data as string
    my $Data = $Kernel::OM->Get('Kernel::System::Storable')->Serialize(
        Data => $Param{Data},
    );

    # encode task data
    $Kernel::OM->Get('Kernel::System::Encode')->EncodeOutput($Data);
    $Data = encode_base64($Data);

    # get needed objects
    my $DBObject   = $Kernel::OM->Get('Kernel::System::DB');
    my $TimeObject = $Kernel::OM->Get('Kernel::System::Time');

    my $Identifier;
    TRY:
    for my $Try ( 1 .. 10 ) {

        # calculate a task identifier
        $Identifier = $TimeObject->SystemTime() . int rand 1000000;

        # insert the future task (initially locked with lock_key = 1 so it will not be taken by any
        #    moved into worker task list at this moment)
        last TRY if $DBObject->Do(
            SQL => '
                INSERT INTO scheduler_future_task
                    (ident, execution_time, name, task_type, task_data, attempts, lock_key, create_time)
                VALUES
                    (?, ?, ?, ?, ?, ?, 1, current_timestamp)',
            Bind => [
                \$Identifier,
                \$Param{ExecutionTime},
                \$Param{Name},
                \$Param{Type},
                \$Data,
                \$Param{Attempts},
            ],
        );
    }

    # get task id
    $DBObject->Prepare(
        SQL  => 'SELECT id FROM scheduler_future_task WHERE ident = ?',
        Bind => [ \$Identifier ],
    );

    # fetch the task id
    my $TaskID;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        $TaskID = $Row[0];
    }

    # unlock the task, for now on the task can be moved to the worker task list
    $DBObject->Do(
        SQL => '
            UPDATE scheduler_future_task
            SET lock_key = 0
            WHERE lock_key = 1 AND id = ?',
        Bind => [
            \$TaskID,
        ],
    );

    # delete future task list cache
    $Kernel::OM->Get('Kernel::System::Cache')->Delete(
        Type => 'SchedulerDB',
        Key  => 'FutureTaskListUnlocked',    # TODO FIXME
    );

    return $TaskID;
}
</pre></div>

<p>add a new task to scheduler future task list</p>

<pre>    my $TaskID = $SchedulerDBObject-&gt;FutureTaskAdd(
        ExecutionTime            =&gt; '2015-01-01 00:00:00',
        Type                     =&gt; 'GenericInterface',  # e. g. GenericInterface, Test
        Name                     =&gt; 'any name',          # optional
        Attempts                 =&gt; 5,                   # optional (default 1)
        MaximumParallelInstances =&gt; 2,                   # optional (default 0), number of tasks
                                                         #   with the same type (and name if provided)
                                                         #   that can exists at the same time,
                                                         #   value of 0 means unlimited
        Data =&gt; {                                        # data payload
            ...
        },
    );
</pre><p>Returns:</p>

<pre>    my $TaskID = 123;  # or false in case of an error
</pre><h2 id="FutureTaskGet">FutureTaskGet()</h2>

<p><a href="#" onclick="toggleCode('method_FutureTaskGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_FutureTaskGet">
                                        <pre>

sub FutureTaskGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{TaskID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need TaskID!',
        );
        return;
    }

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # get task from database
    return if !$DBObject->Prepare(
        SQL =>
            'SELECT execution_time, name, task_type, task_data, attempts, lock_key, lock_time, create_time
            FROM scheduler_future_task
            WHERE id = ?',
        Bind => [ \$Param{TaskID} ],
    );

    # get storable object
    my $StorableObject = $Kernel::OM->Get('Kernel::System::Storable');

    my %Task;
    while ( my @Data = $DBObject->FetchrowArray() ) {

        # decode task data
        my $DecodedData = decode_base64( $Data[3] );

        # deserialize data
        my $DataParam = $StorableObject->Deserialize( Data => $DecodedData );

        if ( !$DataParam ) {

            # error log
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => 'Future task data is not in a correct storable format! TaskID: ' . $Param{TaskID},
            );

            # remove damaged future task
            $Self->FutureTaskDelete(
                TaskID => $Param{TaskID},
            );

            return;
        }

        %Task = (
            TaskID        => $Param{TaskID},
            ExecutionTime => $Data[0],
            Name          => $Data[1],
            Type          => $Data[2],
            Data          => $DataParam || {},
            Attempts      => $Data[4],
            LockKey       => $Data[5] // 0,
            LockTime      => $Data[6] // '',
            CreateTime    => $Data[7],
        );
    }

    return %Task;
}
</pre></div>

<p>get scheduler future task</p>

<pre>    my %Task = $SchedulerDBObject-&gt;FutureTaskGet(
        TaskID =&gt; 123,
    );
</pre><p>Returns:</p>

<pre>    %Task = (
        TaskID        =&gt; 123,
        ExecutionTime =&gt; '2015-01-01 00:00:00',
        Name          =&gt; 'any name',
        Type          =&gt; 'GenericInterface',
        Data          =&gt; $DataRef,
        Attempts      =&gt; 10,
        LockKey       =&gt; 'XYZ',
        LockTime      =&gt; '2011-02-08 15:08:01',
        CreateTime    =&gt; '2011-02-08 15:08:00',
    );
</pre><h2 id="FutureTaskDelete">FutureTaskDelete()</h2>

<p><a href="#" onclick="toggleCode('method_FutureTaskDelete');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_FutureTaskDelete">
                                        <pre>

sub FutureTaskDelete {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{TaskID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need TaskID!',
        );
        return;
    }

    # delete task from the future list
    $Kernel::OM->Get('Kernel::System::DB')->Do(
        SQL  => 'DELETE FROM scheduler_future_task WHERE id = ?',
        Bind => [ \$Param{TaskID} ],
    );

    # delete future task list cache
    $Kernel::OM->Get('Kernel::System::Cache')->Delete(
        Type => 'SchedulerDB',
        Key  => 'FutureTaskListUnlocked',    # TODO FIXME
    );

    return 1;
}
</pre></div>

<p>delete a task from scheduler future task list</p>

<pre>    my $Success = $SchedulerDBObject-&gt;FutureTaskDelete(
        TaskID =&gt; 123,
    );
</pre><h2 id="FutureTaskList">FutureTaskList()</h2>

<p><a href="#" onclick="toggleCode('method_FutureTaskList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_FutureTaskList">
                                        <pre>

sub FutureTaskList {
    my ( $Self, %Param ) = @_;

    my $SQL = 'SELECT id, execution_time, name, task_type FROM scheduler_future_task';
    my @Bind;

    # add type
    if ( $Param{Type} ) {
        $SQL .= ' WHERE task_type = ?';
        @Bind = ( \$Param{Type} );
    }

    $SQL .= ' ORDER BY id ASC';

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # ask the database
    return if !$DBObject->Prepare(
        SQL  => $SQL,
        Bind => \@Bind,
    );

    # fetch the result
    my @List;
    while ( my @Row = $DBObject->FetchrowArray() ) {

        push @List, {
            TaskID        => $Row[0],
            ExecutionTime => $Row[1],
            Name          => $Row[2],
            Type          => $Row[3],
        };
    }

    return @List;
}
</pre></div>

<p>get the list of scheduler future tasks</p>

<pre>    my @List = $SchedulerDBObject-&gt;FutureTaskList(
        Type =&gt; 'some type',  # optional
    );
</pre><p>Returns:</p>

<pre>    @List = (
        {
            TaskID        =&gt; 123,
            ExecutionTime =&gt; '2015-01-01 00:00:00',
            Name          =&gt; 'any name',
            Type          =&gt; 'GenericInterface',
        },
        {
            TaskID        =&gt; 456,
            ExecutionTime =&gt; '2015-01-01 00:00:00',
            Name          =&gt; 'any other name',
            Type          =&gt; 'GenericInterface',
        },
        # ...
    );
</pre><h2 id="FutureTaskToExecute">FutureTaskToExecute()</h2>

<p><a href="#" onclick="toggleCode('method_FutureTaskToExecute');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_FutureTaskToExecute">
                                        <pre>

sub FutureTaskToExecute {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Key (qw(NodeID PID)) {
        if ( !$Param{$Key} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Key!",
            );

            return;
        }
    }

    # create the lock key
    my $LockKeyNodeID = sprintf "%03d", $Param{NodeID};
    my $LockKeyPID    = sprintf "%08d", $Param{PID};
    my $LockKey       = '1' . $LockKeyNodeID . $LockKeyPID;

    # get needed objects
    my $DBObject   = $Kernel::OM->Get('Kernel::System::DB');
    my $TimeObject = $Kernel::OM->Get('Kernel::System::Time');

    # get current time
    my $CurrentTime = $TimeObject->CurrentTimestamp();

    # lock the task in database
    return if !$DBObject->Do(
        SQL => '
            UPDATE scheduler_future_task
            SET lock_key = ?, lock_time = current_timestamp
            WHERE lock_key = 0 AND execution_time <= ?',
        Bind => [
            \$LockKey,
            \$CurrentTime,
        ],
    );

    # get all locked future tasks
    return if !$DBObject->Prepare(
        SQL => '
            SELECT id, name, task_type, task_data, attempts
            FROM scheduler_future_task
            WHERE lock_key = ?
            ORDER BY execution_time ASC',
        Bind => [ \$LockKey ],
    );

    # get storable object
    my $StorableObject = $Kernel::OM->Get('Kernel::System::Storable');

    # fetch the result
    my @FutureTaskList;
    while ( my @Row = $DBObject->FetchrowArray() ) {

        # decode task data
        my $DecodedData = decode_base64( $Row[3] );

        # deserialize data
        my $DataParam = $StorableObject->Deserialize( Data => $DecodedData );

        if ( !$DataParam ) {

            # error log
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => 'Future task data is not in a correct storable format! TaskID: ' . $Param{TaskID},
            );

            # remove damaged future task
            $Self->FutureTaskDelete(
                TaskID => $Param{TaskID},
            );

            return;
        }

        my %Task = (
            TaskID   => $Row[0],
            Name     => $Row[1],
            Type     => $Row[2],
            Data     => $DataParam || {},
            Attempts => $Row[4],
        );

        push @FutureTaskList, \%Task;
    }

    # move tasks to the execution task list
    for my $FutureTask (@FutureTaskList) {

        my %Task = %{$FutureTask};

        delete $Task{TaskID};

        # add task to the list
        $Self->TaskAdd(%Task);

        # remove future task
        $Self->FutureTaskDelete(
            TaskID => $FutureTask->{TaskID},
        );
    }

    return 1;
}
</pre></div>

<p>moves all future tasks with reached execution time to the task table to execute</p>

<pre>    my $Success = $SchedulerDBObject-&gt;FutureTaskToExecute(
        NodeID =&gt; 1,    # the ID of the node in a cluster environment
        PID    =&gt; 456,  # the process ID of the daemon that is moving the tasks to execution
    );
</pre><h2 id="FutureTaskSummary">FutureTaskSummary()</h2>

<p><a href="#" onclick="toggleCode('method_FutureTaskSummary');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_FutureTaskSummary">
                                        <pre>

sub FutureTaskSummary {
    my ( $Self, %Param ) = @_;

    my @List = $Self->FutureTaskList();

    return (
        {
            Header => 'Tasks to be executed in future:',
            Column => [
                {
                    Name        => 'Name',
                    DisplayName => 'Name',
                    Size        => 40,
                },
                {
                    Name        => 'Type',
                    DisplayName => 'Type',
                    Size        => 20,
                },
                {
                    Name        => 'ExecutionTime',
                    DisplayName => 'To Execute At',
                    Size        => 20,
                },
            ],
            Data           => \@List,
            NoDataMesssage => 'There are currently no tasks to be executed in future',
        },
    );
}
</pre></div>

<p>get a summary of the tasks from the future task table</p>

<pre>    my @Summary = $SchedulerDBObject-&gt;FutureTaskSummary();
</pre><h2 id="CronTaskToExecute">CronTaskToExecute()</h2>

<p><a href="#" onclick="toggleCode('method_CronTaskToExecute');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_CronTaskToExecute">
                                        <pre>

sub CronTaskToExecute {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Key (qw(NodeID PID)) {
        if ( !$Param{$Key} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Key!",
            );

            return;
        }
    }

    # get cron config
    my $Config = $Kernel::OM->Get('Kernel::Config')->Get('Daemon::SchedulerCronTaskManager::Task') || {};

    # do noting if there are no cron tasks definitions in SysConfig
    return 1 if !IsHashRefWithData($Config);

    # get needed objects
    my $TimeObject      = $Kernel::OM->Get('Kernel::System::Time');
    my $CronEventObject = $Kernel::OM->Get('Kernel::System::CronEvent');

    # get current time
    my $SystemTime = $TimeObject->SystemTime();

    CRONJOBKEY:
    for my $CronjobKey ( sort keys %{$Config} ) {

        next CRONJOBKEY if !$CronjobKey;

        # extract config
        my $JobConfig = $Config->{$CronjobKey};

        next CRONJOBKEY if !IsHashRefWithData($JobConfig);

        if ( !$JobConfig->{Module} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Config option Daemon::SchedulerCronTaskManager::Task###$CronjobKey is invalid."
                    . " Need 'Module' parameter!",
            );
            next CRONJOBKEY;
        }

        if ( $JobConfig->{Module} && !$JobConfig->{Function} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Config option Daemon::SchedulerCronTaskManager::Task###$CronjobKey is invalid."
                    . " Need 'Function' parameter!",
            );
            next CRONJOBKEY;
        }

        # calculate last cron time
        my $PreviousEventTimestamp = $CronEventObject->PreviousEventGet(
            Schedule => $JobConfig->{Schedule},
        );

        next CRONJOBKEY if !$PreviousEventTimestamp;

        # execute recurrent tasks
        $Self->RecurrentTaskExecute(
            NodeID                   => $Param{NodeID},
            PID                      => $Param{PID},
            TaskName                 => $JobConfig->{TaskName},
            TaskType                 => 'Cron',
            PreviousEventTimestamp   => $PreviousEventTimestamp,
            MaximumParallelInstances => $JobConfig->{MaximumParallelInstances},
            Data                     => {
                Module   => $JobConfig->{Module}   || '',
                Function => $JobConfig->{Function} || '',
                Params   => $JobConfig->{Params}   || '',
            },
        );
    }

    return 1;
}
</pre></div>

<p>creates cron tasks that needs to be run in the current time into the task table to execute</p>

<pre>    my $Success = $SchedulerDBObject-&gt;CronTaskToExecute(
        NodeID =&gt; 1,    # the ID of the node in a cluster environment
        PID    =&gt; 456,  # the process ID of the daemon that is creating the tasks to execution
    );
</pre><h2 id="CronTaskCleanup">CronTaskCleanup()</h2>

<p><a href="#" onclick="toggleCode('method_CronTaskCleanup');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_CronTaskCleanup">
                                        <pre>

sub CronTaskCleanup {
    my ( $Self, %Param ) = @_;

    # get cron config
    my $Config = $Kernel::OM->Get('Kernel::Config')->Get('Daemon::SchedulerCronTaskManager::Task') || {};

    # do noting if there are no cron tasks definitions in SysConfig
    return 1 if !IsHashRefWithData($Config);

    # get needed objects
    my $TimeObject      = $Kernel::OM->Get('Kernel::System::Time');
    my $CronEventObject = $Kernel::OM->Get('Kernel::System::CronEvent');

    my %CronJobLookup;

    CRONJOBKEY:
    for my $CronjobKey ( sort keys %{$Config} ) {

        next CRONJOBKEY if !$CronjobKey;

        # extract config
        my $JobConfig = $Config->{$CronjobKey};

        next CRONJOBKEY if !IsHashRefWithData($JobConfig);

        next CRONJOBKEY if ( !$JobConfig->{Module} );

        next CRONJOBKEY if ( $JobConfig->{Module} && !$JobConfig->{Function} );

        # calculate last cron time
        my $PreviousEventTimestamp = $CronEventObject->PreviousEventGet(
            Schedule => $JobConfig->{Schedule},
        );

        next CRONJOBKEY if !$PreviousEventTimestamp;

        $CronJobLookup{ $JobConfig->{TaskName} } = 1;
    }

    # get a list of all generic agent recurrent tasks
    my @TaskList = $Self->RecurrentTaskList(
        Type => 'Cron',
    );

    TASK:
    for my $Task (@TaskList) {

        # skip if task has an active generic agent job in the DB
        next TASK if $CronJobLookup{ $Task->{Name} };

        my $Success = $Self->RecurrentTaskDelete(
            TaskID => $Task->{TaskID},
        );

        if ( !$Success ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Task $Task->{Name}-$Task->{Type} ($Task->{TaskID}) could not be deleted!",
            );
        }
    }

    return 1;
}
</pre></div>

<p>removes recurrent tasks that does not have a matching a cron tasks definition in SysConfig</p>

<pre>    my $Success = $SchedulerDBObject-&gt;CronTaskCleanup();
</pre><h2 id="CronTaskSummary">CronTaskSummary()</h2>

<p><a href="#" onclick="toggleCode('method_CronTaskSummary');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_CronTaskSummary">
                                        <pre>

sub CronTaskSummary {
    my ( $Self, %Param ) = @_;

    # get cron jobs from the SysConfig
    my $Config = $Kernel::OM->Get('Kernel::Config')->Get('Daemon::SchedulerCronTaskManager::Task') || {};

    my %TaskLookup;

    JOBNAME:
    for my $JobName ( sort keys %{$Config} ) {

        my $JobConfig = $Config->{$JobName};

        next JOBNAME if !$JobConfig;
        next JOBNAME if !$JobConfig->{Schedule};

        $TaskLookup{$JobName} = $JobConfig->{Schedule};
    }

    return $Self->RecurrentTaskSummary(
        Type        => 'Cron',
        DisplayType => 'cron',
        TaskLookup  => \%TaskLookup,
    );
}
</pre></div>

<p>get a summary of the cron tasks from the recurrent task table</p>

<pre>    my @Summary = $SchedulerDBObject-&gt;CronTaskSummary();
</pre><h2 id="GenericAgentTaskToExecute">GenericAgentTaskToExecute()</h2>

<p><a href="#" onclick="toggleCode('method_GenericAgentTaskToExecute');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_GenericAgentTaskToExecute">
                                        <pre>

sub GenericAgentTaskToExecute {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Key (qw(NodeID PID)) {
        if ( !$Param{$Key} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Key!",
            );

            return;
        }
    }

    # get generic agent object
    my $GenericAgentObject = $Kernel::OM->Get('Kernel::System::GenericAgent');

    # get a list of generic agent jobs
    my %JobList = $GenericAgentObject->JobList();

    # do noting if there are no generic agent jobs
    return 1 if !%JobList;

    # get CRON event objects
    my $CronEventObject = $Kernel::OM->Get('Kernel::System::CronEvent');

    JOBNAME:
    for my $JobName ( sort keys %JobList ) {

        # get job
        my %Job = $GenericAgentObject->JobGet(
            Name => $JobName,
        );

        # skip if job is invalid
        next JOBNAME if !$Job{Valid};

        # get required params
        my $ScheduleCheck = 1;
        for my $Key (qw( ScheduleDays ScheduleMinutes ScheduleHours )) {
            if ( !$Job{$Key} ) {
                $ScheduleCheck = 0;
            }
        }

        # skip if job is not time based
        next JOBNAME if !$ScheduleCheck;

        # get CRON tab for Generic Agent Schedule
        my $Schedule = $CronEventObject->GenericAgentSchedule2CronTab(%Job);

        next JOBNAME if !$Schedule;

        # get the last time the GenericAgent job should be executed, this returns even THIS minute
        my $PreviousEventTimestamp = $CronEventObject->PreviousEventGet(
            Schedule => $Schedule,
        );

        next JOBNAME if !$PreviousEventTimestamp;

        # execute recurrent tasks
        $Self->RecurrentTaskExecute(
            NodeID                   => $Param{NodeID},
            PID                      => $Param{PID},
            TaskName                 => $JobName,
            TaskType                 => 'GenericAgent',
            PreviousEventTimestamp   => $PreviousEventTimestamp,
            MaximumParallelInstances => 1,
            Data                     => \%Job,
        );
    }

    return 1;
}
</pre></div>

<p>creates generic agent tasks that needs to be run in the current time into the task table to execute</p>

<pre>    my $Success = $SchedulerDBObject-&gt;GenericAgentTaskToExecute(
        NodeID =&gt; 1,    # the ID of the node in a cluster environment
        PID    =&gt; 456,  # the process ID of the daemon that is creating the tasks to execution
    );
</pre><h2 id="GenericAgentTaskCleanup">GenericAgentTaskCleanup()</h2>

<p><a href="#" onclick="toggleCode('method_GenericAgentTaskCleanup');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_GenericAgentTaskCleanup">
                                        <pre>

sub GenericAgentTaskCleanup {
    my ( $Self, %Param ) = @_;

    # get generic agent object
    my $GenericAgentObject = $Kernel::OM->Get('Kernel::System::GenericAgent');

    # get a list of generic agent jobs
    my %JobList = $GenericAgentObject->JobList();

    # do noting if there are no generic agent jobs
    return 1 if !%JobList;

    my %GenericAgentJobLookup;

    # get CRON event objects
    my $CronEventObject = $Kernel::OM->Get('Kernel::System::CronEvent');

    JOBNAME:
    for my $JobName ( sort keys %JobList ) {

        # get job
        my %Job = $GenericAgentObject->JobGet(
            Name => $JobName,
        );

        # skip if job is invalid
        next JOBNAME if !$Job{Valid};

        # get required params
        my $ScheduleCheck = 1;
        for my $Key (qw( ScheduleDays ScheduleMinutes ScheduleHours )) {
            if ( !$Job{$Key} ) {
                $ScheduleCheck = 0;
            }
        }

        # skip if job is not time based
        next JOBNAME if !$ScheduleCheck;

        # get CRON tab for Generic Agent Schedule
        my $Schedule = $CronEventObject->GenericAgentSchedule2CronTab(%Job);

        next JOBNAME if !$Schedule;

        $GenericAgentJobLookup{$JobName} = 1;
    }

    # get a list of all generic agent recurrent tasks
    my @TaskList = $Self->RecurrentTaskList(
        Type => 'GenericAgent',
    );

    TASK:
    for my $Task (@TaskList) {

        # skip if task has an active generic agent job in the DB
        next TASK if $GenericAgentJobLookup{ $Task->{Name} };

        my $Success = $Self->RecurrentTaskDelete(
            TaskID => $Task->{TaskID},
        );

        if ( !$Success ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Task $Task->{Name}-$Task->{Type} ($Task->{TaskID}) could not be deleted!",
            );
        }
    }

    return 1;
}
</pre></div>

<p>removes recurrent tasks that does not have a matching generic agent job</p>

<pre>    my $Success = $SchedulerDBObject-&gt;GenericAgentTaskCleanup();
</pre><h2 id="GenericAgentTaskSummary">GenericAgentTaskSummary()</h2>

<p><a href="#" onclick="toggleCode('method_GenericAgentTaskSummary');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_GenericAgentTaskSummary">
                                        <pre>

sub GenericAgentTaskSummary {
    my ( $Self, %Param ) = @_;

    # get generic agent object
    my $GenericAgentObject = $Kernel::OM->Get('Kernel::System::GenericAgent');

    # get a list of generic agent jobs from the DB
    my %JobList = $GenericAgentObject->JobList();

    # get cron event object
    my $CronEventObject = $Kernel::OM->Get('Kernel::System::CronEvent');

    my %TaskLookup;

    JOBNAME:
    for my $JobName ( sort keys %JobList ) {

        # get job
        my %JobConfig = $GenericAgentObject->JobGet(
            Name => $JobName,
        );

        next JOBNAME if !%JobConfig;
        next JOBNAME if !$JobConfig{Valid};

        # get required params
        my $ScheduleCheck = 1;
        for my $Key (qw( ScheduleDays ScheduleMinutes ScheduleHours )) {
            if ( !$JobConfig{$Key} ) {
                $ScheduleCheck = 0;
            }
        }

        # skip if job is not time based
        next JOBNAME if !$ScheduleCheck;

        # get CRON tab for Generic Agent Schedule
        my $Schedule = $CronEventObject->GenericAgentSchedule2CronTab(%JobConfig);

        next JOBNAME if !$Schedule;

        $TaskLookup{$JobName} = $Schedule;
    }

    return $Self->RecurrentTaskSummary(
        Type        => 'GenericAgent',
        DisplayType => 'generic agent',
        TaskLookup  => \%TaskLookup,
    );
}
</pre></div>

<p>get a summary of the generic agent tasks from the recurrent task table</p>

<pre>    my @Summary = $SchedulerDBObject-&gt;GenericAgentTaskSummary();
</pre><h2 id="RecurrentTaskGet">RecurrentTaskGet()</h2>

<p><a href="#" onclick="toggleCode('method_RecurrentTaskGet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_RecurrentTaskGet">
                                        <pre>

sub RecurrentTaskGet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{TaskID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need TaskID!',
        );
        return;
    }

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # get task from database
    return if !$DBObject->Prepare(
        SQL => 'SELECT name, task_type, last_execution_time, lock_key, lock_time, create_time, change_time
            FROM scheduler_recurrent_task
            WHERE id = ?',
        Bind => [ \$Param{TaskID} ],
    );

    my %Task;
    while ( my @Data = $DBObject->FetchrowArray() ) {

        %Task = (
            TaskID            => $Param{TaskID},
            Name              => $Data[0],
            Type              => $Data[1],
            LastExecutionTime => $Data[2],
            LockKey           => $Data[3] // 0,
            LockTime          => $Data[4] // '',
            CreateTime        => $Data[5],
            ChangeTime        => $Data[6]
        );
    }

    return %Task;
}
</pre></div>

<p>get scheduler recurrent task</p>

<pre>    my %Task = $SchedulerDBObject-&gt;RecurrentTaskGet(
        TaskID =&gt; 123,
    );
</pre><p>Returns:</p>

<pre>    %Task = (
        TaskID            =&gt; 123,
        Name              =&gt; 'any name',
        Type              =&gt; 'GenericInterface',
        LastExecutionTime =&gt; '2015-01-01 00:00:00',
        LockKey           =&gt; 'XYZ',
        LockTime          =&gt; '2015-01-02 00:00:00'
        CreateTime        =&gt; '2015-01-01 00:00:00'
        ChangeTime        =&gt; '2015-01-02 00:00:00'
    );
</pre><h2 id="RecurrentTaskList">RecurrentTaskList()</h2>

<p><a href="#" onclick="toggleCode('method_RecurrentTaskList');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_RecurrentTaskList">
                                        <pre>

sub RecurrentTaskList {
    my ( $Self, %Param ) = @_;

    my $SQL = '
        SELECT id, name, task_type, last_execution_time, lock_key, lock_time, create_time,
            change_time
        FROM scheduler_recurrent_task';
    my @Bind;

    # add type
    if ( $Param{Type} ) {
        $SQL .= ' WHERE task_type = ?';
        @Bind = ( \$Param{Type} );
    }

    $SQL .= ' ORDER BY id ASC';

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # ask the database
    return if !$DBObject->Prepare(
        SQL  => $SQL,
        Bind => \@Bind,
    );

    # fetch the result
    my @List;
    while ( my @Row = $DBObject->FetchrowArray() ) {

        push @List, {
            TaskID            => $Row[0],
            Name              => $Row[1],
            Type              => $Row[2],
            LastExecutionTime => $Row[3],
            LockKey           => $Row[4] // 0,
            LockTime          => $Row[5] // '',
            CreateTime        => $Row[6],
            ChangeTime        => $Row[7],
        };
    }

    return @List;
}
</pre></div>

<p>get the list of scheduler recurrent tasks</p>

<pre>    my @List = $SchedulerDBObject-&gt;RecurrentTaskList(
        Type =&gt; 'some type',  # optional
    );
</pre><p>Returns:</p>

<pre>    @List = (
        {
            TaskID            =&gt; 123,
            Name              =&gt; 'any name',
            Type              =&gt; 'GenericInterface',
            LastExecutionTime =&gt; '2015-01-01 00:00:00',
            LockKey           =&gt; 'XYZ',
            LockTime          =&gt; '2015-01-02 00:00:00'
            CreateTime        =&gt; '2015-01-01 00:00:00'
            ChangeTime        =&gt; '2015-01-02 00:00:00'
        },
        {
            TaskID            =&gt; 456,
            Name              =&gt; 'any other name',
            Type              =&gt; 'GenericInterface',
            LastExecutionTime =&gt; '2015-01-01 00:00:00',
            LockKey           =&gt; 'XYZ',
            LockTime          =&gt; '2015-01-02 00:00:00'
            CreateTime        =&gt; '2015-01-01 00:00:00'
            ChangeTime        =&gt; '2015-01-02 00:00:00'
        },
        # ...
    );
</pre><h2 id="RecurrentTaskDelete">RecurrentTaskDelete()</h2>

<p><a href="#" onclick="toggleCode('method_RecurrentTaskDelete');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_RecurrentTaskDelete">
                                        <pre>

sub RecurrentTaskDelete {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{TaskID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need TaskID!',
        );
        return;
    }

    # get task to delete cache
    my %Task = $Self->RecurrentTaskGet(
        TaskID => $Param{TaskID},
    );

    # delete task from the recurrent task list
    $Kernel::OM->Get('Kernel::System::DB')->Do(
        SQL  => 'DELETE FROM scheduler_recurrent_task WHERE id = ?',
        Bind => [ \$Param{TaskID} ],
    );

    # delete cache if task exits before the delete
    if (%Task) {

        my $CacheKey = "$Task{Name}::$Task{Type}";

        $Kernel::OM->Get('Kernel::System::Cache')->Delete(
            Type => 'SchedulerDBRecurrentTaskExecute',
            Key  => '$CacheKey',
        );
    }

    return 1;
}
</pre></div>

<p>delete a task from scheduler recurrent task list</p>

<pre>    my $Success = $SchedulerDBObject-&gt;RecurrentTaskDelete(
        TaskID =&gt; 123,
    );
</pre><h2 id="RecurrentTaskExecute">RecurrentTaskExecute()</h2>

<p><a href="#" onclick="toggleCode('method_RecurrentTaskExecute');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_RecurrentTaskExecute">
                                        <pre>

sub RecurrentTaskExecute {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Key (qw(NodeID PID TaskName TaskType PreviousEventTimestamp Data)) {
        if ( !$Param{$Key} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Key!",
            );

            return;
        }
    }

    # get cache object
    my $CacheObject = $Kernel::OM->Get('Kernel::System::Cache');

    my $CacheKey = "$Param{TaskName}::$Param{TaskType}";

    # read cache
    my $Cache = $CacheObject->Get(
        Type           => 'SchedulerDBRecurrentTaskExecute',
        Key            => $CacheKey,
        CacheInMemory  => 0,
        CacheInBackend => 1,
    );

    return 1 if $Cache && $Cache eq $Param{PreviousEventTimestamp};

    # get needed objects
    my $DBObject   = $Kernel::OM->Get('Kernel::System::DB');
    my $TimeObject = $Kernel::OM->Get('Kernel::System::Time');

    my $LastExecutionTimeStamp;

    # get entry id and last execution time from database
    my $EntryID;
    TRY:
    for my $Try ( 1 .. 10 ) {

        # insert entry if not exists
        if ( $Try ne 1 ) {

            return if !$DBObject->Do(
                SQL => "
                    INSERT INTO scheduler_recurrent_task
                        (name, task_type, last_execution_time, lock_key, create_time, change_time)
                    VALUES
                        (?, ?, ?, 0, current_timestamp, current_timestamp)",
                Bind => [
                    \$Param{TaskName},
                    \$Param{TaskType},
                    \$Param{PreviousEventTimestamp},
                ],
            );
        }

        # get entry id
        next TRY if !$DBObject->Prepare(
            SQL => "
                SELECT id, last_execution_time
                FROM scheduler_recurrent_task
                WHERE task_type = ? AND name = ?",
            Bind => [
                \$Param{TaskType},
                \$Param{TaskName},
            ],
        );

        # fetch the entry id
        while ( my @Row = $DBObject->FetchrowArray() ) {
            $EntryID                = $Row[0];
            $LastExecutionTimeStamp = $Row[1];
        }

        last TRY if $EntryID;
    }

    return if !$EntryID;

    if ( $LastExecutionTimeStamp eq $Param{PreviousEventTimestamp} ) {

        # set cache
        $CacheObject->Set(
            Type           => 'SchedulerDBRecurrentTaskExecute',
            Key            => $CacheKey,
            TTL            => 60 * 5,
            Value          => $Param{PreviousEventTimestamp},
            CacheInMemory  => 0,
            CacheInBackend => 1,
        );

        return 1;
    }

    # create the lock key
    my $LockKeyNodeID = sprintf "%03d", $Param{NodeID};
    my $LockKeyPID    = sprintf "%08d", $Param{PID};
    my $LockKey       = '1' . $LockKeyNodeID . $LockKeyPID;

    # lock the entry in database
    return if !$DBObject->Do(
        SQL => '
            UPDATE scheduler_recurrent_task
            SET lock_key = ?, lock_time = current_timestamp, change_time = current_timestamp
            WHERE lock_key = 0 AND id = ?',
        Bind => [
            \$LockKey,
            \$EntryID,
        ],
    );

    # get locked entry
    $DBObject->Prepare(
        SQL  => 'SELECT lock_key FROM scheduler_recurrent_task WHERE id = ?',
        Bind => [ \$EntryID ],
    );

    # fetch the result
    my $LockKeyFromDB = '';
    while ( my @Data = $DBObject->FetchrowArray() ) {
        $LockKeyFromDB = $Data[0];
    }

    return 1 if $LockKeyFromDB ne $LockKey;

    # set cache
    $CacheObject->Set(
        Type           => 'SchedulerDBRecurrentTaskExecute',
        Key            => $CacheKey,
        TTL            => 60 * 5,
        Value          => $Param{PreviousEventTimestamp},
        CacheInMemory  => 0,
        CacheInBackend => 1,
    );

    # add the task
    my $TaskID = $Self->TaskAdd(
        Type                     => $Param{TaskType},
        Name                     => $Param{TaskName},
        Attempts                 => 1,
        MaximumParallelInstances => $Param{MaximumParallelInstances},
        Data                     => $Param{Data},
    );

    # unlock the task
    if ( IsPositiveInteger($TaskID) ) {
        $DBObject->Do(
            SQL => '
                UPDATE scheduler_recurrent_task
                SET lock_key = 0, lock_time = NULL, last_execution_time = ?, last_worker_task_id = ?,
                    change_time = current_timestamp
                WHERE lock_key = ? AND id = ?',
            Bind => [
                \$Param{PreviousEventTimestamp},
                \$TaskID,
                \$LockKey,
                \$EntryID,
            ],
        );
    }
    else {
        $DBObject->Do(
            SQL => '
                UPDATE scheduler_recurrent_task
                SET lock_key = 0, lock_time = NULL, change_time = current_timestamp
                WHERE lock_key = ? AND id = ?',
            Bind => [
                \$LockKey,
                \$EntryID,
            ],
        );
    }

    return 1 if $TaskID;

    # error handling
    $Kernel::OM->Get('Kernel::System::Log')->Log(
        Priority => 'error',
        Message  => "Could not create new scheduler recurrent task $Param{TaskName}!",
    );

    return;
}
</pre></div>

<p>executes recurrent tasks like cron or generic agent tasks</p>

<pre>    my $Success = $SchedulerDBObject-&gt;RecurrentTaskExecute(
        NodeID                   =&gt; 1,                 # the ID of the node in a cluster environment
        PID                      =&gt; 456,               # the process ID of the daemon that is creating
                                                       #    the tasks to execution
        TaskName                 =&gt; 'UniqueTaskName',
        TaskType                 =&gt; 'Cron',
        PreviousEventTimestamp   =&gt; 1433212343,
        MaximumParallelInstances =&gt; 1,                 # optional (default 0) number of tasks with the
                                                       #    same name and type that can be in execution
                                                       #    table at the same time, value of 0 means
                                                       #    unlimited
        Data                   =&gt; {                    # data payload
            ...
        },
    );
</pre><h2 id="RecurrentTaskSummary">RecurrentTaskSummary()</h2>

<p><a href="#" onclick="toggleCode('method_RecurrentTaskSummary');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_RecurrentTaskSummary">
                                        <pre>

sub RecurrentTaskSummary {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for my $Needed (qw(Type DisplayType TaskLookup)) {
        if ( !$Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $Needed!",
            );

            return ();
        }
    }

    if ( ref $Param{TaskLookup} ne 'HASH' ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "TaskLookup is invalid!",
        );

        return ();
    }

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # ask the database
    return () if !$DBObject->Prepare(
        SQL => '
            SELECT id, name, task_type, last_execution_time, last_worker_status, last_worker_running_time
            FROM scheduler_recurrent_task
            WHERE task_type = ?
            ORDER BY id ASC',
        Bind => [ \$Param{Type} ],
    );

    # get needed objects
    my $TimeObject      = $Kernel::OM->Get('Kernel::System::Time');
    my $CronEventObject = $Kernel::OM->Get('Kernel::System::CronEvent');

    # fetch the result
    my @List;
    ROW:
    while ( my @Row = $DBObject->FetchrowArray() ) {

        # skip tasks that are not registered in the TaskLookup table
        my $Schedule = $Param{TaskLookup}->{ $Row[1] };

        next ROW if !$Schedule;

        # calculate next cron event time
        my $NextExecutionTime = $CronEventObject->NextEventGet(
            Schedule => $Schedule,
        );

        my $LastWorkerStatus;
        if ( defined $Row[4] ) {
            $LastWorkerStatus = $Row[4] ? 'Success' : 'Fail';
        }

        my $LastWorkerRunningTime;
        if ( defined $Row[5] ) {
            $LastWorkerRunningTime = $Self->_Seconds2String( $Row[5] );
        }

        push @List, {
            Name                  => $Row[1],
            Type                  => $Row[2],
            LastExecutionTime     => $Row[3] // '',
            NextExecutionTime     => $NextExecutionTime // '',
            LastWorkerStatus      => $LastWorkerStatus // 'N/A',
            LastWorkerRunningTime => $LastWorkerRunningTime // 'N/A',
        };
    }

    return (
        {
            Header => "Recurrent $Param{DisplayType} tasks:",
            Column => [
                {
                    Name        => 'Name',
                    DisplayName => 'Name',
                    Size        => 40,
                },
                {
                    Name        => 'LastExecutionTime',
                    DisplayName => 'Last Execution',
                    Size        => 20,
                },
                {
                    Name        => 'LastWorkerStatus',
                    DisplayName => 'Last Status',
                    Size        => 12,
                },
                {
                    Name        => 'LastWorkerRunningTime',
                    DisplayName => 'Last Duration',
                    Size        => 18,
                },
                {
                    Name        => 'NextExecutionTime',
                    DisplayName => 'Next Execution',
                    Size        => 20,
                },
            ],
            Data           => \@List,
            NoDataMesssage => "There are currently no $Param{DisplayType} recurring tasks configured",
        },
    );
}
</pre></div>

<p>get a summary of the recurring tasks for the specified task type</p>

<pre>    my @Summary = $SchedulerDBObject-&gt;RecurrentTaskSummary(
        Type         =&gt; 'some_type',
        DisplayType  =&gt; 'some type',
        TaskLookup   =&gt; {                       # only tasks with names in this table will be shown
            TaskName1 =&gt; '* * * * *',           #   the value of the items in this table is a crontab
            TaskName3 =&gt; '*/1 3,4 * * * 0',     #   format schedule
        }
    );
</pre><h2 id="RecurrentTaskWorkerInfoSet">RecurrentTaskWorkerInfoSet()</h2>

<p><a href="#" onclick="toggleCode('method_RecurrentTaskWorkerInfoSet');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_RecurrentTaskWorkerInfoSet">
                                        <pre>

sub RecurrentTaskWorkerInfoSet {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{LastWorkerTaskID} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Need LastWorkerTaskID!",
        );

        return;
    }

    my $LastWorkerStatus = $Param{LastWorkerStatus} ? 1 : 0;
    my $LastWorkerRunningTime = $Param{LastWorkerRunningTime} // 0;

    return if !$Kernel::OM->Get('Kernel::System::DB')->Do(
        SQL => '
            UPDATE scheduler_recurrent_task
            SET last_worker_status = ?, last_worker_running_time = ?, change_time = current_timestamp
            WHERE last_worker_task_id = ?',
        Bind => [
            \$LastWorkerStatus,
            \$LastWorkerRunningTime,
            \$Param{LastWorkerTaskID},
        ],
    );

    return 1;
}
</pre></div>

<p>sets last worker information (success status and running time) to a recurrent task</p>

<pre>    my $Success = $SchedulerDBObject-&gt;RecurrentTaskWorkerInfoSet(
        LastWorkerTaskID      =&gt; 123,        # the task ID from the worker table that is performing the
                                             #      recurring task
        LastWorkerStatis      =&gt; 1,          # optional 1 or 0, defaults to 0, 1 means success
        LastWorkerRunningTime =&gt; 123,        # optional, defaults to 0, the number in seconds a worker took
                                             #      to complete the task
    );
</pre><h2 id="RecurrentTaskUnlockExpired">RecurrentTaskUnlockExpired()</h2>

<p><a href="#" onclick="toggleCode('method_RecurrentTaskUnlockExpired');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_RecurrentTaskUnlockExpired">
                                        <pre>

sub RecurrentTaskUnlockExpired {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    if ( !$Param{Type} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "Need Type",
        );
    }

    # get needed objects
    my $DBObject   = $Kernel::OM->Get('Kernel::System::DB');
    my $TimeObject = $Kernel::OM->Get('Kernel::System::Time');

    # ask the database (get all recurrent tasks for the given type with a lock key different than 0)
    return if !$DBObject->Prepare(
        SQL => '
            SELECT id, name, lock_time
            FROM scheduler_recurrent_task
            WHERE task_type = ?
                AND lock_key <> 0
            ORDER BY id ASC',
        Bind => [ \$Param{Type} ],
    );

    # fetch the result
    my @List;
    ROW:
    while ( my @Row = $DBObject->FetchrowArray() ) {

        # convert lock time stamp to a system time
        my $LockTime = $TimeObject->TimeStamp2SystemTime(
            String => $Row[2],
        ) || 0;

        # get current system time
        my $SystemTime = $TimeObject->SystemTime();

        # skip task if it has been locked within the last minute
        next ROW if $SystemTime - $LockTime < 60;

        push @List, {
            TaskID   => $Row[0],
            Name     => $Row[1],
            LockTime => $Row[2],
        };
    }

    # stop if there are no tasks to unlock
    return 1 if !@List;

    for my $Task (@List) {

        # unlock all the task that has been locked for more than 1 minute
        return if !$Kernel::OM->Get('Kernel::System::DB')->Do(
            SQL => '
                UPDATE scheduler_recurrent_task
                SET lock_key = 0, lock_time = NULL, change_time = current_timestamp
                WHERE id = ?',
            Bind => [ \$Task->{TaskID}, ],
        );
    }

    return 1;
}
</pre></div>

<p>remove lock status for recurring tasks that has been locked for more than 1 minutes</p>

<pre>    my $Success = $SchedulerDBObject-&gt;RecurrentTaskUnlockExpired(
        Type =&gt; 'some_type',
    );
</pre><h1 id="TERMS_AND_CONDITIONS">TERMS AND CONDITIONS <a href="#TOP" class="toplink"><img alt="^" src="../../../up.gif" /></a></h1>

<p>This software is part of the OTRS project (<a href="http://otrs.org/">http://otrs.org/</a>).</p>

<p>This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see <a href="http://www.gnu.org/licenses/agpl.txt">http://www.gnu.org/licenses/agpl.txt</a>.</p>


</div><div class="footer">generated by <a href="http://search.cpan.org/perldoc?Pod%3A%3AProjectDocs">Pod::ProjectDocs</a></div></body>
</html>
