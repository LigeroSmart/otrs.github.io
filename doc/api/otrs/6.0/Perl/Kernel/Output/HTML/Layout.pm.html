<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<!-- otrs.github.io -->
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../../../../../../../documentation.css">
<script src="https://code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../../../../../../documentation.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
<script>
$(document).ready(function() {

    // Hint languages to prevent false matches (php for example).
    hljs.configure({
        languages: ['perl', 'javascript', 'xml', 'html', 'css', 'json', 'yaml']
    });

    // programlistings in manuals
    $('pre.programlisting').each(function(i, block) {
        hljs.highlightBlock(block);
    });
    // code snippets in Perl API docs
    $('.pod pre').addClass('perl').each(function(i, block) {
        hljs.highlightBlock(block);
    });
});</script>
<!-- otrs.github.io -->

	<title>Kernel::Output::HTML::Layout</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <script type="text/javascript">

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  </script></head>
<body>
<div class="box">
  <h1 class="t1">OTRS 6.0 API Reference Perl</h1>
  <table>
    <tr>
      <td class="label">Description</td>
      <td class="cell">manuals and libraries</td>
    </tr>
  </table>
</div>
<div class="path">
  <a href="../../../index.html">OTRS 6.0 API Reference Perl</a> &gt; Perl Modules &gt;
  Kernel::Output::HTML::Layout
</div>
<div>
<a href="../../../src/Kernel/Output/HTML/Layout.pm">Source</a>
</div>
<div class="pod">
<!-- INDEX START -->
<h3 id="TOP">Index</h3>
<ul>
	<li><a href="#NAME">NAME</a></li>
	<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
	<li><a href="#PUBLIC_INTERFACE">PUBLIC INTERFACE</a><br />
<ul>
	<li><a href="#new">new()</a></li>
	<li><a href="#Block">Block()</a></li>
	<li><a href="#JSONEncode">JSONEncode()</a></li>
	<li><a href="#Redirect">Redirect()</a></li>
	<li><a href="#Notify">Notify()</a></li>
	<li><a href="#Header">Header()</a></li>
	<li><a href="#Ascii2Html">Ascii2Html()</a></li>
	<li><a href="#LinkQuote">LinkQuote()</a></li>
	<li><a href="#HTMLLinkQuote">HTMLLinkQuote()</a></li>
	<li><a href="#LinkEncode">LinkEncode()</a></li>
	<li><a href="#BuildSelection">BuildSelection()</a></li>
	<li><a href="#Permission">Permission()</a></li>
	<li><a href="#Attachment">Attachment()</a></li>
	<li><a href="#PageNavBar">PageNavBar()</a></li>
	<li><a href="#BuildDateSelection">BuildDateSelection()</a></li>
	<li><a href="#Ascii2RichText">Ascii2RichText()</a></li>
	<li><a href="#RichText2Ascii">RichText2Ascii()</a></li>
	<li><a href="#RichTextDocumentComplete">RichTextDocumentComplete()</a></li>
	<li><a href="#RichTextDocumentServe">RichTextDocumentServe()</a></li>
	<li><a href="#RichTextDocumentCleanup">RichTextDocumentCleanup()</a></li>
</ul>
</li>
	<li><a href="#TERMS_AND_CONDITIONS">TERMS AND CONDITIONS</a></li>
</ul>
<hr />
<!-- INDEX END -->

<h1 id="NAME">NAME <a href="#TOP" class="toplink"><img alt="^" src="../../../up.gif" /></a></h1>

<p>Kernel::Output::HTML::Layout - all generic html functions</p>

<h1 id="DESCRIPTION">DESCRIPTION <a href="#TOP" class="toplink"><img alt="^" src="../../../up.gif" /></a></h1>

<p>All generic html functions. E. g. to get options fields, template processing, ...</p>

<h1 id="PUBLIC_INTERFACE">PUBLIC INTERFACE <a href="#TOP" class="toplink"><img alt="^" src="../../../up.gif" /></a></h1>

<h2 id="new">new()</h2>

<p><a href="#" onclick="toggleCode('method_new');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_new">
                                        <pre>

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {%Param};
    bless( $Self, $Type );

    # set debug
    $Self->{Debug} = 0;

    # reset block data
    delete $Self->{BlockData};

    # empty action if not defined
    $Self->{Action} = '' if !defined $Self->{Action};

    my $ConfigObject = $Kernel::OM->Get('Kernel::Config');

    # get/set some common params
    if ( !$Self->{UserTheme} ) {
        $Self->{UserTheme} = $ConfigObject->Get('DefaultTheme');
    }

    # We'll keep one default TimeObject and one for the user's time zone (if needed)
    $Self->{TimeObject} = $Kernel::OM->Get('Kernel::System::Time');

    if ( $Self->{UserTimeZone} ) {
        $Self->{UserTimeObject} = Kernel::System::Time->new( %{$Self} );
    }
    else {
        $Self->{UserTimeObject} = $Self->{TimeObject};
        $Self->{UserTimeZone}   = '';
    }

    # Determine the language to use based on the browser setting, if there
    #   is none yet.
    if ( !$Self->{UserLanguage} ) {
        my @BrowserLanguages = split /\s*,\s*/, $Self->{Lang} || $ENV{HTTP_ACCEPT_LANGUAGE} || '';
        my %Data = %{ $ConfigObject->Get('DefaultUsedLanguages') };
        LANGUAGE:
        for my $BrowserLang (@BrowserLanguages) {
            for my $Language ( reverse sort keys %Data ) {

                # check xx_XX and xx-XX type
                my $LanguageOtherType = $Language;
                $LanguageOtherType =~ s/_/-/;
                if ( $BrowserLang =~ /^($Language|$LanguageOtherType)/i ) {
                    $Self->{UserLanguage} = $Language;
                    last LANGUAGE;
                }
            }
            if ( !$Self->{UserLanguage} ) {
                for my $Language ( reverse sort keys %Data ) {

                    # If Browser requests 'vi', also offer 'vi_VI' even though we don't have 'vi'
                    if ( $Language =~ m/^$BrowserLang/smxi ) {
                        $Self->{UserLanguage} = $Language;
                        last LANGUAGE;
                    }
                }
            }
        }
        $Self->{UserLanguage} ||= $ConfigObject->Get('DefaultLanguage') || 'en';
    }

    # create language object
    if ( !$Self->{LanguageObject} ) {
        $Kernel::OM->ObjectParamAdd(
            'Kernel::Language' => {
                UserTimeZone => $Self->{UserTimeZone},
                UserLanguage => $Self->{UserLanguage},
                Action       => $Self->{Action},
            },
        );
        $Self->{LanguageObject} = $Kernel::OM->Get('Kernel::Language');
    }

    # set charset if there is no charset given
    $Self->{UserCharset} = 'utf-8';
    $Self->{Charset}     = $Self->{UserCharset};                            # just for compat.
    $Self->{SessionID}   = $Param{SessionID} || '';
    $Self->{SessionName} = $Param{SessionName} || 'SessionID';
    $Self->{CGIHandle}   = $ENV{SCRIPT_NAME} || 'No-$ENV{"SCRIPT_NAME"}';

    # baselink
    $Self->{Baselink} = $Self->{CGIHandle} . '?';
    $Self->{Time}     = $Self->{LanguageObject}->Time(
        Action => 'GET',
        Format => 'DateFormat',
    );
    $Self->{TimeLong} = $Self->{LanguageObject}->Time(
        Action => 'GET',
        Format => 'DateFormatLong',
    );

    # set text direction
    $Self->{TextDirection} = $Self->{LanguageObject}->{TextDirection};

    # check Frontend::Output::FilterElementPost
    $Self->{FilterElementPost} = {};

    my %FilterElementPost = %{ $ConfigObject->Get('Frontend::Output::FilterElementPost') // {} };

    FILTER:
    for my $Filter ( sort keys %FilterElementPost ) {

        # extract filter config
        my $FilterConfig = $FilterElementPost{$Filter};

        next FILTER if !$FilterConfig || ref $FilterConfig ne 'HASH';

        # extract template list
        my %TemplateList = %{ $FilterConfig->{Templates} || {} };

        if ( !%TemplateList || $TemplateList{ALL} ) {

            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => <<EOF,
$FilterConfig->{Module} will be ignored because it wants to operate on all templates or does not specify a template list.
EOF
            );

            next FILTER;
        }

        $Self->{FilterElementPost}->{$Filter} = $FilterElementPost{$Filter};
    }

    # check Frontend::Output::FilterContent
    $Self->{FilterContent} = $ConfigObject->Get('Frontend::Output::FilterContent');

    # check Frontend::Output::FilterText
    $Self->{FilterText} = $ConfigObject->Get('Frontend::Output::FilterText');

    # check browser
    $Self->{Browser}        = 'Unknown';
    $Self->{BrowserVersion} = 0;
    $Self->{Platform}       = '';
    $Self->{IsMobile}       = 0;

    $Self->{BrowserJavaScriptSupport} = 1;
    $Self->{BrowserRichText}          = 1;

    my $HttpUserAgent = ( defined $ENV{HTTP_USER_AGENT} ? lc $ENV{HTTP_USER_AGENT} : '' );

    if ( !$HttpUserAgent ) {
        $Self->{Browser} = 'Unknown - no $ENV{"HTTP_USER_AGENT"}';
    }
    elsif ($HttpUserAgent) {

        # check, if we are on a mobile platform.
        # tablets are handled like desktops
        # only phones are "mobile"
        if ( $HttpUserAgent =~ /mobile/ ) {
            $Self->{IsMobile} = 1;
        }

        # android
        if ( $HttpUserAgent =~ /android/ ) {
            $Self->{Platform} = 'Android';
        }

        # edge / spartan
        if ( $HttpUserAgent =~ /edge/ ) {
            $Self->{Browser} = 'Edge';
        }

        # msie
        elsif (
            $HttpUserAgent =~ /msie\s([0-9.]+)/
            || $HttpUserAgent =~ /internet\sexplorer\/([0-9.]+)/
            )
        {
            $Self->{Browser} = 'MSIE';

            if ( $1 =~ /(\d+)\.(\d+)/ ) {
                $Self->{BrowserMajorVersion} = $1;
                $Self->{BrowserMinorVersion} = $2;
            }

            # older windows mobile phones (until IE9), that still have 'MSIE' in the user agent string
            if ( $Self->{IsMobile} ) {
                $Self->{Platform} = 'Windows Phone';
            }
        }

        # mobile ie
        elsif ( $HttpUserAgent =~ /iemobile/ ) {
            $Self->{Browser}  = 'MSIE';
            $Self->{Platform} = 'Windows Phone';
        }

        # mobile ie (second try)
        elsif ( $HttpUserAgent =~ /trident/ ) {
            $Self->{Browser} = 'MSIE';

            if ( $HttpUserAgent =~ /rv:([0-9])+\.([0-9])+/ ) {
                $Self->{BrowserMajorVersion} = $2;
                $Self->{BrowserMinorVersion} = $3;
            }
        }

        # iOS
        elsif ( $HttpUserAgent =~ /(ipad|iphone|ipod)/ ) {
            $Self->{Platform} = 'iOS';
            $Self->{Browser}  = 'Safari';

            if ( $HttpUserAgent =~ /(ipad|iphone|ipod);.*cpu.*os ([0-9]+)_/ ) {
                $Self->{BrowserVersion} = $2;
            }

            if ( $HttpUserAgent =~ /crios/ ) {
                $Self->{Browser} = 'Chrome';
            }

            # RichText is supported in iOS6+.
            if ( $Self->{BrowserVersion} >= 6 ) {
                $Self->{BrowserRichText} = 1;
            }
            else {
                $Self->{BrowserRichText} = 0;
            }
        }

        # safari
        elsif ( $HttpUserAgent =~ /safari/ ) {

            # chrome
            if ( $HttpUserAgent =~ /chrome/ ) {
                $Self->{Browser} = 'Chrome';
            }
            else {
                $Self->{Browser} = 'Safari';
            }
        }

        # konqueror
        elsif ( $HttpUserAgent =~ /konqueror/ ) {
            $Self->{Browser} = 'Konqueror';

            # on konquerer disable rich text editor
            $Self->{BrowserRichText} = 0;
        }

        # firefox
        elsif ( $HttpUserAgent =~ /firefox/ ) {
            $Self->{Browser} = 'Firefox';
        }

        # opera
        elsif ( $HttpUserAgent =~ /^opera.*/ ) {
            $Self->{Browser} = 'Opera';
        }

        # netscape
        elsif ( $HttpUserAgent =~ /netscape/ ) {
            $Self->{Browser} = 'Netscape';
        }

        # w3m
        elsif ( $HttpUserAgent =~ /^w3m.*/ ) {
            $Self->{Browser}                  = 'w3m';
            $Self->{BrowserJavaScriptSupport} = 0;
        }

        # lynx
        elsif ( $HttpUserAgent =~ /^lynx.*/ ) {
            $Self->{Browser}                  = 'Lynx';
            $Self->{BrowserJavaScriptSupport} = 0;
        }

        # links
        elsif ( $HttpUserAgent =~ /^links.*/ ) {
            $Self->{Browser} = 'Links';
        }
        else {
            $Self->{Browser} = 'Unknown - ' . $HttpUserAgent;
        }
    }

    # check mobile devices to disable richtext support
    if (
        $Self->{IsMobile}
        && $Self->{Platform} ne 'iOS'
        && $Self->{Platform} ne 'Android'
        && $Self->{Platform} ne 'Windows Phone'
        )
    {
        $Self->{BrowserRichText} = 0;
    }

    # check if rich text can be active
    if ( !$Self->{BrowserJavaScriptSupport} || !$Self->{BrowserRichText} ) {
        $ConfigObject->Set(
            Key   => 'Frontend::RichText',
            Value => 0,
        );
    }

    # check if rich text is active
    if ( !$ConfigObject->Get('Frontend::RichText') ) {
        $Self->{BrowserRichText} = 0;
    }

    # check if spell check should be active
    if ( $Self->{BrowserJavaScriptSupport} && $ConfigObject->Get('SpellChecker') ) {
        if ( $ConfigObject->Get('Frontend::RichText') ) {
            $Self->{BrowserSpellCheckerInline} = 1;
        }
        else {
            $Self->{BrowserSpellChecker} = 1;
        }
    }

    # load theme
    my $Theme = $Self->{UserTheme} || $ConfigObject->Get('DefaultTheme') || Translatable('Standard');

    # force a theme based on host name
    my $DefaultThemeHostBased = $ConfigObject->Get('DefaultTheme::HostBased');
    if ( $DefaultThemeHostBased && $ENV{HTTP_HOST} ) {

        THEME:
        for my $RegExp ( sort keys %{$DefaultThemeHostBased} ) {

            # do not use empty regexp or theme directories
            next THEME if !$RegExp;
            next THEME if $RegExp eq '';
            next THEME if !$DefaultThemeHostBased->{$RegExp};

            # check if regexp is matching
            if ( $ENV{HTTP_HOST} =~ /$RegExp/i ) {
                $Theme = $DefaultThemeHostBased->{$RegExp};
            }
        }
    }

    # locate template files
    $Self->{TemplateDir}         = $ConfigObject->Get('TemplateDir') . '/HTML/Templates/' . $Theme;
    $Self->{StandardTemplateDir} = $ConfigObject->Get('TemplateDir') . '/HTML/Templates/' . 'Standard';

    # Check if 'Standard' fallback exists
    if ( !-e $Self->{StandardTemplateDir} ) {
        $Self->FatalDie(
            Message =>
                "No existing template directory found ('$Self->{TemplateDir}')! Check your Home in Kernel/Config.pm."
        );
    }

    if ( !-e $Self->{TemplateDir} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message =>
                "No existing template directory found ('$Self->{TemplateDir}')!.
                Default theme used instead.",
        );

        # Set TemplateDir to 'Standard' as a fallback.
        $Theme = 'Standard';
        $Self->{TemplateDir} = $Self->{StandardTemplateDir};
    }

    $Self->{CustomTemplateDir}         = $ConfigObject->Get('CustomTemplateDir') . '/HTML/Templates/' . $Theme;
    $Self->{CustomStandardTemplateDir} = $ConfigObject->Get('CustomTemplateDir') . '/HTML/Templates/' . 'Standard';

    # get main object
    my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

    # load sub layout files
    my $NewDir = $ConfigObject->Get('TemplateDir') . '/HTML/Layout';
    if ( -e $NewDir ) {
        my @NewFiles = $MainObject->DirectoryRead(
            Directory => $NewDir,
            Filter    => '*.pm',
        );
        for my $NewFile (@NewFiles) {
            if ( $NewFile !~ /Layout.pm$/ ) {
                $NewFile =~ s{\A.*\/(.+?).pm\z}{$1}xms;
                my $NewClassName = "Kernel::Output::HTML::Layout::$NewFile";
                if ( !$MainObject->RequireBaseClass($NewClassName) ) {
                    $Self->FatalDie(
                        Message => "Could not load class Kernel::Output::HTML::Layout::$NewFile.",
                    );
                }
            }
        }
    }

    if ( $Self->{SessionID} && $Self->{UserChallengeToken} ) {
        $Self->{ChallengeTokenParam} = "ChallengeToken=$Self->{UserChallengeToken};";
    }

    return $Self;
}
</pre></div>

<p>create a new object. Do not use it directly, instead use:</p>

<pre>    use Kernel::System::ObjectManager;
    local $Kernel::OM = Kernel::System::ObjectManager-&gt;new(
        'Kernel::Output::HTML::Layout' =&gt; {
            Lang    =&gt; 'de',
        },
    );
    my $LayoutObject = $Kernel::OM-&gt;Get('Kernel::Output::HTML::Layout');
</pre><p>From the web installer, a special Option <code>InstallerOnly</code> is passed
to indicate that a database connection is not yet available.</p>

<pre>    use Kernel::System::ObjectManager;
    local $Kernel::OM = Kernel::System::ObjectManager-&gt;new(
        'Kernel::Output::HTML::Layout' =&gt; {
            InstallerOnly =&gt; 1,
        },
    );
    my $LayoutObject = $Kernel::OM-&gt;Get('Kernel::Output::HTML::Layout');
</pre><h2 id="Block">Block()</h2>

<p><a href="#" onclick="toggleCode('method_Block');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Block">
                                        <pre>

sub Block {
    my ( $Self, %Param ) = @_;

    if ( !$Param{Name} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Need Name!'
        );
        return;
    }
    push @{ $Self->{BlockData} },
        {
        Name => $Param{Name},
        Data => $Param{Data},
        };
}
</pre></div>

<p>call a block and pass data to it (optional) to generate the block's output.</p>

<pre>    $LayoutObject-&gt;Block(
        Name =&gt; 'Row',
        Data =&gt; {
            Time =&gt; ...,
        },
    );
</pre><h2 id="JSONEncode">JSONEncode()</h2>

<p><a href="#" onclick="toggleCode('method_JSONEncode');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_JSONEncode">
                                        <pre>

sub JSONEncode {
    my ( $Self, %Param ) = @_;

    # check for needed data
    return if !defined $Param{Data};

    # get JSON encoded data
    my $JSON = $Kernel::OM->Get('Kernel::System::JSON')->Encode(
        Data => $Param{Data},
    ) || '""';

    # remove trailing and trailing double quotes if requested
    if ( $Param{NoQuotes} ) {
        $JSON =~ s{ \A "(.*)" \z }{$1}smx;
    }

    return $JSON;
}
</pre></div>

<p>Encode perl data structure to JSON string</p>

<pre>    my $JSON = $LayoutObject-&gt;JSONEncode(
        Data        =&gt; $Data,
        NoQuotes    =&gt; 0|1, # optional: no double quotes at the start and the end of JSON string
    );
</pre><h2 id="Redirect">Redirect()</h2>

<p><a href="#" onclick="toggleCode('method_Redirect');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Redirect">
                                        <pre>

sub Redirect {
    my ( $Self, %Param ) = @_;

    my $ConfigObject = $Kernel::OM->Get('Kernel::Config');

    # add cookies if exists
    my $Cookies = '';
    if ( $Self->{SetCookies} && $ConfigObject->Get('SessionUseCookie') ) {
        for ( sort keys %{ $Self->{SetCookies} } ) {
            $Cookies .= "Set-Cookie: $Self->{SetCookies}->{$_}\n";
        }
    }

    # create & return output
    if ( $Param{ExtURL} ) {

        # external redirect
        $Param{Redirect} = $Param{ExtURL};
        return $Cookies
            . $Self->Output(
            TemplateFile => 'Redirect',
            Data         => \%Param
            );
    }

    # set baselink
    $Param{Redirect} = $Self->{Baselink};

    if ( $Param{OP} ) {

        # Filter out hazardous characters
        if ( $Param{OP} =~ s{\x00}{}smxg ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => 'Someone tries to use a null bytes (\x00) character in redirect!',
            );
        }

        if ( $Param{OP} =~ s{\r}{}smxg ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => 'Someone tries to use a carriage return character in redirect!',
            );
        }

        if ( $Param{OP} =~ s{\n}{}smxg ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => 'Someone tries to use a newline character in redirect!',
            );
        }

        # internal redirect
        $Param{OP} =~ s/^.*\?(.+?)$/$1/;
        $Param{Redirect} .= $Param{OP};
    }

    # check if IIS 6 is used, add absolute url for IIS workaround
    # see also:
    #  o http://bugs.otrs.org/show_bug.cgi?id=2230
    #  o http://bugs.otrs.org/show_bug.cgi?id=9835
    #  o http://support.microsoft.com/default.aspx?scid=kb;en-us;221154
    if ( $ENV{SERVER_SOFTWARE} =~ /^microsoft\-iis\/6/i ) {
        my $Host = $ENV{HTTP_HOST} || $ConfigObject->Get('FQDN');
        my $HttpType = $ConfigObject->Get('HttpType');
        $Param{Redirect} = $HttpType . '://' . $Host . $Param{Redirect};
    }
    my $Output = $Cookies
        . $Self->Output(
        TemplateFile => 'Redirect',
        Data         => \%Param
        );

    # add session id to redirect if no cookie is enabled
    if ( !$Self->{SessionIDCookie} && !( $Self->{BrowserHasCookie} && $Param{Login} ) ) {

        # rewrite location header
        $Output =~ s{
            (location:\s)(.*)
        }
        {
            my $Start  = $1;
            my $Target = $2;
            my $End = '';
            if ($Target =~ /^(.+?)#(|.+?)$/) {
                $Target = $1;
                $End = "#$2";
            }
            if ($Target =~ /http/i || !$Self->{SessionID}) {
                "$Start$Target$End";
            }
            else {
                if ($Target =~ /(\?|&)$/) {
                    "$Start$Target$Self->{SessionName}=$Self->{SessionID}$End";
                }
                elsif ($Target !~ /\?/) {
                    "$Start$Target?$Self->{SessionName}=$Self->{SessionID}$End";
                }
                elsif ($Target =~ /\?/) {
                    "$Start$Target&$Self->{SessionName}=$Self->{SessionID}$End";
                }
                else {
                    "$Start$Target?&$Self->{SessionName}=$Self->{SessionID}$End";
                }
            }
        }iegx;
    }
    return $Output;
}
</pre></div>

<p>return html for browser to redirect</p>

<pre>    my $HTML = $LayoutObject-&gt;Redirect(
        OP =&gt; &quot;Action=AdminUserGroup;Subaction=User;ID=$UserID&quot;,
    );

    my $HTML = $LayoutObject-&gt;Redirect(
        ExtURL =&gt; &quot;http://some.example.com/&quot;,
    );
</pre><p>During login action, <code>Login =</code> 1&gt; should be passed to Redirect(),
which indicates that if the browser has cookie support, it is OK
for the session cookie to be not yet set.</p>

<h2 id="Notify">Notify()</h2>

<p><a href="#" onclick="toggleCode('method_Notify');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Notify">
                                        <pre>

sub Notify {
    my ( $Self, %Param ) = @_;

    # create & return output
    if ( !$Param{Info} && !$Param{Data} ) {
        $Param{BackendMessage} = $Kernel::OM->Get('Kernel::System::Log')->GetLogEntry(
            Type => 'Notice',
            What => 'Message',
            )
            || $Kernel::OM->Get('Kernel::System::Log')->GetLogEntry(
            Type => 'Error',
            What => 'Message',
            ) || '';

        $Param{Info} = $Param{BackendMessage};

        # return if we have nothing to show
        return '' if !$Param{Info};
    }

    my $BoxClass = 'Notice';

    if ( $Param{Info} ) {
        $Param{Info} =~ s/\n//g;
    }
    if ( $Param{Priority} && $Param{Priority} eq 'Error' ) {
        $BoxClass = 'Error';
    }
    elsif ( $Param{Priority} && $Param{Priority} eq 'Success' ) {
        $BoxClass = 'Success';
    }
    elsif ( $Param{Priority} && $Param{Priority} eq 'Info' ) {
        $BoxClass = 'Info';
    }

    if ( $Param{Link} ) {
        $Self->Block(
            Name => 'LinkStart',
            Data => {
                LinkStart => $Param{Link},
                LinkClass => $Param{LinkClass} || '',
            },
        );
    }
    if ( $Param{Data} ) {
        $Self->Block(
            Name => 'Data',
            Data => \%Param,
        );
    }
    else {
        $Self->Block(
            Name => 'Text',
            Data => \%Param,
        );
    }
    if ( $Param{Link} ) {
        $Self->Block(
            Name => 'LinkStop',
            Data => {
                LinkStop => '</a>',
            },
        );
    }
    return $Self->Output(
        TemplateFile => 'Notify',
        Data         => {
            %Param,
            BoxClass => $BoxClass,
        },
    );
}
</pre></div>

<p>create notify lines</p>

<pre>    infos, the text will be translated

    my $Output = $LayoutObject-&gt;Notify(
        Priority =&gt; 'Warning',
        Info =&gt; 'Some Info Message',
    );

    data with link, the text will be translated

    my $Output = $LayoutObject-&gt;Notify(
        Priority  =&gt; 'Warning',
        Data      =&gt; 'Template content',
        Link      =&gt; 'http://example.com/',
        LinkClass =&gt; 'some_CSS_class',              # optional
    );

    errors, the text will be translated

    my $Output = $LayoutObject-&gt;Notify(
        Priority =&gt; 'Error',
        Info =&gt; 'Some Error Message',
    );

    errors from log backend, if no error extists, a '' will be returned

    my $Output = $LayoutObject-&gt;Notify(
        Priority =&gt; 'Error',
    );
</pre><h2 id="Header">Header()</h2>

<p><a href="#" onclick="toggleCode('method_Header');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Header">
                                        <pre>

sub Header {
    my ( $Self, %Param ) = @_;

    my $Type = $Param{Type} || '';

    # check params
    if ( !defined $Param{ShowToolbarItems} ) {
        $Param{ShowToolbarItems} = 1;
    }

    if ( !defined $Param{ShowPrefLink} ) {
        $Param{ShowPrefLink} = 1;
    }

    my $ConfigObject = $Kernel::OM->Get('Kernel::Config');

    # do not show preferences link if the preferences module is disabled
    my $Modules = $ConfigObject->Get('Frontend::Module');
    if ( !$Modules->{AgentPreferences} ) {
        $Param{ShowPrefLink} = 0;
    }

    if ( !defined $Param{ShowLogoutButton} ) {
        $Param{ShowLogoutButton} = 1;
    }

    # set rtl if needed
    if ( $Self->{TextDirection} && $Self->{TextDirection} eq 'rtl' ) {
        $Param{BodyClass} = 'RTL';
    }
    elsif ( $ConfigObject->Get('Frontend::DebugMode') ) {
        $Self->Block(
            Name => 'DebugRTLButton',
        );
    }

    # Generate the minified CSS and JavaScript files and the tags referencing them (see LayoutLoader)
    $Self->LoaderCreateAgentCSSCalls();

    my %AgentLogo;

    # check if we need to display a custom logo for the selected skin
    my $AgentLogoCustom = $ConfigObject->Get('AgentLogoCustom');
    if (
        $Self->{SkinSelected}
        && $AgentLogoCustom
        && IsHashRefWithData($AgentLogoCustom)
        && $AgentLogoCustom->{ $Self->{SkinSelected} }
        )
    {
        %AgentLogo = %{ $AgentLogoCustom->{ $Self->{SkinSelected} } };
    }

    # Otherwise show default header logo, if configured
    elsif ( defined $ConfigObject->Get('AgentLogo') ) {
        %AgentLogo = %{ $ConfigObject->Get('AgentLogo') };
    }

    if ( %AgentLogo && keys %AgentLogo ) {

        my %Data;
        for my $CSSStatement ( sort keys %AgentLogo ) {
            if ( $CSSStatement eq 'URL' ) {
                my $WebPath = '';
                if ( $AgentLogo{$CSSStatement} !~ /(http|ftp|https):\//i ) {
                    $WebPath = $ConfigObject->Get('Frontend::WebPath');
                }
                $Data{'URL'} = 'url(' . $WebPath . $AgentLogo{$CSSStatement} . ')';
            }
            else {
                $Data{$CSSStatement} = $AgentLogo{$CSSStatement};
            }
        }

        $Self->Block(
            Name => 'HeaderLogoCSS',
            Data => \%Data,
        );
    }

    # add cookies if exists
    my $Output = '';
    if ( $Self->{SetCookies} && $ConfigObject->Get('SessionUseCookie') ) {
        for ( sort keys %{ $Self->{SetCookies} } ) {
            $Output .= "Set-Cookie: $Self->{SetCookies}->{$_}\n";
        }
    }

    my $File = $Param{Filename} || $Self->{Action} || 'unknown';

    # set file name for "save page as"
    $Param{ContentDisposition} = "filename=\"$File.html\"";

    # area and title
    if ( !$Param{Area} ) {
        $Param{Area} = (
            defined $Self->{Action}
            ? $ConfigObject->Get('Frontend::Module')->{ $Self->{Action} }->{NavBarName}
            : ''
        );
    }
    if ( !$Param{Title} ) {
        $Param{Title} = $ConfigObject->Get('Frontend::Module')->{ $Self->{Action} }->{Title}
            || '';
    }
    for my $Word (qw(Value Title Area)) {
        if ( $Param{$Word} ) {
            $Param{TitleArea} .= $Self->{LanguageObject}->Translate( $Param{$Word} ) . ' - ';
        }
    }

    my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

    # run header meta modules
    my $HeaderMetaModule = $ConfigObject->Get('Frontend::HeaderMetaModule');
    if ( ref $HeaderMetaModule eq 'HASH' ) {
        my %Jobs = %{$HeaderMetaModule};

        MODULE:
        for my $Job ( sort keys %Jobs ) {

            # load and run module
            next MODULE if !$MainObject->Require( $Jobs{$Job}->{Module} );
            my $Object = $Jobs{$Job}->{Module}->new(
                %{$Self},
                LayoutObject => $Self,
            );
            next MODULE if !$Object;
            $Object->Run( %Param, Config => $Jobs{$Job} );
        }
    }

    # run tool bar item modules
    if ( $Self->{UserID} && $Self->{UserType} eq 'User' ) {
        my $ToolBarModule = $ConfigObject->Get('Frontend::ToolBarModule');
        if ( $Param{ShowToolbarItems} && ref $ToolBarModule eq 'HASH' ) {

            $Self->Block(
                Name => 'ToolBar',
                Data => \%Param,
            );

            my %Modules;
            my %Jobs = %{$ToolBarModule};

            # get group object
            my $GroupObject = $Kernel::OM->Get('Kernel::System::Group');

            MODULE:
            for my $Job ( sort keys %Jobs ) {

                # load and run module
                next MODULE if !$MainObject->Require( $Jobs{$Job}->{Module} );
                my $Object = $Jobs{$Job}->{Module}->new(
                    %{$Self},    # UserID etc.
                );
                next MODULE if !$Object;

                my $ToolBarAccessOk;

                # if group restriction for tool-bar is set, check user permission
                if ( $Jobs{$Job}->{Group} ) {

                    # remove white-spaces
                    $Jobs{$Job}->{Group} =~ s{\s}{}xmsg;

                    # get group configurations
                    my @Items = split( ';', $Jobs{$Job}->{Group} );

                    ITEM:
                    for my $Item (@Items) {

                        # split values into permission and group
                        my ( $Permission, $GroupName ) = split( ':', $Item );

                        # log an error if not valid setting
                        if ( !$Permission || !$GroupName ) {
                            $Kernel::OM->Get('Kernel::System::Log')->Log(
                                Priority => 'error',
                                Message  => "Invalid config for ToolBarModule $Job - Key Group: '$Item'! "
                                    . "Need something like 'Permission:Group;'",
                            );
                        }

                        # get groups for current user
                        my %Groups = $GroupObject->PermissionUserGet(
                            UserID => $Self->{UserID},
                            Type   => $Permission,
                        );

                        # next job if user have not groups
                        next ITEM if !%Groups;

                        # check user belongs to the correct group
                        my %GroupsReverse = reverse %Groups;
                        next ITEM if !$GroupsReverse{$GroupName};

                        $ToolBarAccessOk = 1;

                        last ITEM;
                    }

                    # go to the next module if not permissions
                    # for the current one
                    next MODULE if !$ToolBarAccessOk;
                }

                %Modules = ( $Object->Run( %Param, Config => $Jobs{$Job} ), %Modules );
            }

            # show tool bar items
            MODULE:
            for my $Key ( sort keys %Modules ) {
                next MODULE if !%{ $Modules{$Key} };
                $Self->Block(
                    Name => $Modules{$Key}->{Block},
                    Data => {
                        %{ $Modules{$Key} },
                        AccessKeyReference => $Modules{$Key}->{AccessKey}
                        ? " ($Modules{$Key}->{AccessKey})"
                        : '',
                    },
                );
            }
        }

        if ( $Kernel::OM->Get('Kernel::System::Main')->Require( 'Kernel::System::Chat', Silent => 1 ) ) {
            if ( $ConfigObject->Get('ChatEngine::Active') ) {
                $Self->AddJSData(
                    Key   => 'ChatEngine::Active',
                    Value => $ConfigObject->Get('ChatEngine::Active')
                );
            }
        }

        # show logged in notice
        if ( $Param{ShowPrefLink} ) {
            $Self->Block(
                Name => 'Login',
                Data => \%Param,
            );
        }
        else {
            $Self->Block(
                Name => 'LoginWithoutLink',
                Data => \%Param,
            );
        }

        # show logout button (if registered)
        if (
            $Param{ShowLogoutButton}
            && $ConfigObject->Get('Frontend::Module')->{Logout}
            )
        {
            $Self->Block(
                Name => 'Logout',
                Data => \%Param,
            );
        }
    }

    # create & return output
    $Output .= $Self->Output(
        TemplateFile => "Header$Type",
        Data         => \%Param
    );

    # remove the version tag from the header if configured
    $Self->_DisableBannerCheck( OutputRef => \$Output );

    return $Output;
}
</pre></div>

<p>generates the HTML for the page begin in the Agent interface.</p>

<pre>    my $Output = $LayoutObject-&gt;Header(
        Type              =&gt; 'Small',                # (optional) '' (Default, full header) or 'Small' (blank header)
        ShowToolbarItems  =&gt; 0,                      # (optional) default 1 (0|1)
        ShowPrefLink      =&gt; 0,                      # (optional) default 1 (0|1)
        ShowLogoutButton  =&gt; 0,                      # (optional) default 1 (0|1)
    );
</pre><h2 id="Ascii2Html">Ascii2Html()</h2>

<p><a href="#" onclick="toggleCode('method_Ascii2Html');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Ascii2Html">
                                        <pre>

sub Ascii2Html {
    my ( $Self, %Param ) = @_;

    # check needed param
    return '' if !defined $Param{Text};

    # check text
    my $TextScalar;
    my $Text;
    if ( !ref $Param{Text} ) {
        $TextScalar = 1;
        $Text       = \$Param{Text};
    }
    elsif ( ref $Param{Text} eq 'SCALAR' ) {
        $Text = $Param{Text};
    }
    else {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => 'Invalid ref "' . ref( $Param{Text} ) . '" of Text param!',
        );
        return '';
    }

    # run output filter text
    my @Filters;
    if ( $Param{LinkFeature} && $Self->{FilterText} && ref $Self->{FilterText} eq 'HASH' ) {

        # extract filter list
        my %FilterList = %{ $Self->{FilterText} };

        my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

        FILTER:
        for my $Filter ( sort keys %FilterList ) {

            # extract filter config
            my $FilterConfig = $FilterList{$Filter};

            next FILTER if !$FilterConfig;
            next FILTER if ref $FilterConfig ne 'HASH';

            # extract template list
            my $TemplateList = $FilterConfig->{Templates};

            # check template list
            if ( !$TemplateList || ref $TemplateList ne 'HASH' || !%{$TemplateList} ) {

                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message =>
                        "Please add a template list to output filter $FilterConfig->{Module} "
                        . "to improve performance. Use ALL if OutputFilter should modify all "
                        . "templates of the system (deprecated).",
                );
            }

            # check template list
            if ( $Param{TemplateFile} && ref $TemplateList eq 'HASH' && !$TemplateList->{ALL} ) {
                next FILTER if !$TemplateList->{ $Param{TemplateFile} };
            }

            $Self->FatalDie() if !$MainObject->Require( $FilterConfig->{Module} );

            # create new instance
            my $Object = $FilterConfig->{Module}->new(
                %{$Self},
                LayoutObject => $Self,
            );

            next FILTER if !$Object;

            push(
                @Filters,
                {
                    Object => $Object,
                    Filter => $FilterConfig,
                },
            );
        }

        # pre run
        for my $Filter (@Filters) {

            $Text = $Filter->{Object}->Pre(
                Filter => $Filter->{Filter},
                Data   => $Text,
            );
        }
    }

    # max width
    if ( $Param{Max} && length ${$Text} > $Param{Max} ) {
        ${$Text} = substr( ${$Text}, 0, $Param{Max} - 5 ) . '[...]';
    }

    # newline
    if ( $Param{NewLine} && length( ${$Text} ) < 140_000 ) {
        ${$Text} =~ s/(\n\r|\r\r\n|\r\n)/\n/g;
        ${$Text} =~ s/\r/\n/g;
        ${$Text} =~ s/(.{4,$Param{NewLine}})(?:\s|\z)/$1\n/gm;
        my $ForceNewLine = $Param{NewLine} + 10;
        ${$Text} =~ s/(.{$ForceNewLine})(.+?)/$1\n$2/g;
    }

    # remove tabs
    ${$Text} =~ s/\t/ /g;

    # strip empty lines
    if ( $Param{StripEmptyLines} ) {
        ${$Text} =~ s/^\s*\n//mg;
    }

    # max lines
    if ( $Param{VMax} ) {
        my @TextList = split( "\n", ${$Text} );
        ${$Text} = '';
        my $Counter = 1;
        for (@TextList) {
            if ( $Counter <= $Param{VMax} ) {
                ${$Text} .= $_ . "\n";
            }
            $Counter++;
        }
        if ( $Counter >= $Param{VMax} ) {
            ${$Text} .= "[...]\n";
        }
    }

    # html quoting
    ${$Text} =~ s/&/&amp;/g;
    ${$Text} =~ s/</&lt;/g;
    ${$Text} =~ s/>/&gt;/g;
    ${$Text} =~ s/"/&quot;/g;

    # text -> html format quoting
    if ( $Param{LinkFeature} ) {
        for my $Filter (@Filters) {
            $Text = $Filter->{Object}->Post(
                Filter => $Filter->{Filter},
                Data   => $Text,
            );
        }
    }

    if ( $Param{HTMLResultMode} ) {
        ${$Text} =~ s/\n/<br\/>\n/g;
        ${$Text} =~ s/  /&nbsp;&nbsp;/g;
    }

    if ( $Param{Type} && $Param{Type} eq 'JSText' ) {
        ${$Text} =~ s/'/\\'/g;
    }

    return $Text if ref $Param{Text};
    return ${$Text};
}
</pre></div>

<p>convert ascii to html string</p>

<pre>    my $HTML = $LayoutObject-&gt;Ascii2Html(
        Text            =&gt; 'Some &lt;&gt; Test &lt;font color=&quot;red&quot;&gt;Test&lt;/font&gt;',
        Max             =&gt; 20,       # max 20 chars folowed by [..]
        VMax            =&gt; 15,       # first 15 lines
        NewLine         =&gt; 0,        # move \r to \n
        HTMLResultMode  =&gt; 0,        # replace &quot; &quot; with &amp;nbsp;
        StripEmptyLines =&gt; 0,
        Type            =&gt; 'Normal', # JSText or Normal text
        LinkFeature     =&gt; 0,        # do some URL detections
    );
</pre><p>also string ref is possible</p>

<pre>    my $HTMLStringRef = $LayoutObject-&gt;Ascii2Html(
        Text =&gt; \$String,
    );
</pre><h2 id="LinkQuote">LinkQuote()</h2>

<p><a href="#" onclick="toggleCode('method_LinkQuote');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_LinkQuote">
                                        <pre>

sub LinkQuote {
    my ( $Self, %Param ) = @_;

    my $Text   = $Param{Text}   || '';
    my $Target = $Param{Target} || 'NewPage' . int( rand(199) );

    # check ref
    my $TextScalar;
    if ( !ref $Text ) {
        $TextScalar = $Text;
        $Text       = \$TextScalar;
    }

    # run output filter text
    my @Filters;
    if ( $Self->{FilterText} && ref $Self->{FilterText} eq 'HASH' ) {

        # extract filter list
        my %FilterList = %{ $Self->{FilterText} };

        my $MainObject = $Kernel::OM->Get('Kernel::System::Main');

        FILTER:
        for my $Filter ( sort keys %FilterList ) {

            # extract filter config
            my $FilterConfig = $FilterList{$Filter};

            next FILTER if !$FilterConfig;
            next FILTER if ref $FilterConfig ne 'HASH';

            # extract template list
            my $TemplateList = $FilterConfig->{Templates};

            # check template list
            if ( !$TemplateList || ref $TemplateList ne 'HASH' || !%{$TemplateList} ) {

                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message =>
                        "Please add a template list to output filter $FilterConfig->{Module} "
                        . "to improve performance. Use ALL if OutputFilter should modify all "
                        . "templates of the system (deprecated).",
                );
            }

            # check template list
            if ( $Param{TemplateFile} && ref $TemplateList eq 'HASH' && !$TemplateList->{ALL} ) {
                next FILTER if !$TemplateList->{ $Param{TemplateFile} };
            }

            $Self->FatalDie() if !$MainObject->Require( $FilterConfig->{Module} );

            # create new instance
            my $Object = $FilterConfig->{Module}->new(
                %{$Self},
                LayoutObject => $Self,
            );

            next FILTER if !$Object;

            push @Filters, {
                Object => $Object,
                Filter => $FilterConfig,
            };
        }
    }

    for my $Filter (@Filters) {
        $Text = $Filter->{Object}->Pre(
            Filter => $Filter->{Filter},
            Data   => $Text
        );
    }
    for my $Filter (@Filters) {
        $Text = $Filter->{Object}->Post(
            Filter => $Filter->{Filter},
            Data   => $Text
        );
    }

    # do mail to quote
    ${$Text} =~ s/(mailto:.+?)(\.\s|\s|\)|\"|]|')/<a href=\"$1\">$1<\/a>$2/gi;

    # check ref && return result like called
    if ($TextScalar) {
        return ${$Text};
    }
    else {
        return $Text;
    }
}
</pre></div>

<p>detect links in text</p>

<pre>    my $HTMLWithLinks = $LayoutObject-&gt;LinkQuote(
        Text =&gt; $HTMLWithOutLinks,
    );
</pre><p>also string ref is possible</p>

<pre>    my $HTMLWithLinksRef = $LayoutObject-&gt;LinkQuote(
        Text =&gt; \$HTMLWithOutLinksRef,
    );
</pre><h2 id="HTMLLinkQuote">HTMLLinkQuote()</h2>

<p><a href="#" onclick="toggleCode('method_HTMLLinkQuote');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_HTMLLinkQuote">
                                        <pre>

sub HTMLLinkQuote {
    my ( $Self, %Param ) = @_;

    return $Kernel::OM->Get('Kernel::System::HTMLUtils')->LinkQuote(
        String    => $Param{String},
        TargetAdd => 1,
        Target    => '_blank',
    );
}
</pre></div>

<p>detect links in HTML code</p>

<pre>    my $HTMLWithLinks = $LayoutObject-&gt;HTMLLinkQuote(
        String =&gt; $HTMLString,
    );
</pre><p>also string ref is possible</p>

<pre>    my $HTMLWithLinksRef = $LayoutObject-&gt;HTMLLinkQuote(
        String =&gt; \$HTMLString,
    );
</pre><h2 id="LinkEncode">LinkEncode()</h2>

<p><a href="#" onclick="toggleCode('method_LinkEncode');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_LinkEncode">
                                        <pre>

sub LinkEncode {
    my ( $Self, $Link ) = @_;

    return if !defined $Link;

    return URI::Escape::uri_escape_utf8($Link);
}
</pre></div>

<p>perform URL encoding on query string parameter names or values.</p>

<pre>    my $ParamValueEncoded = $LayoutObject-&gt;LinkEncode($ParamValue);
</pre><p>Don't encode entire URLs, because this will make them invalid
(?, &amp; and ; will be encoded as well). Only pass one parameter name
or value at a time.</p>

<h2 id="BuildSelection">BuildSelection()</h2>

<p><a href="#" onclick="toggleCode('method_BuildSelection');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_BuildSelection">
                                        <pre>

sub BuildSelection {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(Name Data)) {
        if ( !$Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    # The parameters 'Ajax' and 'OnChange' are exclusive
    if ( $Param{Ajax} && $Param{OnChange} ) {
        $Kernel::OM->Get('Kernel::System::Log')->Log(
            Priority => 'error',
            Message  => "The parameters 'OnChange' and 'Ajax' exclude each other!"
        );
        return;
    }

    # set OnChange if AJAX is used
    if ( $Param{Ajax} ) {
        if ( !$Param{Ajax}->{Depend} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => 'Need Depend Param Ajax option!',
            );
            $Self->FatalError();
        }
        if ( !$Param{Ajax}->{Update} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => 'Need Update Param Ajax option()!',
            );
            $Self->FatalError();
        }
        my $Selector = $Param{ID} || $Param{Name};
        $Param{OnChange} = "Core.AJAX.FormUpdate(\$('#"
            . $Selector . "'), '" . $Param{Ajax}->{Subaction} . "',"
            . " '$Param{Name}',"
            . " ['"
            . join( "', '", @{ $Param{Ajax}->{Update} } ) . "']);";
    }

    # create OptionRef
    my $OptionRef = $Self->_BuildSelectionOptionRefCreate(%Param);

    # create AttributeRef
    my $AttributeRef = $Self->_BuildSelectionAttributeRefCreate(%Param);

    # create DataRef
    my $DataRef = $Self->_BuildSelectionDataRefCreate(
        Data         => $Param{Data},
        AttributeRef => $AttributeRef,
        OptionRef    => $OptionRef,
    );

    # create FiltersRef
    my @Filters;
    my $FilterActive;
    if ( $Param{Filters} ) {
        my $Index = 1;
        for my $Filter ( sort keys %{ $Param{Filters} } ) {
            if (
                $Param{Filters}->{$Filter}->{Name}
                && $Param{Filters}->{$Filter}->{Values}
                )
            {
                my $FilterData = $Self->_BuildSelectionDataRefCreate(
                    Data         => $Param{Filters}->{$Filter}->{Values},
                    AttributeRef => $AttributeRef,
                    OptionRef    => $OptionRef,
                );
                push @Filters, {
                    Name => $Param{Filters}->{$Filter}->{Name},
                    Data => $FilterData,
                };
                if ( $Param{Filters}->{$Filter}->{Active} ) {
                    $FilterActive = $Index;
                }
            }
            else {
                $Kernel::OM->Get('Kernel::System::Log')->Log(
                    Priority => 'error',
                    Message  => 'Each Filter must provide Name and Values!',
                );
                $Self->FatalError();
            }
            $Index++;
        }
        @Filters = sort { $a->{Name} cmp $b->{Name} } @Filters;
    }

    # generate output
    my $String = $Self->_BuildSelectionOutput(
        AttributeRef       => $AttributeRef,
        DataRef            => $DataRef,
        OptionTitle        => $Param{OptionTitle},
        TreeView           => $Param{TreeView},
        FiltersRef         => \@Filters,
        FilterActive       => $FilterActive,
        ExpandFilters      => $Param{ExpandFilters},
        ValidateDateAfter  => $Param{ValidateDateAfter},
        ValidateDateBefore => $Param{ValidateDateBefore},
    );
    return $String;
}
</pre></div>

<p>build a HTML option element based on given data</p>

<pre>    my $HTML = $LayoutObject-&gt;BuildSelection(
        Data            =&gt; $ArrayRef,        # use $HashRef, $ArrayRef or $ArrayHashRef (see below)
        Name            =&gt; 'TheName',        # name of element
        ID              =&gt; 'HTMLID',         # (optional) the HTML ID for this element, if not provided, the name will be used as ID as well
        Multiple        =&gt; 0,                # (optional) default 0 (0|1)
        Size            =&gt; 1,                # (optional) default 1 element size
        Class           =&gt; 'class',          # (optional) a css class, include 'Modernize' to activate InputFields
        Disabled        =&gt; 0,                # (optional) default 0 (0|1) disable the element
        AutoComplete    =&gt; 'off',            # (optional)
        OnChange        =&gt; 'javascript',     # (optional)
        OnClick         =&gt; 'javascript',     # (optional)

        SelectedID     =&gt; 1,                 # (optional) use integer or arrayref (unable to use with ArrayHashRef)
        SelectedID     =&gt; [1, 5, 3],         # (optional) use integer or arrayref (unable to use with ArrayHashRef)
        SelectedValue  =&gt; 'test',            # (optional) use string or arrayref (unable to use with ArrayHashRef)
        SelectedValue  =&gt; ['test', 'test1'], # (optional) use string or arrayref (unable to use with ArrayHashRef)

        Sort           =&gt; 'NumericValue',    # (optional) (AlphanumericValue|NumericValue|AlphanumericKey|NumericKey|TreeView|IndividualKey|IndividualValue) unable to use with ArrayHashRef
        SortIndividual =&gt; ['sec', 'min']     # (optional) only sort is set to IndividualKey or IndividualValue
        SortReverse    =&gt; 0,                 # (optional) reverse the list

        Translation    =&gt; 1,                 # (optional) default 1 (0|1) translate value
        PossibleNone   =&gt; 0,                 # (optional) default 0 (0|1) add a leading empty selection
        TreeView       =&gt; 0,                 # (optional) default 0 (0|1)
        DisabledBranch =&gt; 'Branch',          # (optional) disable all elements of this branch (use string or arrayref)
        Max            =&gt; 100,               # (optional) default 100 max size of the shown value
        HTMLQuote      =&gt; 0,                 # (optional) default 1 (0|1) disable html quote
        Title          =&gt; 'Tooltip Text',    # (optional) string will be shown as Tooltip on mouseover
        OptionTitle    =&gt; 1,                 # (optional) default 0 (0|1) show title attribute (the option value) on every option element

        Filters =&gt; {                         # (optional) filter data, used by InputFields
            LastOwners =&gt; {                  # filter id
                Name   =&gt; 'Last owners',     # name of the filter
                Values =&gt; {                  # filtered data structure
                    Key1 =&gt; 'Value1',
                    Key2 =&gt; 'Value2',
                    Key3 =&gt; 'Value3',
                },
                Active =&gt; 1,                 # (optional) default 0 (0|1) make this filter immediately active
            },
            InvolvedAgents =&gt; {
                Name   =&gt; 'Involved in this ticket',
                Values =&gt; \%HashWithData,
            },
        },
        ExpandFilters  =&gt; 1,                 # (optional) default 0 (0|1) expand filters list by default

        ValidateDateAfter  =&gt; '2016-01-01',  # (optional) validate that date is after supplied value
        ValidateDateBefore =&gt; '2016-01-01',  # (optional) validate that date is before supplied value
    );

    my $HashRef = {
        Key1 =&gt; 'Value1',
        Key2 =&gt; 'Value2',
        Key3 =&gt; 'Value3',
    };

    my $ArrayRef = [
        'KeyValue1',
        'KeyValue2',
        'KeyValue3',
        'KeyValue4',
    ];

    my $ArrayHashRef = [
        {
            Key   =&gt; '1',
            Value =&gt; 'Value1',
        },
        {
            Key      =&gt; '2',
            Value    =&gt; 'Value1::Subvalue1',
            Selected =&gt; 1,
        },
        {
            Key   =&gt; '3',
            Value =&gt; 'Value1::Subvalue2',
        },
        {
            Key      =&gt; '4',
            Value    =&gt; 'Value2',
            Disabled =&gt; 1,
        }
    ];
</pre><h2 id="Permission">Permission()</h2>

<p><a href="#" onclick="toggleCode('method_Permission');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Permission">
                                        <pre>

sub Permission {
    my ( $Self, %Param ) = @_;

    for my $Needed (qw(Action Type)) {
        if ( !defined $Param{$Needed} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Got no $Needed!",
            );
            $Self->FatalError();
        }
    }

    # Get config option for frontend module.
    my $Config = $Kernel::OM->Get('Kernel::Config')->Get('Frontend::Module')->{ $Param{Action} };
    return if !$Config;

    my $Item = $Config->{ $Param{Type} eq 'ro' ? 'GroupRo' : 'Group' };

    my $GroupObject = $Kernel::OM->Get(
        $Self->{UserType} eq 'Customer' ? 'Kernel::System::CustomerGroup' : 'Kernel::System::Group'
    );

    # No access restriction?
    if ( !$Config->{GroupRo} && !$Config->{Group} ) {
        return 1;
    }

    # Array access restriction.
    if ( $Item && ref $Item eq 'ARRAY' ) {
        for my $GroupName ( @{$Item} ) {
            return 1 if $GroupObject->PermissionCheck(
                UserID    => $Self->{UserID},
                GroupName => $GroupName,
                Type      => $Param{Type},
            );
        }
    }

    # Scalar access restriction.
    elsif ($Item) {
        return 1 if $GroupObject->PermissionCheck(
            UserID    => $Self->{UserID},
            GroupName => $Item,
            Type      => $Param{Type},
        );
    }

    return 0;
}
</pre></div>

<p>check if access to a frontend module exists</p>

<pre>    my $Access = $LayoutObject-&gt;Permission(
        Action =&gt; 'AdminCustomerUser',
        Type   =&gt; 'rw', # ro|rw possible
    );
</pre><h2 id="Attachment">Attachment()</h2>

<p><a href="#" onclick="toggleCode('method_Attachment');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Attachment">
                                        <pre>

sub Attachment {
    my ( $Self, %Param ) = @_;

    # check needed params
    for (qw(Content ContentType)) {
        if ( !defined $Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Got no $_!",
            );
            $Self->FatalError();
        }
    }

    # get config object
    my $ConfigObject = $Kernel::OM->Get('Kernel::Config');

    # return attachment
    my $Output = 'Content-Disposition: ';
    if ( $Param{Type} ) {
        $Output .= $Param{Type};
        $Output .= '; ';
    }
    else {
        $Output .= $ConfigObject->Get('AttachmentDownloadType') || 'attachment';
        $Output .= '; ';
    }

    if ( $Param{Filename} ) {

        # IE 10+ supports this
        my $URLEncodedFilename = URI::Escape::uri_escape_utf8( $Param{Filename} );
        $Output .= " filename=\"$Param{Filename}\"; filename*=utf-8''$URLEncodedFilename";
    }
    $Output .= "\n";

    # get attachment size
    $Param{Size} = bytes::length( $Param{Content} );

    # add no cache headers
    if ( $Param{NoCache} ) {
        $Output .= "Expires: Tue, 1 Jan 1980 12:00:00 GMT\n";
        $Output .= "Cache-Control: no-cache\n";
        $Output .= "Pragma: no-cache\n";
    }
    $Output .= "Content-Length: $Param{Size}\n";
    $Output .= "X-UA-Compatible: IE=edge,chrome=1\n";

    if ( !$ConfigObject->Get('DisableIFrameOriginRestricted') ) {
        $Output .= "X-Frame-Options: SAMEORIGIN\n";
    }

    if ( $Param{Sandbox} && !$Kernel::OM->Get('Kernel::Config')->Get('DisableContentSecurityPolicy') ) {

        # Disallow external and inline scripts, active content, frames, but keep allowing inline styles
        #   as this is a common use case in emails.
        # Also disallow referrer headers to prevent referrer leaks.
        # img-src:    allow external and inline (data:) images
        # script-src: block all scripts
        # object-src: allow 'self' so that the browser can load plugins for PDF display
        # frame-src:  block all frames
        # style-src:  allow inline styles for nice email display
        # referrer:   don't send referrers to prevent referrer-leak attacks
        $Output
            .= "Content-Security-Policy: default-src *; img-src * data:; script-src 'none'; object-src 'self'; frame-src 'none'; style-src 'unsafe-inline'; referrer no-referrer;\n";
    }

    if ( $Param{Charset} ) {
        $Output .= "Content-Type: $Param{ContentType}; charset=$Param{Charset};\n\n";
    }
    else {
        $Output .= "Content-Type: $Param{ContentType}\n\n";
    }

    # disable utf8 flag, to write binary to output
    my $EncodeObject = $Kernel::OM->Get('Kernel::System::Encode');
    $EncodeObject->EncodeOutput( \$Output );
    $EncodeObject->EncodeOutput( \$Param{Content} );

    # fix for firefox HEAD problem
    if ( !$ENV{REQUEST_METHOD} || $ENV{REQUEST_METHOD} ne 'HEAD' ) {
        $Output .= $Param{Content};
    }

    # reset binmode, don't use utf8
    binmode STDOUT, ':bytes';

    return $Output;
}
</pre></div>

<p>returns browser output to display/download a attachment</p>

<pre>    $HTML = $LayoutObject-&gt;Attachment(
        Type        =&gt; 'inline',        # optional, default: attachment, possible: inline|attachment
        Filename    =&gt; 'FileName.png',  # optional
        ContentType =&gt; 'image/png',
        Content     =&gt; $Content,
        Sandbox     =&gt; 1,               # optional, default 0; use content security policy to prohibit external
                                        #   scripts, flash etc.
    );

    or for AJAX html snippets

    $HTML = $LayoutObject-&gt;Attachment(
        Type        =&gt; 'inline',        # optional, default: attachment, possible: inline|attachment
        Filename    =&gt; 'FileName.html', # optional
        ContentType =&gt; 'text/html',
        Charset     =&gt; 'utf-8',         # optional
        Content     =&gt; $Content,
        NoCache     =&gt; 1,               # optional
    );
</pre><h2 id="PageNavBar">PageNavBar()</h2>

<p><a href="#" onclick="toggleCode('method_PageNavBar');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_PageNavBar">
                                        <pre>

sub PageNavBar {
    my ( $Self, %Param ) = @_;

    my $Limit = $Param{Limit} || 0;
    $Param{AllHits}  = 0 if ( !$Param{AllHits} );
    $Param{StartHit} = 0 if ( !$Param{AllHits} );
    my $Pages = int( ( $Param{AllHits} / $Param{PageShown} ) + 0.99999 );
    my $Page  = int( ( $Param{StartHit} / $Param{PageShown} ) + 0.99999 );
    my $WindowSize = $Param{WindowSize} || 5;
    my $IDPrefix   = $Param{IDPrefix}   || 'Generic';

    # build Results (1-5 or 16-30)
    if ( $Param{AllHits} >= ( $Param{StartHit} + $Param{PageShown} ) ) {
        $Param{Results} = $Param{StartHit} . "-" . ( $Param{StartHit} + $Param{PageShown} - 1 );
    }
    else {
        $Param{Results} = "$Param{StartHit}-$Param{AllHits}";
    }

    # check total hits
    if ( $Limit == $Param{AllHits} ) {
        $Param{TotalHits} = "<span class=\"PaginationLimit\">$Param{AllHits}</span>";
    }
    else {
        $Param{TotalHits} = $Param{AllHits};
    }

    # build page nav bar
    my $WindowStart = sprintf( "%.0f", ( $Param{StartHit} / $Param{PageShown} ) );
    $WindowStart = int( ( $WindowStart / $WindowSize ) ) + 1;
    $WindowStart = ( $WindowStart * $WindowSize ) - ($WindowSize);
    my $Action = $Param{Action} || '';
    my $Link   = $Param{Link}   || '';
    my $Baselink = "$Self->{Baselink}$Action;$Link";
    my $i        = 0;
    my %PaginationData;
    my $WidgetName;
    my $ClassWidgetName;

    if ( $Param{AJAXReplace} ) {
        $WidgetName = $Param{AJAXReplace};
        $WidgetName =~ s{-}{}xmsg;

        $ClassWidgetName = $WidgetName;
        $ClassWidgetName =~ s/^Dashboard//;
    }

    while ( $i <= ( $Pages - 1 ) ) {
        $i++;

        # show normal page 1,2,3,...
        if ( $i <= ( $WindowStart + $WindowSize ) && $i > $WindowStart ) {
            my $BaselinkAll = $Baselink
                . "StartWindow=$WindowStart;StartHit="
                . ( ( ( $i - 1 ) * $Param{PageShown} ) + 1 );
            my $SelectedPage = "";
            my $PageNumber   = $i;

            if ( $Page == $i ) {
                $SelectedPage = " class=\"Selected\"";
            }

            if ( $Param{AJAXReplace} ) {

                $PaginationData{$PageNumber} = {
                    Baselink    => $BaselinkAll,
                    AjaxReplace => $Param{AJAXReplace},
                    WidgetName  => $ClassWidgetName
                };

                $Self->Block(
                    Name => 'PageAjax',
                    Data => {
                        BaselinkAll  => $BaselinkAll,
                        AjaxReplace  => $Param{AJAXReplace},
                        PageNumber   => $PageNumber,
                        IDPrefix     => $IDPrefix,
                        SelectedPage => $SelectedPage,
                        WidgetName   => $ClassWidgetName
                    },
                );
            }
            else {
                $Self->Block(
                    Name => 'Page',
                    Data => {
                        BaselinkAll  => $BaselinkAll,
                        PageNumber   => $PageNumber,
                        IDPrefix     => $IDPrefix,
                        SelectedPage => $SelectedPage
                    },
                );
            }
        }

        # over window ">>" and ">|"
        elsif ( $i > ( $WindowStart + $WindowSize ) ) {
            my $StartWindow        = $WindowStart + $WindowSize + 1;
            my $LastStartWindow    = int( $Pages / $WindowSize );
            my $BaselinkOneForward = $Baselink . "StartHit=" . ( ( $i - 1 ) * $Param{PageShown} + 1 );
            my $BaselinkAllForward = $Baselink . "StartHit=" . ( ( $Param{PageShown} * ( $Pages - 1 ) ) + 1 );

            if ( $Param{AJAXReplace} ) {
                $PaginationData{$BaselinkOneForward} = {
                    Baselink    => $BaselinkOneForward,
                    AjaxReplace => $Param{AJAXReplace},
                    WidgetName  => $ClassWidgetName
                };
                $PaginationData{$BaselinkAllForward} = {
                    Baselink    => $BaselinkAllForward,
                    AjaxReplace => $Param{AJAXReplace},
                    WidgetName  => $ClassWidgetName
                };

                $Self->Block(
                    Name => 'PageForwardAjax',
                    Data => {
                        BaselinkOneForward => $BaselinkOneForward,
                        BaselinkAllForward => $BaselinkAllForward,
                        AjaxReplace        => $Param{AJAXReplace},
                        IDPrefix           => $IDPrefix,
                        WidgetName         => $ClassWidgetName
                    },
                );
            }
            else {
                $Self->Block(
                    Name => 'PageForward',
                    Data => {
                        BaselinkOneForward => $BaselinkOneForward,
                        BaselinkAllForward => $BaselinkAllForward,
                        IDPrefix           => $IDPrefix,
                    },
                );
            }

            $i = 99999999;
        }

        # over window "<<" and "|<"
        elsif ( $i < $WindowStart && ( $i - 1 ) < $Pages ) {
            my $StartWindow     = $WindowStart - $WindowSize - 1;
            my $BaselinkAllBack = $Baselink . 'StartHit=1;StartWindow=1';
            my $BaselinkOneBack = $Baselink . 'StartHit=' . ( ( $WindowStart - 1 ) * ( $Param{PageShown} ) + 1 );

            if ( $Param{AJAXReplace} ) {

                $PaginationData{$BaselinkOneBack} = {
                    Baselink    => $BaselinkOneBack,
                    AjaxReplace => $Param{AJAXReplace},
                    WidgetName  => $ClassWidgetName
                };
                $PaginationData{$BaselinkAllBack} = {
                    Baselink    => $BaselinkAllBack,
                    AjaxReplace => $Param{AJAXReplace},
                    WidgetName  => $ClassWidgetName
                };

                $Self->Block(
                    Name => 'PageBackAjax',
                    Data => {
                        BaselinkOneBack => $BaselinkOneBack,
                        BaselinkAllBack => $BaselinkAllBack,
                        AjaxReplace     => $Param{AJAXReplace},
                        IDPrefix        => $IDPrefix,
                        WidgetName      => $ClassWidgetName
                    },
                );
            }
            else {
                $Self->Block(
                    Name => 'PageBack',
                    Data => {
                        BaselinkOneBack => $BaselinkOneBack,
                        BaselinkAllBack => $BaselinkAllBack,
                        IDPrefix        => $IDPrefix,
                    },
                );
            }

            $i = $WindowStart - 1;
        }
    }

    # send data to JS
    if ( $Param{AJAXReplace} ) {
        $Self->AddJSData(
            Key   => 'PaginationData' . $ClassWidgetName,
            Value => \%PaginationData
        );
    }

    $Param{SearchNavBar} = $Self->Output(
        TemplateFile => 'Pagination',
        AJAX         => $Param{AJAX},
    );

    # only show total amount of pages if there is more than one
    if ( $Pages > 1 ) {
        $Param{NavBarLong} = "- " . $Self->{LanguageObject}->Translate("Page") . ": $Param{SearchNavBar}";
    }
    else {
        $Param{SearchNavBar} = '';
    }

    # return data
    return (
        TotalHits  => $Param{TotalHits},
        Result     => $Param{Results},
        ResultLong => "$Param{Results} "
            . $Self->{LanguageObject}->Translate("of")
            . " $Param{TotalHits}",
        SiteNavBar     => $Param{SearchNavBar},
        SiteNavBarLong => $Param{NavBarLong},
        Link           => $Param{Link},
    );
}
</pre></div>

<p>generates a page navigation bar</p>

<pre>    my %PageNavBar = $LayoutObject-&gt;PageNavBar(
        Limit       =&gt; 100,         # marks result of TotalHits red if Limit is gerater then AllHits
        WindowSize  =&gt; 15,          # max shown pages to click
        StartHit    =&gt; 1,           # start to show items
        PageShown   =&gt; 15,          # number of shown items a page
        AllHits     =&gt; 56,          # number of total hits
        Action      =&gt; 'AgentXXX',  # e. g. 'Action=' . $Self-&gt;{LayoutObject}-&gt;{Action}
        Link        =&gt; $Link,       # e. g. 'Subaction=View;'
        AJAXReplace =&gt; 'IDElement', # IDElement which should be replaced
        IDPrefix    =&gt; 'Tickets',   # Prefix for the id parameter
    );

    return values of hash

        TotalHits  # total hits
        Result     # shown items e. g. &quot;1-5&quot; or &quot;16-30&quot;
        SiteNavBar # html for page nav bar e. g. &quot;1 2 3 4&quot;

        ResultLong     # shown items e. g. &quot;1-5 of 32&quot; or &quot;16-30 of 64&quot;
        SiteNavBarLong # html for page nav bar e. g. &quot;Page: 1 2 3 4&quot;
</pre><h2 id="BuildDateSelection">BuildDateSelection()</h2>

<p><a href="#" onclick="toggleCode('method_BuildDateSelection');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_BuildDateSelection">
                                        <pre>

sub BuildDateSelection {
    my ( $Self, %Param ) = @_;

    my $ConfigObject = $Kernel::OM->Get('Kernel::Config');

    my $DateInputStyle = $ConfigObject->Get('TimeInputFormat');
    my $Prefix         = $Param{Prefix} || '';
    my $DiffTime       = $Param{DiffTime} || 0;
    my $Format         = defined( $Param{Format} ) ? $Param{Format} : 'DateInputFormatLong';
    my $Area           = $Param{Area} || 'Agent';
    my $Optional       = $Param{ $Prefix . 'Optional' } || 0;
    my $Required       = $Param{ $Prefix . 'Required' } || 0;
    my $Used           = $Param{ $Prefix . 'Used' } || 0;
    my $Class          = $Param{ $Prefix . 'Class' } || '';

    # Defines, if the date selection should be validated on client side with JS
    my $Validate = $Param{Validate} || 0;

    # Validate that the date is in the future (e. g. pending times)
    my $ValidateDateInFuture    = $Param{ValidateDateInFuture}    || 0;
    my $ValidateDateNotInFuture = $Param{ValidateDateNotInFuture} || 0;

    # Validate that the date is set after/before supplied date
    my $ValidateDateAfterPrefix  = $Param{ValidateDateAfterPrefix}  || '';
    my $ValidateDateAfterValue   = $Param{ValidateDateAfterValue}   || '';
    my $ValidateDateBeforePrefix = $Param{ValidateDateBeforePrefix} || '';
    my $ValidateDateBeforeValue  = $Param{ValidateDateBeforeValue}  || '';

    my ( $s, $m, $h, $D, $M, $Y ) = $Self->{UserTimeObject}->SystemTime2Date(
        SystemTime => $Self->{UserTimeObject}->SystemTime() + $DiffTime,
    );

    my ( $Cs, $Cm, $Ch, $CD, $CM, $CY ) = $Self->{UserTimeObject}->SystemTime2Date(
        SystemTime => $Self->{UserTimeObject}->SystemTime(),
    );

    # time zone translation
    if (
        $Self->{UserTimeZone}
        && $Param{ $Prefix . 'Year' }
        && $Param{ $Prefix . 'Month' }
        && $Param{ $Prefix . 'Day' }
        && !$Param{OverrideTimeZone}
        )
    {
        my $DateTimeObject = $Kernel::OM->Create(
            'Kernel::System::DateTime',
            ObjectParams => {
                Year   => $Param{ $Prefix . 'Year' },
                Month  => $Param{ $Prefix . 'Month' },
                Day    => $Param{ $Prefix . 'Day' },
                Hour   => $Param{ $Prefix . 'Hour' } || 0,
                Minute => $Param{ $Prefix . 'Minute' } || 0,
                Second => $Param{ $Prefix . 'Second' } || 0,
            },
        );

        if ($DateTimeObject) {
            $DateTimeObject->ToTimeZone( TimeZone => $Self->{UserTimeZone} );
            my $DateTimeValues = $DateTimeObject->Get();

            $Param{ $Prefix . 'Year' }   = $DateTimeValues->{Year};
            $Param{ $Prefix . 'Month' }  = $DateTimeValues->{Month};
            $Param{ $Prefix . 'Day' }    = $DateTimeValues->{Day};
            $Param{ $Prefix . 'Hour' }   = $DateTimeValues->{Hour};
            $Param{ $Prefix . 'Minute' } = $DateTimeValues->{Minute};
            $Param{ $Prefix . 'Second' } = $DateTimeValues->{Second};
        }
    }

    # year
    if ( $DateInputStyle eq 'Option' ) {
        my %Year;
        if ( defined $Param{YearPeriodPast} && defined $Param{YearPeriodFuture} ) {
            for ( $Y - $Param{YearPeriodPast} .. $Y + $Param{YearPeriodFuture} ) {
                $Year{$_} = $_;
            }
        }
        else {
            for ( 2001 .. $Y + 1 + ( $Param{YearDiff} || 0 ) ) {
                $Year{$_} = $_;
            }
        }

        # Check if the DiffTime is in a future year. In this case, we add the missing years between
        # $CY (current year) and $Y (year) to allow the user to manually set back the year if needed.
        if ( $Y > $CY ) {
            for ( $CY .. $Y ) {
                $Year{$_} = $_;
            }
        }

        $Param{Year} = $Self->BuildSelection(
            Name        => $Prefix . 'Year',
            Data        => \%Year,
            SelectedID  => int( $Param{ $Prefix . 'Year' } || $Y ),
            Translation => 0,
            Class       => $Validate ? "Validate_DateYear $Class" : $Class,
            Title       => $Self->{LanguageObject}->Translate('Year'),
            Disabled    => $Param{Disabled},
        );
    }
    else {
        $Param{Year} = "<input type=\"text\" "
            . ( $Validate ? "class=\"Validate_DateYear $Class\" " : "class=\"$Class\" " )
            . "name=\"${Prefix}Year\" id=\"${Prefix}Year\" size=\"4\" maxlength=\"4\" "
            . "title=\""
            . $Self->{LanguageObject}->Translate('Year')
            . "\" value=\""
            . sprintf( "%02d", ( $Param{ $Prefix . 'Year' } || $Y ) ) . "\" "
            . ( $Param{Disabled} ? 'readonly="readonly"' : '' ) . "/>";
    }

    # month
    if ( $DateInputStyle eq 'Option' ) {
        my %Month = map { $_ => sprintf( "%02d", $_ ); } ( 1 .. 12 );
        $Param{Month} = $Self->BuildSelection(
            Name        => $Prefix . 'Month',
            Data        => \%Month,
            SelectedID  => int( $Param{ $Prefix . 'Month' } || $M ),
            Translation => 0,
            Class       => $Validate ? "Validate_DateMonth $Class" : $Class,
            Title       => $Self->{LanguageObject}->Translate('Month'),
            Disabled    => $Param{Disabled},
        );
    }
    else {
        $Param{Month} = "<input type=\"text\" "
            . ( $Validate ? "class=\"Validate_DateMonth $Class\" " : "class=\"$Class\" " )
            . "name=\"${Prefix}Month\" id=\"${Prefix}Month\" size=\"2\" maxlength=\"2\" "
            . "title=\""
            . $Self->{LanguageObject}->Translate('Month')
            . "\" value=\""
            . sprintf( "%02d", ( $Param{ $Prefix . 'Month' } || $M ) ) . "\" "
            . ( $Param{Disabled} ? 'readonly="readonly"' : '' ) . "/>";
    }

    my $DateValidateClasses = '';
    if ($Validate) {
        $DateValidateClasses
            .= "Validate_DateDay Validate_DateYear_${Prefix}Year Validate_DateMonth_${Prefix}Month";

        if ( $Format eq 'DateInputFormatLong' ) {
            $DateValidateClasses
                .= " Validate_DateHour_${Prefix}Hour Validate_DateMinute_${Prefix}Minute";
        }

        if ($ValidateDateInFuture) {
            $DateValidateClasses .= " Validate_DateInFuture";
        }
        if ($ValidateDateNotInFuture) {
            $DateValidateClasses .= " Validate_DateNotInFuture";
        }
        if ( $ValidateDateAfterPrefix || $ValidateDateAfterValue ) {
            $DateValidateClasses .= ' Validate_DateAfter';
        }
        if ( $ValidateDateBeforePrefix || $ValidateDateBeforeValue ) {
            $DateValidateClasses .= ' Validate_DateBefore';
        }
        if ($ValidateDateAfterPrefix) {
            $DateValidateClasses .= " Validate_DateAfter_$ValidateDateAfterPrefix";
        }
        if ($ValidateDateBeforePrefix) {
            $DateValidateClasses .= " Validate_DateBefore_$ValidateDateBeforePrefix";
        }
    }

    # day
    if ( $DateInputStyle eq 'Option' ) {
        my %Day = map { $_ => sprintf( "%02d", $_ ); } ( 1 .. 31 );
        $Param{Day} = $Self->BuildSelection(
            Name               => $Prefix . 'Day',
            Data               => \%Day,
            SelectedID         => int( $Param{ $Prefix . 'Day' } || $D ),
            Translation        => 0,
            Class              => "$DateValidateClasses $Class",
            Title              => $Self->{LanguageObject}->Translate('Day'),
            Disabled           => $Param{Disabled},
            ValidateDateAfter  => $ValidateDateAfterValue,
            ValidateDateBefore => $ValidateDateBeforeValue,
        );
    }
    else {
        $Param{Day} = "<input type=\"text\" "
            . "class=\"$DateValidateClasses $Class\" "
            . "name=\"${Prefix}Day\" id=\"${Prefix}Day\" size=\"2\" maxlength=\"2\" "
            . "title=\""
            . $Self->{LanguageObject}->Translate('Day')
            . "\" value=\""
            . sprintf( "%02d", ( $Param{ $Prefix . 'Day' } || $D ) ) . "\" "
            . ( $Param{Disabled} ? 'readonly="readonly"' : '' ) . "/>";

    }
    if ( $Format eq 'DateInputFormatLong' ) {

        # hour
        if ( $DateInputStyle eq 'Option' ) {
            my %Hour = map { $_ => sprintf( "%02d", $_ ); } ( 0 .. 23 );
            $Param{Hour} = $Self->BuildSelection(
                Name       => $Prefix . 'Hour',
                Data       => \%Hour,
                SelectedID => defined( $Param{ $Prefix . 'Hour' } )
                ? int( $Param{ $Prefix . 'Hour' } )
                : int($h),
                Translation => 0,
                Class       => $Validate ? ( 'Validate_DateHour ' . $Class ) : $Class,
                Title       => $Self->{LanguageObject}->Translate('Hours'),
                Disabled    => $Param{Disabled},
            );
        }
        else {
            $Param{Hour} = "<input type=\"text\" "
                . ( $Validate ? "class=\"Validate_DateHour $Class\" " : "class=\"$Class\" " )
                . "name=\"${Prefix}Hour\" id=\"${Prefix}Hour\" size=\"2\" maxlength=\"2\" "
                . "title=\""
                . $Self->{LanguageObject}->Translate('Hours')
                . "\" value=\""
                . sprintf(
                "%02d",
                ( defined( $Param{ $Prefix . 'Hour' } ) ? int( $Param{ $Prefix . 'Hour' } ) : $h )
                )
                . "\" "
                . ( $Param{Disabled} ? 'readonly="readonly"' : '' ) . "/>";

        }

        # minute
        if ( $DateInputStyle eq 'Option' ) {
            my %Minute = map { $_ => sprintf( "%02d", $_ ); } ( 0 .. 59 );
            $Param{Minute} = $Self->BuildSelection(
                Name       => $Prefix . 'Minute',
                Data       => \%Minute,
                SelectedID => defined( $Param{ $Prefix . 'Minute' } )
                ? int( $Param{ $Prefix . 'Minute' } )
                : int($m),
                Translation => 0,
                Class       => $Validate ? ( 'Validate_DateMinute ' . $Class ) : $Class,
                Title       => $Self->{LanguageObject}->Translate('Minutes'),
                Disabled    => $Param{Disabled},
            );
        }
        else {
            $Param{Minute} = "<input type=\"text\" "
                . ( $Validate ? "class=\"Validate_DateMinute $Class\" " : "class=\"$Class\" " )
                . "name=\"${Prefix}Minute\" id=\"${Prefix}Minute\" size=\"2\" maxlength=\"2\" "
                . "title=\""
                . $Self->{LanguageObject}->Translate('Minutes')
                . "\" value=\""
                . sprintf(
                "%02d",
                (
                    defined( $Param{ $Prefix . 'Minute' } )
                    ? int( $Param{ $Prefix . 'Minute' } )
                    : $m
                    )
                ) . "\" "
                . ( $Param{Disabled} ? 'readonly="readonly"' : '' ) . "/>";
        }
    }

    # Get first day of the week
    my $WeekDayStart = $ConfigObject->Get('CalendarWeekDayStart');
    if ( $Param{Calendar} ) {
        if ( $ConfigObject->Get( "TimeZone::Calendar" . $Param{Calendar} . "Name" ) ) {
            $WeekDayStart = $ConfigObject->Get( "CalendarWeekDayStart::Calendar" . $Param{Calendar} );
        }
    }
    if ( !defined $WeekDayStart ) {
        $WeekDayStart = 1;
    }

    my $Output;

    # optional checkbox
    if ($Optional) {
        my $Checked = '';
        if ($Used) {
            $Checked = ' checked="checked"';
        }
        $Output .= "<input type=\"checkbox\" name=\""
            . $Prefix
            . "Used\" id=\"" . $Prefix . "Used\" value=\"1\""
            . $Checked
            . " class=\"$Class\""
            . " title=\""
            . $Self->{LanguageObject}->Translate('Check to activate this date')
            . "\" "
            . ( $Param{Disabled} ? 'disabled="disabled"' : '' )
            . "/>&nbsp;";
    }

    # remove 'Second' because it is never used and bug #9441
    delete $Param{ $Prefix . 'Second' };

    # date format
    $Output .= $Self->{LanguageObject}->Time(
        Action => 'Return',
        Format => 'DateInputFormat',
        Mode   => 'NotNumeric',
        %Param,
    );

    # prepare datepicker for specific calendar
    my $VacationDays = '';
    if ( $Param{Calendar} ) {
        $VacationDays = $Self->DatepickerGetVacationDays(
            Calendar => $Param{Calendar},
        );
    }
    my $VacationDaysJSON = $Self->JSONEncode(
        Data => $VacationDays,
    );

    # Add Datepicker JS to output.
    my $DatepickerJS = '
    Core.UI.Datepicker.Init({
        Day: $("#" + Core.App.EscapeSelector("' . $Prefix . '") + "Day"),
        Month: $("#" + Core.App.EscapeSelector("' . $Prefix . '") + "Month"),
        Year: $("#" + Core.App.EscapeSelector("' . $Prefix . '") + "Year"),
        Hour: $("#" + Core.App.EscapeSelector("' . $Prefix . '") + "Hour"),
        Minute: $("#" + Core.App.EscapeSelector("' . $Prefix . '") + "Minute"),
        VacationDays: ' . $VacationDaysJSON . ',
        DateInFuture: ' .    ( $ValidateDateInFuture    ? 'true' : 'false' ) . ',
        DateNotInFuture: ' . ( $ValidateDateNotInFuture ? 'true' : 'false' ) . ',
        WeekDayStart: ' . $WeekDayStart . '
    });';

    $Self->AddJSOnDocumentComplete( Code => $DatepickerJS );
    $Self->{HasDatepicker} = 1;    # Call some Datepicker init code.

    return $Output;
}
</pre></div>

<p>build the HTML code to represent a date selection based on the given data.
Depending on the SysConfig settings the controls to set the date could be multiple select or input fields</p>

<pre>    my $HTML = $LayoutObject-&gt;BuildDateSelection(
        Prefix           =&gt; 'some prefix',        # optional, (needed to specify other parameters)
        &lt;Prefix&gt;Year     =&gt; 2015,                 # optional, defaults to current year, used to set the initial value
        &lt;Prefix&gt;Month    =&gt; 6,                    # optional, defaults to current month, used to set the initial value
        &lt;Prefix&gt;Day      =&gt; 9,                    # optional, defaults to current day, used to set the initial value
        &lt;Prefix&gt;Hour     =&gt; 12,                   # optional, defaults to current hour, used to set the initial value
        &lt;Prefix&gt;Minute   =&gt; 26,                   # optional, defaults to current minute, used to set the initial value
        &lt;Prefix&gt;Second   =&gt; 59,                   # optional, defaults to current second, used to set the initial value
        &lt;Prefix&gt;Optional =&gt; 1,                    # optional, default 0, when active a checkbox is included to specify
                                                  #   if the values should be saved or not
        &lt;Prefix&gt;Used     =&gt; 1,                    # optional, default 0, used to set the initial state of the checkbox
                                                  #   mentioned above
        &lt;Prefix&gt;Required =&gt; 1,                    # optional, default 0 (Deprecated)
        &lt;prefix&gt;Class    =&gt; 'some class',         # optional, specify an additional class to the HTML elements
        Area     =&gt; 'some area',                  # optional, default 'Agent' (Deprecated)
        DiffTime =&gt; 123,                          # optional, default 0, used to set the initial time influencing the
                                                  #   current time (in seconds)
        OverrideTimeZone =&gt; 1,                    # optional (1 or 0), when active the time is not translated to the user
                                                  #   time zone
        YearPeriodFuture =&gt; 3,                    # optional, used to define the number of years in future to be display
                                                  #   in the year select
        YearPeriodPast   =&gt; 2,                    # optional, used to define the number of years in past to be display
                                                  #   in the year select
        YearDiff         =&gt; 0,                    # optional. used to define the number of years to be displayed
                                                  #   in the year select (alternatively to YearPeriodFuture and YearPeriodPast)
        ValidateDateInFuture     =&gt; 1,            # optional (1 or 0), when active sets an special class to validate
                                                  #   that the date set in the controls to be in the future
        ValidateDateNotInFuture  =&gt; 1,            # optional (1 or 0), when active sets an special class to validate
                                                  #   that the date set in the controls not to be in the future
        ValidateDateAfterPrefix  =&gt; 'Start',      # optional (Prefix), when defined sets a special class to validate
                                                  #   that the date set in the controls comes after the date with Prefix
        ValidateDateAfterValue   =&gt; '2016-01-01', # optional (Date), when defined sets a special data parameter to validate
                                                  #   that the date set in the controls comes after the supplied date
        ValidateDateBeforePrefix =&gt; 'End',        # optional (Prefix), when defined sets a special class to validate
                                                  #   that the date set in the controls comes before the date with Prefix
        ValidateDateBeforeValue  =&gt; '2016-01-01', # optional (Date), when defined sets a special data parameter to validate
                                                  #   that the date set in the controls comes before the supplied date
        Calendar =&gt; 2,                            # optional, used to define the SysConfig calendar on which the Datepicker
                                                  #   will be based on to show the vacation days and the start week day
        Format   =&gt; 'DateInputFormat',            # optional, or 'DateInputFormatLong', used to define if only date or
                                                  #   date/time components should be shown (DateInputFormatLong shows date/time)
        Validate =&gt; 1,                            # optional (1 or 0), defines if the date selection should be validated on
                                                  #   client side with JS
        Disabled =&gt; 1,                            # optional (1 or 0), when active select and checkbox controls gets the
                                                  #   disabled attribute and input fields gets the read only attribute
    );
</pre><h2 id="Ascii2RichText">Ascii2RichText()</h2>

<p><a href="#" onclick="toggleCode('method_Ascii2RichText');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_Ascii2RichText">
                                        <pre>

sub Ascii2RichText {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(String)) {
        if ( !defined $Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    # ascii 2 html
    $Param{String} = $Kernel::OM->Get('Kernel::System::HTMLUtils')->ToHTML(
        String => $Param{String},
    );

    return $Param{String};
}
</pre></div>

<p>converts text to rich text</p>

<pre>    my $HTMLString = $LayoutObject-&gt;Ascii2RichText(
        String =&gt; $TextString,
    );
</pre><h2 id="RichText2Ascii">RichText2Ascii()</h2>

<p><a href="#" onclick="toggleCode('method_RichText2Ascii');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_RichText2Ascii">
                                        <pre>

sub RichText2Ascii {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(String)) {
        if ( !defined $Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    # ascii 2 html
    $Param{String} = $Kernel::OM->Get('Kernel::System::HTMLUtils')->ToAscii(
        String => $Param{String},
    );

    return $Param{String};
}
</pre></div>

<p>converts text to rich text</p>

<pre>    my $TextString = $LayoutObject-&gt;RichText2Ascii(
        String =&gt; $HTMLString,
    );
</pre><h2 id="RichTextDocumentComplete">RichTextDocumentComplete()</h2>

<p><a href="#" onclick="toggleCode('method_RichTextDocumentComplete');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_RichTextDocumentComplete">
                                        <pre>

sub RichTextDocumentComplete {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(String)) {
        if ( !defined $Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    # replace image link with content id for uploaded images
    my $StringRef = $Self->_RichTextReplaceLinkOfInlineContent(
        String => \$Param{String},
    );

    # verify html document
    $Param{String} = $Kernel::OM->Get('Kernel::System::HTMLUtils')->DocumentComplete(
        String  => ${$StringRef},
        Charset => $Self->{UserCharset},
    );

    # do correct direction
    if ( $Self->{TextDirection} ) {
        $Param{String} =~ s/<body/<body dir="$Self->{TextDirection}"/i;
    }

    # filter links in response
    $Param{String} = $Self->HTMLLinkQuote( String => $Param{String} );

    return $Param{String};
}
</pre></div>

<p>1) add html, body, ... tags to be a valid html document
2) replace links of inline content e. g. images to &lt;img src=&quot;cid:xxxx&quot; /&gt;</p>

<pre>    $HTMLBody = $LayoutObject-&gt;RichTextDocumentComplete(
        String =&gt; $HTMLBody,
    );
</pre><h2 id="RichTextDocumentServe">RichTextDocumentServe()</h2>

<p><a href="#" onclick="toggleCode('method_RichTextDocumentServe');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_RichTextDocumentServe">
                                        <pre>

sub RichTextDocumentServe {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(Data URL Attachments)) {
        if ( !defined $Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    # get charset and convert content to internal charset
    my $Charset;
    if ( $Param{Data}->{ContentType} =~ m/.+?charset=("|'|)(.+)/ig ) {
        $Charset = $2;
        $Charset =~ s/"|'//g;
    }
    if ( !$Charset ) {
        $Charset = 'us-ascii';
        $Param{Data}->{ContentType} .= '; charset="us-ascii"';
    }

    # convert charset
    if ($Charset) {
        $Param{Data}->{Content} = $Kernel::OM->Get('Kernel::System::Encode')->Convert(
            Text  => $Param{Data}->{Content},
            From  => $Charset,
            To    => 'utf-8',
            Check => 1,
        );

        # replace charset in content
        $Param{Data}->{ContentType} =~ s/\Q$Charset\E/utf-8/gi;
        $Param{Data}->{Content} =~ s/(<meta[^>]+charset=("|'|))\Q$Charset\E/$1utf-8/gi;
    }

    # add html links
    $Param{Data}->{Content} = $Self->HTMLLinkQuote(
        String => $Param{Data}->{Content},
    );

    # cleanup some html tags to be cross browser compat.
    $Param{Data}->{Content} = $Self->RichTextDocumentCleanup(
        String => $Param{Data}->{Content},
    );

    # safety check
    if ( !$Param{LoadInlineContent} ) {

        # Strip out active content first, keeping external images.
        my %SafetyCheckResult = $Kernel::OM->Get('Kernel::System::HTMLUtils')->Safety(
            String       => $Param{Data}->{Content},
            NoApplet     => 1,
            NoObject     => 1,
            NoEmbed      => 1,
            NoSVG        => 1,
            NoIntSrcLoad => 0,
            NoExtSrcLoad => 0,
            NoJavaScript => 1,
            Debug        => $Self->{Debug},
        );

        $Param{Data}->{Content} = $SafetyCheckResult{String};

        if ( !$Param{LoadExternalImages} ) {

            # Strip out external images, but show a confirmation button to
            #   load them explicitly.
            my %SafetyCheckResult = $Kernel::OM->Get('Kernel::System::HTMLUtils')->Safety(
                String       => $Param{Data}->{Content},
                NoApplet     => 1,
                NoObject     => 1,
                NoEmbed      => 1,
                NoSVG        => 1,
                NoIntSrcLoad => 0,
                NoExtSrcLoad => 1,
                NoJavaScript => 1,
                Debug        => $Self->{Debug},
            );

            $Param{Data}->{Content} = $SafetyCheckResult{String};

            if ( $SafetyCheckResult{Replace} ) {

                # Generate blocker message.
                my $Message = $Self->Output( TemplateFile => 'AttachmentBlocker' );

                # Add it to the beginning of the body, if possible, otherwise prepend it.
                if ( $Param{Data}->{Content} =~ /<body.*?>/si ) {
                    $Param{Data}->{Content} =~ s/(<body.*?>)/$1\n$Message/si;
                }
                else {
                    $Param{Data}->{Content} = $Message . $Param{Data}->{Content};
                }
            }

        }
    }

    # build base url for inline images
    my $SessionID = '';
    if ( $Self->{SessionID} && !$Self->{SessionIDCookie} ) {
        $SessionID = ';' . $Self->{SessionName} . '=' . $Self->{SessionID};
    }

    # replace inline images in content with runtime url to images
    my $AttachmentLink = $Self->{Baselink} . $Param{URL};
    $Param{Data}->{Content} =~ s{
        (=|"|')cid:(.*?)("|'|>|\/>|\s)
    }
    {
        my $Start= $1;
        my $ContentID = $2;
        my $End = $3;

        # improve html quality
        if ( $Start ne '"' && $Start ne '\'' ) {
            $Start .= '"';
        }
        if ( $End ne '"' && $End ne '\'' ) {
            $End = '"' . $End;
        }

        # find matching attachment and replace it with runtime url to image
        ATTACHMENT_ID:
        for my $AttachmentID (  sort keys %{ $Param{Attachments} }) {
            next ATTACHMENT_ID if lc $Param{Attachments}->{$AttachmentID}->{ContentID} ne lc "<$ContentID>";
            $ContentID = $AttachmentLink . $AttachmentID . $SessionID;
            last ATTACHMENT_ID;
        }

        # return new runtime url
        $Start . $ContentID . $End;
    }egxi;

    # bug #5053
    # inline images using Content-Location as identifier instead of Content-ID even RFC2557
    # http://www.ietf.org/rfc/rfc2557.txt

    # find matching attachment and replace it with runtlime url to image
    ATTACHMENT:
    for my $AttachmentID ( sort keys %{ $Param{Attachments} } ) {
        next ATTACHMENT if !$Param{Attachments}->{$AttachmentID}->{ContentID};

        # content id cleanup
        $Param{Attachments}->{$AttachmentID}->{ContentID} =~ s/^<//;
        $Param{Attachments}->{$AttachmentID}->{ContentID} =~ s/>$//;

        next ATTACHMENT if !$Param{Attachments}->{$AttachmentID}->{ContentID};

        $Param{Data}->{Content} =~ s{
        (=|"|')(\Q$Param{Attachments}->{$AttachmentID}->{ContentID}\E)("|'|>|\/>|\s)
    }
    {
        my $Start= $1;
        my $ContentID = $2;
        my $End = $3;

        # improve html quality
        if ( $Start ne '"' && $Start ne '\'' ) {
            $Start .= '"';
        }
        if ( $End ne '"' && $End ne '\'' ) {
            $End = '"' . $End;
        }

        # return new runtime url
        $ContentID = $AttachmentLink . $AttachmentID . $SessionID;
        $Start . $ContentID . $End;
    }egxi;
    }

    return %{ $Param{Data} };
}
</pre></div>

<p>serve a rich text (HTML) document for local view inside of an <code>iframe</code> in correct charset and with correct
links for inline documents.</p>

<p>By default, all inline/active content (such as <code>script</code>, <code>object</code>, <code>applet</code> or <code>embed</code> tags)
will be stripped. If there are external images, they will be stripped too,
but a message will be shown allowing the user to reload the page showing the external images.</p>

<pre>    my %HTMLFile = $LayoutObject-&gt;RichTextDocumentServe(
        Data =&gt; {
            Content     =&gt; $HTMLBodyRef,
            ContentType =&gt; 'text/html; charset=&quot;iso-8859-1&quot;',
        },
        URL               =&gt; 'AgentTicketAttachment;Subaction=HTMLView;ArticleID=123;FileID=',
        Attachments       =&gt; \%AttachmentListOfInlineAttachments,

        LoadInlineContent =&gt; 0,     # Serve the document including all inline content. WARNING: This might be dangerous.

        LoadExternalImages =&gt; 0,    # Load external images? If this is 0, a message will be included if
                                    # external images were found and removed.
    );
</pre><h2 id="RichTextDocumentCleanup">RichTextDocumentCleanup()</h2>

<p><a href="#" onclick="toggleCode('method_RichTextDocumentCleanup');return false;">[Source]</a></p>
                                        <div class="method-source-code" id="method_RichTextDocumentCleanup">
                                        <pre>

sub RichTextDocumentCleanup {
    my ( $Self, %Param ) = @_;

    # check needed stuff
    for (qw(String)) {
        if ( !defined $Param{$_} ) {
            $Kernel::OM->Get('Kernel::System::Log')->Log(
                Priority => 'error',
                Message  => "Need $_!"
            );
            return;
        }
    }

    $Param{String} = $Kernel::OM->Get('Kernel::System::HTMLUtils')->DocumentCleanup(
        String => $Param{String},
    );

    return $Param{String};
}
</pre></div>

<p>please see <a href="http://search.cpan.org/perldoc?Kernel%3A%3ASystem%3A%3AHTML%3A%3ALayout%3A%3ADocumentCleanup%28%29">Kernel::System::HTML::Layout::DocumentCleanup()</a></p>

<h1 id="TERMS_AND_CONDITIONS">TERMS AND CONDITIONS <a href="#TOP" class="toplink"><img alt="^" src="../../../up.gif" /></a></h1>

<p>This software is part of the OTRS project (<a href="http://otrs.org/">http://otrs.org/</a>).</p>

<p>This software comes with ABSOLUTELY NO WARRANTY. For details, see
the enclosed file COPYING for license information (AGPL). If you
did not receive this file, see <a href="http://www.gnu.org/licenses/agpl.txt">http://www.gnu.org/licenses/agpl.txt</a>.</p>


</div><div class="footer">generated by <a href="http://search.cpan.org/perldoc?Pod%3A%3AProjectDocs">Pod::ProjectDocs</a></div></body>
</html>
